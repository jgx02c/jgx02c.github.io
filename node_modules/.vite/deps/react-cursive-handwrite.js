import {
  require_react
} from "./chunk-ZVMIEU5R.js";
import {
  __commonJS,
  __toESM
} from "./chunk-UXIASGQL.js";

// node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React = require_react();
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
          return isArrayImpl(a);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown;
        var specialPropRefWarningShown;
        var didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function warnIfStringRefCannotBeAutoConverted(config, self) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        function defineKeyPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingKey = function() {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
        }
        function defineRefPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingRef = function() {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
        }
        var ReactElement = function(type, key, ref, self, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function jsxDEV(type, config, maybeKey, source, self) {
          {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            if (maybeKey !== void 0) {
              {
                checkKeyStringCoercion(maybeKey);
              }
              key = "" + maybeKey;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            if (hasValidRef(config)) {
              ref = config.ref;
              warnIfStringRefCannotBeAutoConverted(config, self);
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
            return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function isValidElement(object) {
          {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
        }
        function getDeclarationErrorAddendum() {
          {
            if (ReactCurrentOwner$1.current) {
              var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
        }
        function getSourceInfoErrorAddendum(source) {
          {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
        }
        function validateExplicitKey(element, parentType) {
          {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          {
            if (typeof node !== "object") {
              return;
            }
            if (isArray(node)) {
              for (var i = 0; i < node.length; i++) {
                var child = node[i];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
          {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendum(source);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
            var element = jsxDEV(type, props, key, source, self);
            if (element == null) {
              return element;
            }
            if (validType) {
              var children = props.children;
              if (children !== void 0) {
                if (isStaticChildren) {
                  if (isArray(children)) {
                    for (var i = 0; i < children.length; i++) {
                      validateChildKeys(children[i], type);
                    }
                    if (Object.freeze) {
                      Object.freeze(children);
                    }
                  } else {
                    error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                  }
                } else {
                  validateChildKeys(children, type);
                }
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
        }
        function jsxWithValidationStatic(type, props, key) {
          {
            return jsxWithValidation(type, props, key, true);
          }
        }
        function jsxWithValidationDynamic(type, props, key) {
          {
            return jsxWithValidation(type, props, key, false);
          }
        }
        var jsx = jsxWithValidationDynamic;
        var jsxs = jsxWithValidationStatic;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsx = jsx;
        exports.jsxs = jsxs;
      })();
    }
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_jsx_runtime_development();
    }
  }
});

// node_modules/motion-utils/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/motion-utils/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function addUniqueItem(arr, item) {
      if (arr.indexOf(item) === -1)
        arr.push(item);
    }
    function removeItem(arr, item) {
      const index = arr.indexOf(item);
      if (index > -1)
        arr.splice(index, 1);
    }
    function moveItem([...arr], fromIndex, toIndex) {
      const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;
      if (startIndex >= 0 && startIndex < arr.length) {
        const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;
        const [item] = arr.splice(fromIndex, 1);
        arr.splice(endIndex, 0, item);
      }
      return arr;
    }
    var clamp = (min, max, v) => {
      if (v > max)
        return max;
      if (v < min)
        return min;
      return v;
    };
    exports.warning = () => {
    };
    exports.invariant = () => {
    };
    if (true) {
      exports.warning = (check, message) => {
        if (!check && typeof console !== "undefined") {
          console.warn(message);
        }
      };
      exports.invariant = (check, message) => {
        if (!check) {
          throw new Error(message);
        }
      };
    }
    var MotionGlobalConfig = {};
    var isNumericalString = (v) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v);
    var isZeroValueString = (v) => /^0[^.\s]+$/u.test(v);
    function memo(callback) {
      let result;
      return () => {
        if (result === void 0)
          result = callback();
        return result;
      };
    }
    var noop = (any) => any;
    var combineFunctions = (a, b) => (v) => b(a(v));
    var pipe = (...transformers) => transformers.reduce(combineFunctions);
    var progress = (from, to, value) => {
      const toFromDifference = to - from;
      return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
    };
    var SubscriptionManager = class {
      constructor() {
        this.subscriptions = [];
      }
      add(handler) {
        addUniqueItem(this.subscriptions, handler);
        return () => removeItem(this.subscriptions, handler);
      }
      notify(a, b, c) {
        const numSubscriptions = this.subscriptions.length;
        if (!numSubscriptions)
          return;
        if (numSubscriptions === 1) {
          this.subscriptions[0](a, b, c);
        } else {
          for (let i = 0; i < numSubscriptions; i++) {
            const handler = this.subscriptions[i];
            handler && handler(a, b, c);
          }
        }
      }
      getSize() {
        return this.subscriptions.length;
      }
      clear() {
        this.subscriptions.length = 0;
      }
    };
    var secondsToMilliseconds = (seconds) => seconds * 1e3;
    var millisecondsToSeconds = (milliseconds) => milliseconds / 1e3;
    function velocityPerSecond(velocity, frameDuration) {
      return frameDuration ? velocity * (1e3 / frameDuration) : 0;
    }
    var warned = /* @__PURE__ */ new Set();
    function hasWarned(message) {
      return warned.has(message);
    }
    function warnOnce(condition, message, element) {
      if (condition || warned.has(message))
        return;
      console.warn(message);
      if (element)
        console.warn(element);
      warned.add(message);
    }
    var wrap = (min, max, v) => {
      const rangeSize = max - min;
      return ((v - min) % rangeSize + rangeSize) % rangeSize + min;
    };
    var calcBezier = (t, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1) * t;
    var subdivisionPrecision = 1e-7;
    var subdivisionMaxIterations = 12;
    function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
      let currentX;
      let currentT;
      let i = 0;
      do {
        currentT = lowerBound + (upperBound - lowerBound) / 2;
        currentX = calcBezier(currentT, mX1, mX2) - x;
        if (currentX > 0) {
          upperBound = currentT;
        } else {
          lowerBound = currentT;
        }
      } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
      return currentT;
    }
    function cubicBezier(mX1, mY1, mX2, mY2) {
      if (mX1 === mY1 && mX2 === mY2)
        return noop;
      const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
      return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
    }
    var mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
    var reverseEasing = (easing) => (p) => 1 - easing(1 - p);
    var backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);
    var backIn = reverseEasing(backOut);
    var backInOut = mirrorEasing(backIn);
    var anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
    var circIn = (p) => 1 - Math.sin(Math.acos(p));
    var circOut = reverseEasing(circIn);
    var circInOut = mirrorEasing(circIn);
    var easeIn = cubicBezier(0.42, 0, 1, 1);
    var easeOut = cubicBezier(0, 0, 0.58, 1);
    var easeInOut = cubicBezier(0.42, 0, 0.58, 1);
    function steps(numSteps, direction = "end") {
      return (progress2) => {
        progress2 = direction === "end" ? Math.min(progress2, 0.999) : Math.max(progress2, 1e-3);
        const expanded = progress2 * numSteps;
        const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
        return clamp(0, 1, rounded / numSteps);
      };
    }
    var isEasingArray = (ease) => {
      return Array.isArray(ease) && typeof ease[0] !== "number";
    };
    function getEasingForSegment(easing, i) {
      return isEasingArray(easing) ? easing[wrap(0, easing.length, i)] : easing;
    }
    var isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";
    var easingLookup = {
      linear: noop,
      easeIn,
      easeInOut,
      easeOut,
      circIn,
      circInOut,
      circOut,
      backIn,
      backInOut,
      backOut,
      anticipate
    };
    var isValidEasing = (easing) => {
      return typeof easing === "string";
    };
    var easingDefinitionToFunction = (definition) => {
      if (isBezierDefinition(definition)) {
        exports.invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
        const [x1, y1, x2, y2] = definition;
        return cubicBezier(x1, y1, x2, y2);
      } else if (isValidEasing(definition)) {
        exports.invariant(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`);
        return easingLookup[definition];
      }
      return definition;
    };
    exports.MotionGlobalConfig = MotionGlobalConfig;
    exports.SubscriptionManager = SubscriptionManager;
    exports.addUniqueItem = addUniqueItem;
    exports.anticipate = anticipate;
    exports.backIn = backIn;
    exports.backInOut = backInOut;
    exports.backOut = backOut;
    exports.circIn = circIn;
    exports.circInOut = circInOut;
    exports.circOut = circOut;
    exports.clamp = clamp;
    exports.cubicBezier = cubicBezier;
    exports.easeIn = easeIn;
    exports.easeInOut = easeInOut;
    exports.easeOut = easeOut;
    exports.easingDefinitionToFunction = easingDefinitionToFunction;
    exports.getEasingForSegment = getEasingForSegment;
    exports.hasWarned = hasWarned;
    exports.isBezierDefinition = isBezierDefinition;
    exports.isEasingArray = isEasingArray;
    exports.isNumericalString = isNumericalString;
    exports.isZeroValueString = isZeroValueString;
    exports.memo = memo;
    exports.millisecondsToSeconds = millisecondsToSeconds;
    exports.mirrorEasing = mirrorEasing;
    exports.moveItem = moveItem;
    exports.noop = noop;
    exports.pipe = pipe;
    exports.progress = progress;
    exports.removeItem = removeItem;
    exports.reverseEasing = reverseEasing;
    exports.secondsToMilliseconds = secondsToMilliseconds;
    exports.steps = steps;
    exports.velocityPerSecond = velocityPerSecond;
    exports.warnOnce = warnOnce;
    exports.wrap = wrap;
  }
});

// node_modules/motion-dom/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/motion-dom/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var motionUtils = require_cjs();
    var stepsOrder = [
      "setup",
      // Compute
      "read",
      // Read
      "resolveKeyframes",
      // Write/Read/Write/Read
      "preUpdate",
      // Compute
      "update",
      // Compute
      "preRender",
      // Compute
      "render",
      // Write
      "postRender"
      // Compute
    ];
    var statsBuffer = {
      value: null,
      addProjectionMetrics: null
    };
    function createRenderStep(runNextFrame, stepName) {
      let thisFrame = /* @__PURE__ */ new Set();
      let nextFrame = /* @__PURE__ */ new Set();
      let isProcessing = false;
      let flushNextFrame = false;
      const toKeepAlive = /* @__PURE__ */ new WeakSet();
      let latestFrameData = {
        delta: 0,
        timestamp: 0,
        isProcessing: false
      };
      let numCalls = 0;
      function triggerCallback(callback) {
        if (toKeepAlive.has(callback)) {
          step.schedule(callback);
          runNextFrame();
        }
        numCalls++;
        callback(latestFrameData);
      }
      const step = {
        /**
         * Schedule a process to run on the next frame.
         */
        schedule: (callback, keepAlive = false, immediate = false) => {
          const addToCurrentFrame = immediate && isProcessing;
          const queue = addToCurrentFrame ? thisFrame : nextFrame;
          if (keepAlive)
            toKeepAlive.add(callback);
          if (!queue.has(callback))
            queue.add(callback);
          return callback;
        },
        /**
         * Cancel the provided callback from running on the next frame.
         */
        cancel: (callback) => {
          nextFrame.delete(callback);
          toKeepAlive.delete(callback);
        },
        /**
         * Execute all schedule callbacks.
         */
        process: (frameData2) => {
          latestFrameData = frameData2;
          if (isProcessing) {
            flushNextFrame = true;
            return;
          }
          isProcessing = true;
          [thisFrame, nextFrame] = [nextFrame, thisFrame];
          thisFrame.forEach(triggerCallback);
          if (stepName && statsBuffer.value) {
            statsBuffer.value.frameloop[stepName].push(numCalls);
          }
          numCalls = 0;
          thisFrame.clear();
          isProcessing = false;
          if (flushNextFrame) {
            flushNextFrame = false;
            step.process(frameData2);
          }
        }
      };
      return step;
    }
    var maxElapsed = 40;
    function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
      let runNextFrame = false;
      let useDefaultElapsed = true;
      const state = {
        delta: 0,
        timestamp: 0,
        isProcessing: false
      };
      const flagRunNextFrame = () => runNextFrame = true;
      const steps = stepsOrder.reduce((acc, key) => {
        acc[key] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key : void 0);
        return acc;
      }, {});
      const { setup, read, resolveKeyframes, preUpdate, update, preRender, render, postRender } = steps;
      const processBatch = () => {
        const timestamp = motionUtils.MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
        runNextFrame = false;
        if (!motionUtils.MotionGlobalConfig.useManualTiming) {
          state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
        }
        state.timestamp = timestamp;
        state.isProcessing = true;
        setup.process(state);
        read.process(state);
        resolveKeyframes.process(state);
        preUpdate.process(state);
        update.process(state);
        preRender.process(state);
        render.process(state);
        postRender.process(state);
        state.isProcessing = false;
        if (runNextFrame && allowKeepAlive) {
          useDefaultElapsed = false;
          scheduleNextBatch(processBatch);
        }
      };
      const wake = () => {
        runNextFrame = true;
        useDefaultElapsed = true;
        if (!state.isProcessing) {
          scheduleNextBatch(processBatch);
        }
      };
      const schedule = stepsOrder.reduce((acc, key) => {
        const step = steps[key];
        acc[key] = (process2, keepAlive = false, immediate = false) => {
          if (!runNextFrame)
            wake();
          return step.schedule(process2, keepAlive, immediate);
        };
        return acc;
      }, {});
      const cancel = (process2) => {
        for (let i = 0; i < stepsOrder.length; i++) {
          steps[stepsOrder[i]].cancel(process2);
        }
      };
      return { schedule, cancel, state, steps };
    }
    var { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : motionUtils.noop, true);
    var now;
    function clearTime() {
      now = void 0;
    }
    var time = {
      now: () => {
        if (now === void 0) {
          time.set(frameData.isProcessing || motionUtils.MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
        }
        return now;
      },
      set: (newTime) => {
        now = newTime;
        queueMicrotask(clearTime);
      }
    };
    var activeAnimations = {
      layout: 0,
      mainThread: 0,
      waapi: 0
    };
    var checkStringStartsWith = (token) => (key) => typeof key === "string" && key.startsWith(token);
    var isCSSVariableName = checkStringStartsWith("--");
    var startsAsVariableToken = checkStringStartsWith("var(--");
    var isCSSVariableToken = (value) => {
      const startsWithToken = startsAsVariableToken(value);
      if (!startsWithToken)
        return false;
      return singleCssVariableRegex.test(value.split("/*")[0].trim());
    };
    var singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
    var number = {
      test: (v) => typeof v === "number",
      parse: parseFloat,
      transform: (v) => v
    };
    var alpha = {
      ...number,
      transform: (v) => motionUtils.clamp(0, 1, v)
    };
    var scale = {
      ...number,
      default: 1
    };
    var sanitize = (v) => Math.round(v * 1e5) / 1e5;
    var floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
    function isNullish(v) {
      return v == null;
    }
    var singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
    var isColorString = (type, testProp) => (v) => {
      return Boolean(typeof v === "string" && singleColorRegex.test(v) && v.startsWith(type) || testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp));
    };
    var splitColor = (aName, bName, cName) => (v) => {
      if (typeof v !== "string")
        return v;
      const [a, b, c, alpha2] = v.match(floatRegex);
      return {
        [aName]: parseFloat(a),
        [bName]: parseFloat(b),
        [cName]: parseFloat(c),
        alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
      };
    };
    var clampRgbUnit = (v) => motionUtils.clamp(0, 255, v);
    var rgbUnit = {
      ...number,
      transform: (v) => Math.round(clampRgbUnit(v))
    };
    var rgba = {
      test: isColorString("rgb", "red"),
      parse: splitColor("red", "green", "blue"),
      transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
    };
    function parseHex(v) {
      let r = "";
      let g = "";
      let b = "";
      let a = "";
      if (v.length > 5) {
        r = v.substring(1, 3);
        g = v.substring(3, 5);
        b = v.substring(5, 7);
        a = v.substring(7, 9);
      } else {
        r = v.substring(1, 2);
        g = v.substring(2, 3);
        b = v.substring(3, 4);
        a = v.substring(4, 5);
        r += r;
        g += g;
        b += b;
        a += a;
      }
      return {
        red: parseInt(r, 16),
        green: parseInt(g, 16),
        blue: parseInt(b, 16),
        alpha: a ? parseInt(a, 16) / 255 : 1
      };
    }
    var hex = {
      test: isColorString("#"),
      parse: parseHex,
      transform: rgba.transform
    };
    var createUnitType = (unit) => ({
      test: (v) => typeof v === "string" && v.endsWith(unit) && v.split(" ").length === 1,
      parse: parseFloat,
      transform: (v) => `${v}${unit}`
    });
    var degrees = createUnitType("deg");
    var percent = createUnitType("%");
    var px = createUnitType("px");
    var vh = createUnitType("vh");
    var vw = createUnitType("vw");
    var progressPercentage = (() => ({
      ...percent,
      parse: (v) => percent.parse(v) / 100,
      transform: (v) => percent.transform(v * 100)
    }))();
    var hsla = {
      test: isColorString("hsl", "hue"),
      parse: splitColor("hue", "saturation", "lightness"),
      transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
        return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
      }
    };
    var color = {
      test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),
      parse: (v) => {
        if (rgba.test(v)) {
          return rgba.parse(v);
        } else if (hsla.test(v)) {
          return hsla.parse(v);
        } else {
          return hex.parse(v);
        }
      },
      transform: (v) => {
        return typeof v === "string" ? v : v.hasOwnProperty("red") ? rgba.transform(v) : hsla.transform(v);
      }
    };
    var colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
    function test(v) {
      var _a, _b;
      return isNaN(v) && typeof v === "string" && (((_a = v.match(floatRegex)) == null ? void 0 : _a.length) || 0) + (((_b = v.match(colorRegex)) == null ? void 0 : _b.length) || 0) > 0;
    }
    var NUMBER_TOKEN = "number";
    var COLOR_TOKEN = "color";
    var VAR_TOKEN = "var";
    var VAR_FUNCTION_TOKEN = "var(";
    var SPLIT_TOKEN = "${}";
    var complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
    function analyseComplexValue(value) {
      const originalValue = value.toString();
      const values = [];
      const indexes = {
        color: [],
        number: [],
        var: []
      };
      const types = [];
      let i = 0;
      const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
        if (color.test(parsedValue)) {
          indexes.color.push(i);
          types.push(COLOR_TOKEN);
          values.push(color.parse(parsedValue));
        } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
          indexes.var.push(i);
          types.push(VAR_TOKEN);
          values.push(parsedValue);
        } else {
          indexes.number.push(i);
          types.push(NUMBER_TOKEN);
          values.push(parseFloat(parsedValue));
        }
        ++i;
        return SPLIT_TOKEN;
      });
      const split = tokenised.split(SPLIT_TOKEN);
      return { values, split, indexes, types };
    }
    function parseComplexValue(v) {
      return analyseComplexValue(v).values;
    }
    function createTransformer(source) {
      const { split, types } = analyseComplexValue(source);
      const numSections = split.length;
      return (v) => {
        let output = "";
        for (let i = 0; i < numSections; i++) {
          output += split[i];
          if (v[i] !== void 0) {
            const type = types[i];
            if (type === NUMBER_TOKEN) {
              output += sanitize(v[i]);
            } else if (type === COLOR_TOKEN) {
              output += color.transform(v[i]);
            } else {
              output += v[i];
            }
          }
        }
        return output;
      };
    }
    var convertNumbersToZero = (v) => typeof v === "number" ? 0 : v;
    function getAnimatableNone$1(v) {
      const parsed = parseComplexValue(v);
      const transformer = createTransformer(v);
      return transformer(parsed.map(convertNumbersToZero));
    }
    var complex = {
      test,
      parse: parseComplexValue,
      createTransformer,
      getAnimatableNone: getAnimatableNone$1
    };
    function hueToRgb(p, q, t) {
      if (t < 0)
        t += 1;
      if (t > 1)
        t -= 1;
      if (t < 1 / 6)
        return p + (q - p) * 6 * t;
      if (t < 1 / 2)
        return q;
      if (t < 2 / 3)
        return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }
    function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
      hue /= 360;
      saturation /= 100;
      lightness /= 100;
      let red = 0;
      let green = 0;
      let blue = 0;
      if (!saturation) {
        red = green = blue = lightness;
      } else {
        const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
        const p = 2 * lightness - q;
        red = hueToRgb(p, q, hue + 1 / 3);
        green = hueToRgb(p, q, hue);
        blue = hueToRgb(p, q, hue - 1 / 3);
      }
      return {
        red: Math.round(red * 255),
        green: Math.round(green * 255),
        blue: Math.round(blue * 255),
        alpha: alpha2
      };
    }
    function mixImmediate(a, b) {
      return (p) => p > 0 ? b : a;
    }
    var mixNumber$1 = (from, to, progress) => {
      return from + (to - from) * progress;
    };
    var mixLinearColor = (from, to, v) => {
      const fromExpo = from * from;
      const expo = v * (to * to - fromExpo) + fromExpo;
      return expo < 0 ? 0 : Math.sqrt(expo);
    };
    var colorTypes = [hex, rgba, hsla];
    var getColorType = (v) => colorTypes.find((type) => type.test(v));
    function asRGBA(color2) {
      const type = getColorType(color2);
      motionUtils.warning(Boolean(type), `'${color2}' is not an animatable color. Use the equivalent color code instead.`);
      if (!Boolean(type))
        return false;
      let model = type.parse(color2);
      if (type === hsla) {
        model = hslaToRgba(model);
      }
      return model;
    }
    var mixColor = (from, to) => {
      const fromRGBA = asRGBA(from);
      const toRGBA = asRGBA(to);
      if (!fromRGBA || !toRGBA) {
        return mixImmediate(from, to);
      }
      const blended = { ...fromRGBA };
      return (v) => {
        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
        blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v);
        return rgba.transform(blended);
      };
    };
    var invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
    function mixVisibility(origin, target) {
      if (invisibleValues.has(origin)) {
        return (p) => p <= 0 ? origin : target;
      } else {
        return (p) => p >= 1 ? target : origin;
      }
    }
    function mixNumber(a, b) {
      return (p) => mixNumber$1(a, b, p);
    }
    function getMixer(a) {
      if (typeof a === "number") {
        return mixNumber;
      } else if (typeof a === "string") {
        return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;
      } else if (Array.isArray(a)) {
        return mixArray;
      } else if (typeof a === "object") {
        return color.test(a) ? mixColor : mixObject;
      }
      return mixImmediate;
    }
    function mixArray(a, b) {
      const output = [...a];
      const numValues = output.length;
      const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));
      return (p) => {
        for (let i = 0; i < numValues; i++) {
          output[i] = blendValue[i](p);
        }
        return output;
      };
    }
    function mixObject(a, b) {
      const output = { ...a, ...b };
      const blendValue = {};
      for (const key in output) {
        if (a[key] !== void 0 && b[key] !== void 0) {
          blendValue[key] = getMixer(a[key])(a[key], b[key]);
        }
      }
      return (v) => {
        for (const key in blendValue) {
          output[key] = blendValue[key](v);
        }
        return output;
      };
    }
    function matchOrder(origin, target) {
      const orderedOrigin = [];
      const pointers = { color: 0, var: 0, number: 0 };
      for (let i = 0; i < target.values.length; i++) {
        const type = target.types[i];
        const originIndex = origin.indexes[type][pointers[type]];
        const originValue = origin.values[originIndex] ?? 0;
        orderedOrigin[i] = originValue;
        pointers[type]++;
      }
      return orderedOrigin;
    }
    var mixComplex = (origin, target) => {
      const template = complex.createTransformer(target);
      const originStats = analyseComplexValue(origin);
      const targetStats = analyseComplexValue(target);
      const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
      if (canInterpolate) {
        if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
          return mixVisibility(origin, target);
        }
        return motionUtils.pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
      } else {
        motionUtils.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
        return mixImmediate(origin, target);
      }
    };
    function mix(from, to, p) {
      if (typeof from === "number" && typeof to === "number" && typeof p === "number") {
        return mixNumber$1(from, to, p);
      }
      const mixer = getMixer(from);
      return mixer(from, to);
    }
    var frameloopDriver = (update) => {
      const passTimestamp = ({ timestamp }) => update(timestamp);
      return {
        start: () => frame.update(passTimestamp, true),
        stop: () => cancelFrame(passTimestamp),
        /**
         * If we're processing this frame we can use the
         * framelocked timestamp to keep things in sync.
         */
        now: () => frameData.isProcessing ? frameData.timestamp : time.now()
      };
    };
    var generateLinearEasing = (easing, duration, resolution = 10) => {
      let points = "";
      const numPoints = Math.max(Math.round(duration / resolution), 2);
      for (let i = 0; i < numPoints; i++) {
        points += easing(i / (numPoints - 1)) + ", ";
      }
      return `linear(${points.substring(0, points.length - 2)})`;
    };
    var maxGeneratorDuration = 2e4;
    function calcGeneratorDuration(generator) {
      let duration = 0;
      const timeStep = 50;
      let state = generator.next(duration);
      while (!state.done && duration < maxGeneratorDuration) {
        duration += timeStep;
        state = generator.next(duration);
      }
      return duration >= maxGeneratorDuration ? Infinity : duration;
    }
    function createGeneratorEasing(options, scale2 = 100, createGenerator) {
      const generator = createGenerator({ ...options, keyframes: [0, scale2] });
      const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
      return {
        type: "keyframes",
        ease: (progress) => {
          return generator.next(duration * progress).value / scale2;
        },
        duration: motionUtils.millisecondsToSeconds(duration)
      };
    }
    var velocitySampleDuration = 5;
    function calcGeneratorVelocity(resolveValue, t, current2) {
      const prevT = Math.max(t - velocitySampleDuration, 0);
      return motionUtils.velocityPerSecond(current2 - resolveValue(prevT), t - prevT);
    }
    var springDefaults = {
      // Default spring physics
      stiffness: 100,
      damping: 10,
      mass: 1,
      velocity: 0,
      // Default duration/bounce-based options
      duration: 800,
      // in ms
      bounce: 0.3,
      visualDuration: 0.3,
      // in seconds
      // Rest thresholds
      restSpeed: {
        granular: 0.01,
        default: 2
      },
      restDelta: {
        granular: 5e-3,
        default: 0.5
      },
      // Limits
      minDuration: 0.01,
      // in seconds
      maxDuration: 10,
      // in seconds
      minDamping: 0.05,
      maxDamping: 1
    };
    var safeMin = 1e-3;
    function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {
      let envelope;
      let derivative;
      motionUtils.warning(duration <= motionUtils.secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less");
      let dampingRatio = 1 - bounce;
      dampingRatio = motionUtils.clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
      duration = motionUtils.clamp(springDefaults.minDuration, springDefaults.maxDuration, motionUtils.millisecondsToSeconds(duration));
      if (dampingRatio < 1) {
        envelope = (undampedFreq2) => {
          const exponentialDecay = undampedFreq2 * dampingRatio;
          const delta = exponentialDecay * duration;
          const a = exponentialDecay - velocity;
          const b = calcAngularFreq(undampedFreq2, dampingRatio);
          const c = Math.exp(-delta);
          return safeMin - a / b * c;
        };
        derivative = (undampedFreq2) => {
          const exponentialDecay = undampedFreq2 * dampingRatio;
          const delta = exponentialDecay * duration;
          const d = delta * velocity + velocity;
          const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
          const f = Math.exp(-delta);
          const g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
          const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
          return factor * ((d - e) * f) / g;
        };
      } else {
        envelope = (undampedFreq2) => {
          const a = Math.exp(-undampedFreq2 * duration);
          const b = (undampedFreq2 - velocity) * duration + 1;
          return -safeMin + a * b;
        };
        derivative = (undampedFreq2) => {
          const a = Math.exp(-undampedFreq2 * duration);
          const b = (velocity - undampedFreq2) * (duration * duration);
          return a * b;
        };
      }
      const initialGuess = 5 / duration;
      const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
      duration = motionUtils.secondsToMilliseconds(duration);
      if (isNaN(undampedFreq)) {
        return {
          stiffness: springDefaults.stiffness,
          damping: springDefaults.damping,
          duration
        };
      } else {
        const stiffness = Math.pow(undampedFreq, 2) * mass;
        return {
          stiffness,
          damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
          duration
        };
      }
    }
    var rootIterations = 12;
    function approximateRoot(envelope, derivative, initialGuess) {
      let result = initialGuess;
      for (let i = 1; i < rootIterations; i++) {
        result = result - envelope(result) / derivative(result);
      }
      return result;
    }
    function calcAngularFreq(undampedFreq, dampingRatio) {
      return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
    }
    var durationKeys = ["duration", "bounce"];
    var physicsKeys = ["stiffness", "damping", "mass"];
    function isSpringType(options, keys) {
      return keys.some((key) => options[key] !== void 0);
    }
    function getSpringOptions(options) {
      let springOptions = {
        velocity: springDefaults.velocity,
        stiffness: springDefaults.stiffness,
        damping: springDefaults.damping,
        mass: springDefaults.mass,
        isResolvedFromDuration: false,
        ...options
      };
      if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
        if (options.visualDuration) {
          const visualDuration = options.visualDuration;
          const root = 2 * Math.PI / (visualDuration * 1.2);
          const stiffness = root * root;
          const damping = 2 * motionUtils.clamp(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
          springOptions = {
            ...springOptions,
            mass: springDefaults.mass,
            stiffness,
            damping
          };
        } else {
          const derived = findSpring(options);
          springOptions = {
            ...springOptions,
            ...derived,
            mass: springDefaults.mass
          };
          springOptions.isResolvedFromDuration = true;
        }
      }
      return springOptions;
    }
    function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
      const options = typeof optionsOrVisualDuration !== "object" ? {
        visualDuration: optionsOrVisualDuration,
        keyframes: [0, 1],
        bounce
      } : optionsOrVisualDuration;
      let { restSpeed, restDelta } = options;
      const origin = options.keyframes[0];
      const target = options.keyframes[options.keyframes.length - 1];
      const state = { done: false, value: origin };
      const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
        ...options,
        velocity: -motionUtils.millisecondsToSeconds(options.velocity || 0)
      });
      const initialVelocity = velocity || 0;
      const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
      const initialDelta = target - origin;
      const undampedAngularFreq = motionUtils.millisecondsToSeconds(Math.sqrt(stiffness / mass));
      const isGranularScale = Math.abs(initialDelta) < 5;
      restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
      restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
      let resolveSpring;
      if (dampingRatio < 1) {
        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
        resolveSpring = (t) => {
          const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
          return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
        };
      } else if (dampingRatio === 1) {
        resolveSpring = (t) => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
      } else {
        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
        resolveSpring = (t) => {
          const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
          const freqForT = Math.min(dampedAngularFreq * t, 300);
          return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
        };
      }
      const generator = {
        calculatedDuration: isResolvedFromDuration ? duration || null : null,
        next: (t) => {
          const current2 = resolveSpring(t);
          if (!isResolvedFromDuration) {
            let currentVelocity = t === 0 ? initialVelocity : 0;
            if (dampingRatio < 1) {
              currentVelocity = t === 0 ? motionUtils.secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t, current2);
            }
            const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
            const isBelowDisplacementThreshold = Math.abs(target - current2) <= restDelta;
            state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
          } else {
            state.done = t >= duration;
          }
          state.value = state.done ? target : current2;
          return state;
        },
        toString: () => {
          const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
          const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);
          return calculatedDuration + "ms " + easing;
        },
        toTransition: () => {
        }
      };
      return generator;
    }
    spring.applyToOptions = (options) => {
      const generatorOptions = createGeneratorEasing(options, 100, spring);
      options.ease = generatorOptions.ease;
      options.duration = motionUtils.secondsToMilliseconds(generatorOptions.duration);
      options.type = "keyframes";
      return options;
    };
    function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed }) {
      const origin = keyframes2[0];
      const state = {
        done: false,
        value: origin
      };
      const isOutOfBounds = (v) => min !== void 0 && v < min || max !== void 0 && v > max;
      const nearestBoundary = (v) => {
        if (min === void 0)
          return max;
        if (max === void 0)
          return min;
        return Math.abs(min - v) < Math.abs(max - v) ? min : max;
      };
      let amplitude = power * velocity;
      const ideal = origin + amplitude;
      const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
      if (target !== ideal)
        amplitude = target - origin;
      const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);
      const calcLatest = (t) => target + calcDelta(t);
      const applyFriction = (t) => {
        const delta = calcDelta(t);
        const latest = calcLatest(t);
        state.done = Math.abs(delta) <= restDelta;
        state.value = state.done ? target : latest;
      };
      let timeReachedBoundary;
      let spring$1;
      const checkCatchBoundary = (t) => {
        if (!isOutOfBounds(state.value))
          return;
        timeReachedBoundary = t;
        spring$1 = spring({
          keyframes: [state.value, nearestBoundary(state.value)],
          velocity: calcGeneratorVelocity(calcLatest, t, state.value),
          // TODO: This should be passing * 1000
          damping: bounceDamping,
          stiffness: bounceStiffness,
          restDelta,
          restSpeed
        });
      };
      checkCatchBoundary(0);
      return {
        calculatedDuration: null,
        next: (t) => {
          let hasUpdatedFrame = false;
          if (!spring$1 && timeReachedBoundary === void 0) {
            hasUpdatedFrame = true;
            applyFriction(t);
            checkCatchBoundary(t);
          }
          if (timeReachedBoundary !== void 0 && t >= timeReachedBoundary) {
            return spring$1.next(t - timeReachedBoundary);
          } else {
            !hasUpdatedFrame && applyFriction(t);
            return state;
          }
        }
      };
    }
    function createMixers(output, ease, customMixer) {
      const mixers = [];
      const mixerFactory = customMixer || motionUtils.MotionGlobalConfig.mix || mix;
      const numMixers = output.length - 1;
      for (let i = 0; i < numMixers; i++) {
        let mixer = mixerFactory(output[i], output[i + 1]);
        if (ease) {
          const easingFunction = Array.isArray(ease) ? ease[i] || motionUtils.noop : ease;
          mixer = motionUtils.pipe(easingFunction, mixer);
        }
        mixers.push(mixer);
      }
      return mixers;
    }
    function interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {
      const inputLength = input.length;
      motionUtils.invariant(inputLength === output.length, "Both input and output ranges must be the same length");
      if (inputLength === 1)
        return () => output[0];
      if (inputLength === 2 && output[0] === output[1])
        return () => output[1];
      const isZeroDeltaRange = input[0] === input[1];
      if (input[0] > input[inputLength - 1]) {
        input = [...input].reverse();
        output = [...output].reverse();
      }
      const mixers = createMixers(output, ease, mixer);
      const numMixers = mixers.length;
      const interpolator = (v) => {
        if (isZeroDeltaRange && v < input[0])
          return output[0];
        let i = 0;
        if (numMixers > 1) {
          for (; i < input.length - 2; i++) {
            if (v < input[i + 1])
              break;
          }
        }
        const progressInRange = motionUtils.progress(input[i], input[i + 1], v);
        return mixers[i](progressInRange);
      };
      return isClamp ? (v) => interpolator(motionUtils.clamp(input[0], input[inputLength - 1], v)) : interpolator;
    }
    function fillOffset(offset, remaining) {
      const min = offset[offset.length - 1];
      for (let i = 1; i <= remaining; i++) {
        const offsetProgress = motionUtils.progress(0, remaining, i);
        offset.push(mixNumber$1(min, 1, offsetProgress));
      }
    }
    function defaultOffset(arr) {
      const offset = [0];
      fillOffset(offset, arr.length - 1);
      return offset;
    }
    function convertOffsetToTimes(offset, duration) {
      return offset.map((o) => o * duration);
    }
    function defaultEasing(values, easing) {
      return values.map(() => easing || motionUtils.easeInOut).splice(0, values.length - 1);
    }
    function keyframes({ duration = 300, keyframes: keyframeValues, times, ease = "easeInOut" }) {
      const easingFunctions = motionUtils.isEasingArray(ease) ? ease.map(motionUtils.easingDefinitionToFunction) : motionUtils.easingDefinitionToFunction(ease);
      const state = {
        done: false,
        value: keyframeValues[0]
      };
      const absoluteTimes = convertOffsetToTimes(
        // Only use the provided offsets if they're the correct length
        // TODO Maybe we should warn here if there's a length mismatch
        times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
        duration
      );
      const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
        ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
      });
      return {
        calculatedDuration: duration,
        next: (t) => {
          state.value = mapTimeToKeyframe(t);
          state.done = t >= duration;
          return state;
        }
      };
    }
    var isNotNull = (value) => value !== null;
    function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe, speed = 1) {
      const resolvedKeyframes = keyframes2.filter(isNotNull);
      const useFirstKeyframe = speed < 0 || repeat && repeatType !== "loop" && repeat % 2 === 1;
      const index = useFirstKeyframe ? 0 : resolvedKeyframes.length - 1;
      return !index || finalKeyframe === void 0 ? resolvedKeyframes[index] : finalKeyframe;
    }
    var transitionTypeMap = {
      decay: inertia,
      inertia,
      tween: keyframes,
      keyframes,
      spring
    };
    function replaceTransitionType(transition) {
      if (typeof transition.type === "string") {
        transition.type = transitionTypeMap[transition.type];
      }
    }
    var WithPromise = class {
      constructor() {
        this.count = 0;
        this.updateFinished();
      }
      get finished() {
        return this._finished;
      }
      updateFinished() {
        this.count++;
        this._finished = new Promise((resolve) => {
          this.resolve = resolve;
        });
      }
      notifyFinished() {
        this.resolve();
      }
      /**
       * Allows the animation to be awaited.
       *
       * @deprecated Use `finished` instead.
       */
      then(onResolve, onReject) {
        return this.finished.then(onResolve, onReject);
      }
    };
    var percentToProgress = (percent2) => percent2 / 100;
    var JSAnimation = class extends WithPromise {
      constructor(options) {
        super();
        this.state = "idle";
        this.startTime = null;
        this.isStopped = false;
        this.currentTime = 0;
        this.holdTime = null;
        this.playbackSpeed = 1;
        this.stop = () => {
          const { motionValue: motionValue2 } = this.options;
          if (motionValue2 && motionValue2.updatedAt !== time.now()) {
            this.tick(time.now());
          }
          this.isStopped = true;
          if (this.state === "idle")
            return;
          this.teardown();
          const { onStop } = this.options;
          onStop && onStop();
        };
        activeAnimations.mainThread++;
        this.options = options;
        this.initAnimation();
        this.play();
        if (options.autoplay === false)
          this.pause();
      }
      initAnimation() {
        const { options } = this;
        replaceTransitionType(options);
        const { type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = options;
        let { keyframes: keyframes$1 } = options;
        const generatorFactory = type || keyframes;
        if (generatorFactory !== keyframes) {
          motionUtils.invariant(keyframes$1.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);
        }
        if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
          this.mixKeyframes = motionUtils.pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
          keyframes$1 = [0, 100];
        }
        const generator = generatorFactory({ ...options, keyframes: keyframes$1 });
        if (repeatType === "mirror") {
          this.mirroredGenerator = generatorFactory({
            ...options,
            keyframes: [...keyframes$1].reverse(),
            velocity: -velocity
          });
        }
        if (generator.calculatedDuration === null) {
          generator.calculatedDuration = calcGeneratorDuration(generator);
        }
        const { calculatedDuration } = generator;
        this.calculatedDuration = calculatedDuration;
        this.resolvedDuration = calculatedDuration + repeatDelay;
        this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;
        this.generator = generator;
      }
      updateTime(timestamp) {
        const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;
        if (this.holdTime !== null) {
          this.currentTime = this.holdTime;
        } else {
          this.currentTime = animationTime;
        }
      }
      tick(timestamp, sample = false) {
        const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration } = this;
        if (this.startTime === null)
          return generator.next(0);
        const { delay = 0, keyframes: keyframes2, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe } = this.options;
        if (this.speed > 0) {
          this.startTime = Math.min(this.startTime, timestamp);
        } else if (this.speed < 0) {
          this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
        }
        if (sample) {
          this.currentTime = timestamp;
        } else {
          this.updateTime(timestamp);
        }
        const timeWithoutDelay = this.currentTime - delay * (this.playbackSpeed >= 0 ? 1 : -1);
        const isInDelayPhase = this.playbackSpeed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
        this.currentTime = Math.max(timeWithoutDelay, 0);
        if (this.state === "finished" && this.holdTime === null) {
          this.currentTime = totalDuration;
        }
        let elapsed = this.currentTime;
        let frameGenerator = generator;
        if (repeat) {
          const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;
          let currentIteration = Math.floor(progress);
          let iterationProgress = progress % 1;
          if (!iterationProgress && progress >= 1) {
            iterationProgress = 1;
          }
          iterationProgress === 1 && currentIteration--;
          currentIteration = Math.min(currentIteration, repeat + 1);
          const isOddIteration = Boolean(currentIteration % 2);
          if (isOddIteration) {
            if (repeatType === "reverse") {
              iterationProgress = 1 - iterationProgress;
              if (repeatDelay) {
                iterationProgress -= repeatDelay / resolvedDuration;
              }
            } else if (repeatType === "mirror") {
              frameGenerator = mirroredGenerator;
            }
          }
          elapsed = motionUtils.clamp(0, 1, iterationProgress) * resolvedDuration;
        }
        const state = isInDelayPhase ? { done: false, value: keyframes2[0] } : frameGenerator.next(elapsed);
        if (mixKeyframes) {
          state.value = mixKeyframes(state.value);
        }
        let { done } = state;
        if (!isInDelayPhase && calculatedDuration !== null) {
          done = this.playbackSpeed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
        }
        const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
        if (isAnimationFinished && type !== inertia) {
          state.value = getFinalKeyframe(keyframes2, this.options, finalKeyframe, this.speed);
        }
        if (onUpdate) {
          onUpdate(state.value);
        }
        if (isAnimationFinished) {
          this.finish();
        }
        return state;
      }
      /**
       * Allows the returned animation to be awaited or promise-chained. Currently
       * resolves when the animation finishes at all but in a future update could/should
       * reject if its cancels.
       */
      then(resolve, reject) {
        return this.finished.then(resolve, reject);
      }
      get duration() {
        return motionUtils.millisecondsToSeconds(this.calculatedDuration);
      }
      get time() {
        return motionUtils.millisecondsToSeconds(this.currentTime);
      }
      set time(newTime) {
        newTime = motionUtils.secondsToMilliseconds(newTime);
        this.currentTime = newTime;
        if (this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0) {
          this.holdTime = newTime;
        } else if (this.driver) {
          this.startTime = this.driver.now() - newTime / this.playbackSpeed;
        }
      }
      get speed() {
        return this.playbackSpeed;
      }
      set speed(newSpeed) {
        this.updateTime(time.now());
        const hasChanged = this.playbackSpeed !== newSpeed;
        this.playbackSpeed = newSpeed;
        if (hasChanged) {
          this.time = motionUtils.millisecondsToSeconds(this.currentTime);
        }
      }
      play() {
        if (this.isStopped)
          return;
        const { driver = frameloopDriver, onPlay, startTime } = this.options;
        if (!this.driver) {
          this.driver = driver((timestamp) => this.tick(timestamp));
        }
        onPlay && onPlay();
        const now2 = this.driver.now();
        if (this.state === "finished") {
          this.updateFinished();
          this.startTime = now2;
        } else if (this.holdTime !== null) {
          this.startTime = now2 - this.holdTime;
        } else if (!this.startTime) {
          this.startTime = startTime ?? now2;
        }
        if (this.state === "finished" && this.speed < 0) {
          this.startTime += this.calculatedDuration;
        }
        this.holdTime = null;
        this.state = "running";
        this.driver.start();
      }
      pause() {
        this.state = "paused";
        this.updateTime(time.now());
        this.holdTime = this.currentTime;
      }
      complete() {
        if (this.state !== "running") {
          this.play();
        }
        this.state = "finished";
        this.holdTime = null;
      }
      finish() {
        this.teardown();
        this.state = "finished";
        const { onComplete } = this.options;
        onComplete && onComplete();
      }
      cancel() {
        this.holdTime = null;
        this.startTime = 0;
        this.tick(0);
        this.teardown();
      }
      teardown() {
        this.notifyFinished();
        this.state = "idle";
        this.stopDriver();
        this.startTime = this.holdTime = null;
        activeAnimations.mainThread--;
      }
      stopDriver() {
        if (!this.driver)
          return;
        this.driver.stop();
        this.driver = void 0;
      }
      sample(sampleTime) {
        this.startTime = 0;
        return this.tick(sampleTime, true);
      }
      attachTimeline(timeline) {
        if (this.options.allowFlatten) {
          this.options.type = "keyframes";
          this.options.ease = "linear";
          this.initAnimation();
        }
        return timeline.observe(this);
      }
    };
    function animateValue(options) {
      return new JSAnimation(options);
    }
    function fillWildcards(keyframes2) {
      for (let i = 1; i < keyframes2.length; i++) {
        keyframes2[i] ?? (keyframes2[i] = keyframes2[i - 1]);
      }
    }
    var radToDeg = (rad) => rad * 180 / Math.PI;
    var rotate = (v) => {
      const angle = radToDeg(Math.atan2(v[1], v[0]));
      return rebaseAngle(angle);
    };
    var matrix2dParsers = {
      x: 4,
      y: 5,
      translateX: 4,
      translateY: 5,
      scaleX: 0,
      scaleY: 3,
      scale: (v) => (Math.abs(v[0]) + Math.abs(v[3])) / 2,
      rotate,
      rotateZ: rotate,
      skewX: (v) => radToDeg(Math.atan(v[1])),
      skewY: (v) => radToDeg(Math.atan(v[2])),
      skew: (v) => (Math.abs(v[1]) + Math.abs(v[2])) / 2
    };
    var rebaseAngle = (angle) => {
      angle = angle % 360;
      if (angle < 0)
        angle += 360;
      return angle;
    };
    var rotateZ = rotate;
    var scaleX = (v) => Math.sqrt(v[0] * v[0] + v[1] * v[1]);
    var scaleY = (v) => Math.sqrt(v[4] * v[4] + v[5] * v[5]);
    var matrix3dParsers = {
      x: 12,
      y: 13,
      z: 14,
      translateX: 12,
      translateY: 13,
      translateZ: 14,
      scaleX,
      scaleY,
      scale: (v) => (scaleX(v) + scaleY(v)) / 2,
      rotateX: (v) => rebaseAngle(radToDeg(Math.atan2(v[6], v[5]))),
      rotateY: (v) => rebaseAngle(radToDeg(Math.atan2(-v[2], v[0]))),
      rotateZ,
      rotate: rotateZ,
      skewX: (v) => radToDeg(Math.atan(v[4])),
      skewY: (v) => radToDeg(Math.atan(v[1])),
      skew: (v) => (Math.abs(v[1]) + Math.abs(v[4])) / 2
    };
    function defaultTransformValue(name) {
      return name.includes("scale") ? 1 : 0;
    }
    function parseValueFromTransform(transform2, name) {
      if (!transform2 || transform2 === "none") {
        return defaultTransformValue(name);
      }
      const matrix3dMatch = transform2.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
      let parsers;
      let match;
      if (matrix3dMatch) {
        parsers = matrix3dParsers;
        match = matrix3dMatch;
      } else {
        const matrix2dMatch = transform2.match(/^matrix\(([-\d.e\s,]+)\)$/u);
        parsers = matrix2dParsers;
        match = matrix2dMatch;
      }
      if (!match) {
        return defaultTransformValue(name);
      }
      const valueParser = parsers[name];
      const values = match[1].split(",").map(convertTransformToNumber);
      return typeof valueParser === "function" ? valueParser(values) : values[valueParser];
    }
    var readTransformValue = (instance, name) => {
      const { transform: transform2 = "none" } = getComputedStyle(instance);
      return parseValueFromTransform(transform2, name);
    };
    function convertTransformToNumber(value) {
      return parseFloat(value.trim());
    }
    var transformPropOrder = [
      "transformPerspective",
      "x",
      "y",
      "z",
      "translateX",
      "translateY",
      "translateZ",
      "scale",
      "scaleX",
      "scaleY",
      "rotate",
      "rotateX",
      "rotateY",
      "rotateZ",
      "skew",
      "skewX",
      "skewY"
    ];
    var transformProps = (() => new Set(transformPropOrder))();
    var isNumOrPxType = (v) => v === number || v === px;
    var transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
    var nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
    function removeNonTranslationalTransform(visualElement) {
      const removedTransforms = [];
      nonTranslationalTransformKeys.forEach((key) => {
        const value = visualElement.getValue(key);
        if (value !== void 0) {
          removedTransforms.push([key, value.get()]);
          value.set(key.startsWith("scale") ? 1 : 0);
        }
      });
      return removedTransforms;
    }
    var positionalValues = {
      // Dimensions
      width: ({ x }, { paddingLeft = "0", paddingRight = "0" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
      height: ({ y }, { paddingTop = "0", paddingBottom = "0" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
      top: (_bbox, { top }) => parseFloat(top),
      left: (_bbox, { left }) => parseFloat(left),
      bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),
      right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),
      // Transform
      x: (_bbox, { transform: transform2 }) => parseValueFromTransform(transform2, "x"),
      y: (_bbox, { transform: transform2 }) => parseValueFromTransform(transform2, "y")
    };
    positionalValues.translateX = positionalValues.x;
    positionalValues.translateY = positionalValues.y;
    var toResolve = /* @__PURE__ */ new Set();
    var isScheduled = false;
    var anyNeedsMeasurement = false;
    var isForced = false;
    function measureAllKeyframes() {
      if (anyNeedsMeasurement) {
        const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);
        const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
        const transformsToRestore = /* @__PURE__ */ new Map();
        elementsToMeasure.forEach((element) => {
          const removedTransforms = removeNonTranslationalTransform(element);
          if (!removedTransforms.length)
            return;
          transformsToRestore.set(element, removedTransforms);
          element.render();
        });
        resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
        elementsToMeasure.forEach((element) => {
          element.render();
          const restore = transformsToRestore.get(element);
          if (restore) {
            restore.forEach(([key, value]) => {
              var _a;
              (_a = element.getValue(key)) == null ? void 0 : _a.set(value);
            });
          }
        });
        resolversToMeasure.forEach((resolver) => resolver.measureEndState());
        resolversToMeasure.forEach((resolver) => {
          if (resolver.suspendedScrollY !== void 0) {
            window.scrollTo(0, resolver.suspendedScrollY);
          }
        });
      }
      anyNeedsMeasurement = false;
      isScheduled = false;
      toResolve.forEach((resolver) => resolver.complete(isForced));
      toResolve.clear();
    }
    function readAllKeyframes() {
      toResolve.forEach((resolver) => {
        resolver.readKeyframes();
        if (resolver.needsMeasurement) {
          anyNeedsMeasurement = true;
        }
      });
    }
    function flushKeyframeResolvers() {
      isForced = true;
      readAllKeyframes();
      measureAllKeyframes();
      isForced = false;
    }
    var KeyframeResolver = class {
      constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = false) {
        this.isComplete = false;
        this.isAsync = false;
        this.needsMeasurement = false;
        this.isScheduled = false;
        this.unresolvedKeyframes = [...unresolvedKeyframes];
        this.onComplete = onComplete;
        this.name = name;
        this.motionValue = motionValue2;
        this.element = element;
        this.isAsync = isAsync;
      }
      scheduleResolve() {
        this.isScheduled = true;
        if (this.isAsync) {
          toResolve.add(this);
          if (!isScheduled) {
            isScheduled = true;
            frame.read(readAllKeyframes);
            frame.resolveKeyframes(measureAllKeyframes);
          }
        } else {
          this.readKeyframes();
          this.complete();
        }
      }
      readKeyframes() {
        const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
        if (unresolvedKeyframes[0] === null) {
          const currentValue = motionValue2 == null ? void 0 : motionValue2.get();
          const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
          if (currentValue !== void 0) {
            unresolvedKeyframes[0] = currentValue;
          } else if (element && name) {
            const valueAsRead = element.readValue(name, finalKeyframe);
            if (valueAsRead !== void 0 && valueAsRead !== null) {
              unresolvedKeyframes[0] = valueAsRead;
            }
          }
          if (unresolvedKeyframes[0] === void 0) {
            unresolvedKeyframes[0] = finalKeyframe;
          }
          if (motionValue2 && currentValue === void 0) {
            motionValue2.set(unresolvedKeyframes[0]);
          }
        }
        fillWildcards(unresolvedKeyframes);
      }
      setFinalKeyframe() {
      }
      measureInitialState() {
      }
      renderEndStyles() {
      }
      measureEndState() {
      }
      complete(isForced2 = false) {
        this.isComplete = true;
        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForced2);
        toResolve.delete(this);
      }
      cancel() {
        if (!this.isComplete) {
          this.isScheduled = false;
          toResolve.delete(this);
        }
      }
      resume() {
        if (!this.isComplete)
          this.scheduleResolve();
      }
    };
    var isCSSVar = (name) => name.startsWith("--");
    function setStyle(element, name, value) {
      isCSSVar(name) ? element.style.setProperty(name, value) : element.style[name] = value;
    }
    var supportsScrollTimeline = motionUtils.memo(() => window.ScrollTimeline !== void 0);
    var supportsFlags = {};
    function memoSupports(callback, supportsFlag) {
      const memoized = motionUtils.memo(callback);
      return () => supportsFlags[supportsFlag] ?? memoized();
    }
    var supportsLinearEasing = memoSupports(() => {
      try {
        document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
      } catch (e) {
        return false;
      }
      return true;
    }, "linearEasing");
    var cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;
    var supportedWaapiEasing = {
      linear: "linear",
      ease: "ease",
      easeIn: "ease-in",
      easeOut: "ease-out",
      easeInOut: "ease-in-out",
      circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
      circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
      backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
      backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
    };
    function mapEasingToNativeEasing(easing, duration) {
      if (!easing) {
        return void 0;
      } else if (typeof easing === "function") {
        return supportsLinearEasing() ? generateLinearEasing(easing, duration) : "ease-out";
      } else if (motionUtils.isBezierDefinition(easing)) {
        return cubicBezierAsString(easing);
      } else if (Array.isArray(easing)) {
        return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut);
      } else {
        return supportedWaapiEasing[easing];
      }
    }
    function startWaapiAnimation(element, valueName, keyframes2, { delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease = "easeOut", times } = {}, pseudoElement = void 0) {
      const keyframeOptions = {
        [valueName]: keyframes2
      };
      if (times)
        keyframeOptions.offset = times;
      const easing = mapEasingToNativeEasing(ease, duration);
      if (Array.isArray(easing))
        keyframeOptions.easing = easing;
      if (statsBuffer.value) {
        activeAnimations.waapi++;
      }
      const options = {
        delay,
        duration,
        easing: !Array.isArray(easing) ? easing : "linear",
        fill: "both",
        iterations: repeat + 1,
        direction: repeatType === "reverse" ? "alternate" : "normal"
      };
      if (pseudoElement)
        options.pseudoElement = pseudoElement;
      const animation = element.animate(keyframeOptions, options);
      if (statsBuffer.value) {
        animation.finished.finally(() => {
          activeAnimations.waapi--;
        });
      }
      return animation;
    }
    function isGenerator(type) {
      return typeof type === "function" && "applyToOptions" in type;
    }
    function applyGeneratorOptions({ type, ...options }) {
      if (isGenerator(type) && supportsLinearEasing()) {
        return type.applyToOptions(options);
      } else {
        options.duration ?? (options.duration = 300);
        options.ease ?? (options.ease = "easeOut");
      }
      return options;
    }
    var NativeAnimation = class extends WithPromise {
      constructor(options) {
        super();
        this.finishedTime = null;
        this.isStopped = false;
        if (!options)
          return;
        const { element, name, keyframes: keyframes2, pseudoElement, allowFlatten = false, finalKeyframe, onComplete } = options;
        this.isPseudoElement = Boolean(pseudoElement);
        this.allowFlatten = allowFlatten;
        this.options = options;
        motionUtils.invariant(typeof options.type !== "string", `animateMini doesn't support "type" as a string. Did you mean to import { spring } from "motion"?`);
        const transition = applyGeneratorOptions(options);
        this.animation = startWaapiAnimation(element, name, keyframes2, transition, pseudoElement);
        if (transition.autoplay === false) {
          this.animation.pause();
        }
        this.animation.onfinish = () => {
          this.finishedTime = this.time;
          if (!pseudoElement) {
            const keyframe = getFinalKeyframe(keyframes2, this.options, finalKeyframe, this.speed);
            if (this.updateMotionValue) {
              this.updateMotionValue(keyframe);
            } else {
              setStyle(element, name, keyframe);
            }
            this.animation.cancel();
          }
          onComplete == null ? void 0 : onComplete();
          this.notifyFinished();
        };
        this.animation.oncancel = () => this.notifyFinished();
      }
      play() {
        if (this.isStopped)
          return;
        this.animation.play();
        if (this.state === "finished") {
          this.updateFinished();
        }
      }
      pause() {
        this.animation.pause();
      }
      complete() {
        var _a, _b;
        (_b = (_a = this.animation).finish) == null ? void 0 : _b.call(_a);
      }
      cancel() {
        try {
          this.animation.cancel();
        } catch (e) {
        }
      }
      stop() {
        if (this.isStopped)
          return;
        this.isStopped = true;
        const { state } = this;
        if (state === "idle" || state === "finished") {
          return;
        }
        if (this.updateMotionValue) {
          this.updateMotionValue();
        } else {
          this.commitStyles();
        }
        if (!this.isPseudoElement)
          this.cancel();
      }
      /**
       * WAAPI doesn't natively have any interruption capabilities.
       *
       * In this method, we commit styles back to the DOM before cancelling
       * the animation.
       *
       * This is designed to be overridden by NativeAnimationExtended, which
       * will create a renderless JS animation and sample it twice to calculate
       * its current value, "previous" value, and therefore allow
       * Motion to also correctly calculate velocity for any subsequent animation
       * while deferring the commit until the next animation frame.
       */
      commitStyles() {
        var _a, _b;
        if (!this.isPseudoElement) {
          (_b = (_a = this.animation).commitStyles) == null ? void 0 : _b.call(_a);
        }
      }
      get duration() {
        var _a, _b;
        const duration = ((_b = (_a = this.animation.effect) == null ? void 0 : _a.getComputedTiming) == null ? void 0 : _b.call(_a).duration) || 0;
        return motionUtils.millisecondsToSeconds(Number(duration));
      }
      get time() {
        return motionUtils.millisecondsToSeconds(Number(this.animation.currentTime) || 0);
      }
      set time(newTime) {
        this.finishedTime = null;
        this.animation.currentTime = motionUtils.secondsToMilliseconds(newTime);
      }
      /**
       * The playback speed of the animation.
       * 1 = normal speed, 2 = double speed, 0.5 = half speed.
       */
      get speed() {
        return this.animation.playbackRate;
      }
      set speed(newSpeed) {
        if (newSpeed < 0)
          this.finishedTime = null;
        this.animation.playbackRate = newSpeed;
      }
      get state() {
        return this.finishedTime !== null ? "finished" : this.animation.playState;
      }
      get startTime() {
        return Number(this.animation.startTime);
      }
      set startTime(newStartTime) {
        this.animation.startTime = newStartTime;
      }
      /**
       * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
       */
      attachTimeline({ timeline, observe }) {
        var _a;
        if (this.allowFlatten) {
          (_a = this.animation.effect) == null ? void 0 : _a.updateTiming({ easing: "linear" });
        }
        this.animation.onfinish = null;
        if (timeline && supportsScrollTimeline()) {
          this.animation.timeline = timeline;
          return motionUtils.noop;
        } else {
          return observe(this);
        }
      }
    };
    var unsupportedEasingFunctions = {
      anticipate: motionUtils.anticipate,
      backInOut: motionUtils.backInOut,
      circInOut: motionUtils.circInOut
    };
    function isUnsupportedEase(key) {
      return key in unsupportedEasingFunctions;
    }
    function replaceStringEasing(transition) {
      if (typeof transition.ease === "string" && isUnsupportedEase(transition.ease)) {
        transition.ease = unsupportedEasingFunctions[transition.ease];
      }
    }
    var sampleDelta = 10;
    var NativeAnimationExtended = class extends NativeAnimation {
      constructor(options) {
        replaceStringEasing(options);
        replaceTransitionType(options);
        super(options);
        if (options.startTime) {
          this.startTime = options.startTime;
        }
        this.options = options;
      }
      /**
       * WAAPI doesn't natively have any interruption capabilities.
       *
       * Rather than read commited styles back out of the DOM, we can
       * create a renderless JS animation and sample it twice to calculate
       * its current value, "previous" value, and therefore allow
       * Motion to calculate velocity for any subsequent animation.
       */
      updateMotionValue(value) {
        const { motionValue: motionValue2, onUpdate, onComplete, element, ...options } = this.options;
        if (!motionValue2)
          return;
        if (value !== void 0) {
          motionValue2.set(value);
          return;
        }
        const sampleAnimation = new JSAnimation({
          ...options,
          autoplay: false
        });
        const sampleTime = motionUtils.secondsToMilliseconds(this.finishedTime ?? this.time);
        motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
        sampleAnimation.stop();
      }
    };
    var isAnimatable = (value, name) => {
      if (name === "zIndex")
        return false;
      if (typeof value === "number" || Array.isArray(value))
        return true;
      if (typeof value === "string" && // It's animatable if we have a string
      (complex.test(value) || value === "0") && // And it contains numbers and/or colors
      !value.startsWith("url(")) {
        return true;
      }
      return false;
    };
    function hasKeyframesChanged(keyframes2) {
      const current2 = keyframes2[0];
      if (keyframes2.length === 1)
        return true;
      for (let i = 0; i < keyframes2.length; i++) {
        if (keyframes2[i] !== current2)
          return true;
      }
    }
    function canAnimate(keyframes2, name, type, velocity) {
      const originKeyframe = keyframes2[0];
      if (originKeyframe === null)
        return false;
      if (name === "display" || name === "visibility")
        return true;
      const targetKeyframe = keyframes2[keyframes2.length - 1];
      const isOriginAnimatable = isAnimatable(originKeyframe, name);
      const isTargetAnimatable = isAnimatable(targetKeyframe, name);
      motionUtils.warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
      if (!isOriginAnimatable || !isTargetAnimatable) {
        return false;
      }
      return hasKeyframesChanged(keyframes2) || (type === "spring" || isGenerator(type)) && velocity;
    }
    var acceleratedValues$1 = /* @__PURE__ */ new Set([
      "opacity",
      "clipPath",
      "filter",
      "transform"
      // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
      // or until we implement support for linear() easing.
      // "background-color"
    ]);
    var supportsWaapi = motionUtils.memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
    function supportsBrowserAnimation(options) {
      const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;
      if (!motionValue2 || !motionValue2.owner || !(motionValue2.owner.current instanceof HTMLElement)) {
        return false;
      }
      const { onUpdate, transformTemplate } = motionValue2.owner.getProps();
      return supportsWaapi() && name && acceleratedValues$1.has(name) && (name !== "transform" || !transformTemplate) && /**
       * If we're outputting values to onUpdate then we can't use WAAPI as there's
       * no way to read the value from WAAPI every frame.
       */
      !onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
    }
    var MAX_RESOLVE_DELAY = 40;
    var AsyncMotionValueAnimation = class extends WithPromise {
      constructor({ autoplay = true, delay = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", keyframes: keyframes2, name, motionValue: motionValue2, element, ...options }) {
        var _a;
        super();
        this.stop = () => {
          var _a2, _b;
          if (this._animation) {
            this._animation.stop();
            (_a2 = this.stopTimeline) == null ? void 0 : _a2.call(this);
          } else {
            (_b = this.keyframeResolver) == null ? void 0 : _b.cancel();
          }
        };
        this.createdAt = time.now();
        const optionsWithDefaults = {
          autoplay,
          delay,
          type,
          repeat,
          repeatDelay,
          repeatType,
          name,
          motionValue: motionValue2,
          element,
          ...options
        };
        const KeyframeResolver$1 = (element == null ? void 0 : element.KeyframeResolver) || KeyframeResolver;
        this.keyframeResolver = new KeyframeResolver$1(keyframes2, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue2, element);
        (_a = this.keyframeResolver) == null ? void 0 : _a.scheduleResolve();
      }
      onKeyframesResolved(keyframes2, finalKeyframe, options, sync2) {
        this.keyframeResolver = void 0;
        const { name, type, velocity, delay, isHandoff, onUpdate } = options;
        this.resolvedAt = time.now();
        if (!canAnimate(keyframes2, name, type, velocity)) {
          if (motionUtils.MotionGlobalConfig.instantAnimations || !delay) {
            onUpdate == null ? void 0 : onUpdate(getFinalKeyframe(keyframes2, options, finalKeyframe));
          }
          keyframes2[0] = keyframes2[keyframes2.length - 1];
          options.duration = 0;
          options.repeat = 0;
        }
        const startTime = sync2 ? !this.resolvedAt ? this.createdAt : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : void 0;
        const resolvedOptions = {
          startTime,
          finalKeyframe,
          ...options,
          keyframes: keyframes2
        };
        const animation = !isHandoff && supportsBrowserAnimation(resolvedOptions) ? new NativeAnimationExtended({
          ...resolvedOptions,
          element: resolvedOptions.motionValue.owner.current
        }) : new JSAnimation(resolvedOptions);
        animation.finished.then(() => this.notifyFinished()).catch(motionUtils.noop);
        if (this.pendingTimeline) {
          this.stopTimeline = animation.attachTimeline(this.pendingTimeline);
          this.pendingTimeline = void 0;
        }
        this._animation = animation;
      }
      get finished() {
        if (!this._animation) {
          return this._finished;
        } else {
          return this.animation.finished;
        }
      }
      then(onResolve, _onReject) {
        return this.finished.finally(onResolve).then(() => {
        });
      }
      get animation() {
        if (!this._animation) {
          flushKeyframeResolvers();
        }
        return this._animation;
      }
      get duration() {
        return this.animation.duration;
      }
      get time() {
        return this.animation.time;
      }
      set time(newTime) {
        this.animation.time = newTime;
      }
      get speed() {
        return this.animation.speed;
      }
      get state() {
        return this.animation.state;
      }
      set speed(newSpeed) {
        this.animation.speed = newSpeed;
      }
      get startTime() {
        return this.animation.startTime;
      }
      attachTimeline(timeline) {
        if (this._animation) {
          this.stopTimeline = this.animation.attachTimeline(timeline);
        } else {
          this.pendingTimeline = timeline;
        }
        return () => this.stop();
      }
      play() {
        this.animation.play();
      }
      pause() {
        this.animation.pause();
      }
      complete() {
        this.animation.complete();
      }
      cancel() {
        this.animation.cancel();
      }
    };
    var GroupAnimation = class {
      constructor(animations) {
        this.stop = () => this.runAll("stop");
        this.animations = animations.filter(Boolean);
      }
      get finished() {
        return Promise.all(this.animations.map((animation) => animation.finished));
      }
      /**
       * TODO: Filter out cancelled or stopped animations before returning
       */
      getAll(propName) {
        return this.animations[0][propName];
      }
      setAll(propName, newValue) {
        for (let i = 0; i < this.animations.length; i++) {
          this.animations[i][propName] = newValue;
        }
      }
      attachTimeline(timeline) {
        const subscriptions = this.animations.map((animation) => animation.attachTimeline(timeline));
        return () => {
          subscriptions.forEach((cancel, i) => {
            cancel && cancel();
            this.animations[i].stop();
          });
        };
      }
      get time() {
        return this.getAll("time");
      }
      set time(time2) {
        this.setAll("time", time2);
      }
      get speed() {
        return this.getAll("speed");
      }
      set speed(speed) {
        this.setAll("speed", speed);
      }
      get state() {
        return this.getAll("state");
      }
      get startTime() {
        return this.getAll("startTime");
      }
      get duration() {
        let max = 0;
        for (let i = 0; i < this.animations.length; i++) {
          max = Math.max(max, this.animations[i].duration);
        }
        return max;
      }
      runAll(methodName) {
        this.animations.forEach((controls) => controls[methodName]());
      }
      play() {
        this.runAll("play");
      }
      pause() {
        this.runAll("pause");
      }
      cancel() {
        this.runAll("cancel");
      }
      complete() {
        this.runAll("complete");
      }
    };
    var GroupAnimationWithThen = class extends GroupAnimation {
      then(onResolve, _onReject) {
        return this.finished.finally(onResolve).then(() => {
        });
      }
    };
    var NativeAnimationWrapper = class extends NativeAnimation {
      constructor(animation) {
        super();
        this.animation = animation;
        animation.onfinish = () => {
          this.finishedTime = this.time;
          this.notifyFinished();
        };
      }
    };
    var animationMaps = /* @__PURE__ */ new WeakMap();
    var animationMapKey = (name, pseudoElement = "") => `${name}:${pseudoElement}`;
    function getAnimationMap(element) {
      const map = animationMaps.get(element) || /* @__PURE__ */ new Map();
      animationMaps.set(element, map);
      return map;
    }
    var splitCSSVariableRegex = (
      // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
      /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
    );
    function parseCSSVariable(current2) {
      const match = splitCSSVariableRegex.exec(current2);
      if (!match)
        return [,];
      const [, token1, token2, fallback] = match;
      return [`--${token1 ?? token2}`, fallback];
    }
    var maxDepth = 4;
    function getVariableValue(current2, element, depth = 1) {
      motionUtils.invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current2}". This may indicate a circular fallback dependency.`);
      const [token, fallback] = parseCSSVariable(current2);
      if (!token)
        return;
      const resolved = window.getComputedStyle(element).getPropertyValue(token);
      if (resolved) {
        const trimmed = resolved.trim();
        return motionUtils.isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
      }
      return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
    }
    function getValueTransition(transition, key) {
      return (transition == null ? void 0 : transition[key]) ?? (transition == null ? void 0 : transition["default"]) ?? transition;
    }
    var positionalKeys = /* @__PURE__ */ new Set([
      "width",
      "height",
      "top",
      "left",
      "right",
      "bottom",
      ...transformPropOrder
    ]);
    var auto = {
      test: (v) => v === "auto",
      parse: (v) => v
    };
    var testValueType = (v) => (type) => type.test(v);
    var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
    var findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));
    function isNone(value) {
      if (typeof value === "number") {
        return value === 0;
      } else if (value !== null) {
        return value === "none" || value === "0" || motionUtils.isZeroValueString(value);
      } else {
        return true;
      }
    }
    var maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
    function applyDefaultFilter(v) {
      const [name, value] = v.slice(0, -1).split("(");
      if (name === "drop-shadow")
        return v;
      const [number2] = value.match(floatRegex) || [];
      if (!number2)
        return v;
      const unit = value.replace(number2, "");
      let defaultValue = maxDefaults.has(name) ? 1 : 0;
      if (number2 !== value)
        defaultValue *= 100;
      return name + "(" + defaultValue + unit + ")";
    }
    var functionRegex = /\b([a-z-]*)\(.*?\)/gu;
    var filter = {
      ...complex,
      getAnimatableNone: (v) => {
        const functions = v.match(functionRegex);
        return functions ? functions.map(applyDefaultFilter).join(" ") : v;
      }
    };
    var int = {
      ...number,
      transform: Math.round
    };
    var transformValueTypes = {
      rotate: degrees,
      rotateX: degrees,
      rotateY: degrees,
      rotateZ: degrees,
      scale,
      scaleX: scale,
      scaleY: scale,
      scaleZ: scale,
      skew: degrees,
      skewX: degrees,
      skewY: degrees,
      distance: px,
      translateX: px,
      translateY: px,
      translateZ: px,
      x: px,
      y: px,
      z: px,
      perspective: px,
      transformPerspective: px,
      opacity: alpha,
      originX: progressPercentage,
      originY: progressPercentage,
      originZ: px
    };
    var numberValueTypes = {
      // Border props
      borderWidth: px,
      borderTopWidth: px,
      borderRightWidth: px,
      borderBottomWidth: px,
      borderLeftWidth: px,
      borderRadius: px,
      radius: px,
      borderTopLeftRadius: px,
      borderTopRightRadius: px,
      borderBottomRightRadius: px,
      borderBottomLeftRadius: px,
      // Positioning props
      width: px,
      maxWidth: px,
      height: px,
      maxHeight: px,
      top: px,
      right: px,
      bottom: px,
      left: px,
      // Spacing props
      padding: px,
      paddingTop: px,
      paddingRight: px,
      paddingBottom: px,
      paddingLeft: px,
      margin: px,
      marginTop: px,
      marginRight: px,
      marginBottom: px,
      marginLeft: px,
      // Misc
      backgroundPositionX: px,
      backgroundPositionY: px,
      ...transformValueTypes,
      zIndex: int,
      // SVG
      fillOpacity: alpha,
      strokeOpacity: alpha,
      numOctaves: int
    };
    var defaultValueTypes = {
      ...numberValueTypes,
      // Color props
      color,
      backgroundColor: color,
      outlineColor: color,
      fill: color,
      stroke: color,
      // Border props
      borderColor: color,
      borderTopColor: color,
      borderRightColor: color,
      borderBottomColor: color,
      borderLeftColor: color,
      filter,
      WebkitFilter: filter
    };
    var getDefaultValueType = (key) => defaultValueTypes[key];
    function getAnimatableNone(key, value) {
      let defaultValueType = getDefaultValueType(key);
      if (defaultValueType !== filter)
        defaultValueType = complex;
      return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
    }
    var invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
    function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
      let i = 0;
      let animatableTemplate = void 0;
      while (i < unresolvedKeyframes.length && !animatableTemplate) {
        const keyframe = unresolvedKeyframes[i];
        if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
          animatableTemplate = unresolvedKeyframes[i];
        }
        i++;
      }
      if (animatableTemplate && name) {
        for (const noneIndex of noneKeyframeIndexes) {
          unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);
        }
      }
    }
    var DOMKeyframesResolver = class extends KeyframeResolver {
      constructor(unresolvedKeyframes, onComplete, name, motionValue2, element) {
        super(unresolvedKeyframes, onComplete, name, motionValue2, element, true);
      }
      readKeyframes() {
        const { unresolvedKeyframes, element, name } = this;
        if (!element || !element.current)
          return;
        super.readKeyframes();
        for (let i = 0; i < unresolvedKeyframes.length; i++) {
          let keyframe = unresolvedKeyframes[i];
          if (typeof keyframe === "string") {
            keyframe = keyframe.trim();
            if (isCSSVariableToken(keyframe)) {
              const resolved = getVariableValue(keyframe, element.current);
              if (resolved !== void 0) {
                unresolvedKeyframes[i] = resolved;
              }
              if (i === unresolvedKeyframes.length - 1) {
                this.finalKeyframe = keyframe;
              }
            }
          }
        }
        this.resolveNoneKeyframes();
        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
          return;
        }
        const [origin, target] = unresolvedKeyframes;
        const originType = findDimensionValueType(origin);
        const targetType = findDimensionValueType(target);
        if (originType === targetType)
          return;
        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
          for (let i = 0; i < unresolvedKeyframes.length; i++) {
            const value = unresolvedKeyframes[i];
            if (typeof value === "string") {
              unresolvedKeyframes[i] = parseFloat(value);
            }
          }
        } else {
          this.needsMeasurement = true;
        }
      }
      resolveNoneKeyframes() {
        const { unresolvedKeyframes, name } = this;
        const noneKeyframeIndexes = [];
        for (let i = 0; i < unresolvedKeyframes.length; i++) {
          if (unresolvedKeyframes[i] === null || isNone(unresolvedKeyframes[i])) {
            noneKeyframeIndexes.push(i);
          }
        }
        if (noneKeyframeIndexes.length) {
          makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
        }
      }
      measureInitialState() {
        const { element, unresolvedKeyframes, name } = this;
        if (!element || !element.current)
          return;
        if (name === "height") {
          this.suspendedScrollY = window.pageYOffset;
        }
        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
        unresolvedKeyframes[0] = this.measuredOrigin;
        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
        if (measureKeyframe !== void 0) {
          element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
        }
      }
      measureEndState() {
        var _a;
        const { element, name, unresolvedKeyframes } = this;
        if (!element || !element.current)
          return;
        const value = element.getValue(name);
        value && value.jump(this.measuredOrigin, false);
        const finalKeyframeIndex = unresolvedKeyframes.length - 1;
        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
        if (finalKeyframe !== null && this.finalKeyframe === void 0) {
          this.finalKeyframe = finalKeyframe;
        }
        if ((_a = this.removedTransforms) == null ? void 0 : _a.length) {
          this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
            element.getValue(unsetTransformName).set(unsetTransformValue);
          });
        }
        this.resolveNoneKeyframes();
      }
    };
    var pxValues = /* @__PURE__ */ new Set([
      // Border props
      "borderWidth",
      "borderTopWidth",
      "borderRightWidth",
      "borderBottomWidth",
      "borderLeftWidth",
      "borderRadius",
      "radius",
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomRightRadius",
      "borderBottomLeftRadius",
      // Positioning props
      "width",
      "maxWidth",
      "height",
      "maxHeight",
      "top",
      "right",
      "bottom",
      "left",
      // Spacing props
      "padding",
      "paddingTop",
      "paddingRight",
      "paddingBottom",
      "paddingLeft",
      "margin",
      "marginTop",
      "marginRight",
      "marginBottom",
      "marginLeft",
      // Misc
      "backgroundPositionX",
      "backgroundPositionY"
    ]);
    function applyPxDefaults(keyframes2, name) {
      for (let i = 0; i < keyframes2.length; i++) {
        if (typeof keyframes2[i] === "number" && pxValues.has(name)) {
          keyframes2[i] = keyframes2[i] + "px";
        }
      }
    }
    function isWaapiSupportedEasing(easing) {
      return Boolean(typeof easing === "function" && supportsLinearEasing() || !easing || typeof easing === "string" && (easing in supportedWaapiEasing || supportsLinearEasing()) || motionUtils.isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
    }
    var supportsPartialKeyframes = motionUtils.memo(() => {
      try {
        document.createElement("div").animate({ opacity: [1] });
      } catch (e) {
        return false;
      }
      return true;
    });
    var acceleratedValues = /* @__PURE__ */ new Set([
      "opacity",
      "clipPath",
      "filter",
      "transform"
      // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
      // or until we implement support for linear() easing.
      // "background-color"
    ]);
    function resolveElements(elementOrSelector, scope, selectorCache) {
      if (elementOrSelector instanceof EventTarget) {
        return [elementOrSelector];
      } else if (typeof elementOrSelector === "string") {
        let root = document;
        if (scope) {
          root = scope.current;
        }
        const elements = (selectorCache == null ? void 0 : selectorCache[elementOrSelector]) ?? root.querySelectorAll(elementOrSelector);
        return elements ? Array.from(elements) : [];
      }
      return Array.from(elementOrSelector);
    }
    function styleEffect(subject, values) {
      const elements = resolveElements(subject);
      const subscriptions = [];
      for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        for (const key in values) {
          const value = values[key];
          const updateStyle = () => {
            element.style[key] = value.get();
          };
          const scheduleUpdate = () => frame.render(updateStyle);
          const cancel = value.on("change", scheduleUpdate);
          scheduleUpdate();
          subscriptions.push(() => {
            cancel();
            cancelFrame(updateStyle);
          });
        }
      }
      return () => {
        for (const cancel of subscriptions) {
          cancel();
        }
      };
    }
    var { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);
    var isDragging = {
      x: false,
      y: false
    };
    function isDragActive() {
      return isDragging.x || isDragging.y;
    }
    function setDragLock(axis) {
      if (axis === "x" || axis === "y") {
        if (isDragging[axis]) {
          return null;
        } else {
          isDragging[axis] = true;
          return () => {
            isDragging[axis] = false;
          };
        }
      } else {
        if (isDragging.x || isDragging.y) {
          return null;
        } else {
          isDragging.x = isDragging.y = true;
          return () => {
            isDragging.x = isDragging.y = false;
          };
        }
      }
    }
    function setupGesture(elementOrSelector, options) {
      const elements = resolveElements(elementOrSelector);
      const gestureAbortController = new AbortController();
      const eventOptions = {
        passive: true,
        ...options,
        signal: gestureAbortController.signal
      };
      const cancel = () => gestureAbortController.abort();
      return [elements, eventOptions, cancel];
    }
    function isValidHover(event) {
      return !(event.pointerType === "touch" || isDragActive());
    }
    function hover(elementOrSelector, onHoverStart, options = {}) {
      const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);
      const onPointerEnter = (enterEvent) => {
        if (!isValidHover(enterEvent))
          return;
        const { target } = enterEvent;
        const onHoverEnd = onHoverStart(target, enterEvent);
        if (typeof onHoverEnd !== "function" || !target)
          return;
        const onPointerLeave = (leaveEvent) => {
          if (!isValidHover(leaveEvent))
            return;
          onHoverEnd(leaveEvent);
          target.removeEventListener("pointerleave", onPointerLeave);
        };
        target.addEventListener("pointerleave", onPointerLeave, eventOptions);
      };
      elements.forEach((element) => {
        element.addEventListener("pointerenter", onPointerEnter, eventOptions);
      });
      return cancel;
    }
    var isNodeOrChild = (parent, child) => {
      if (!child) {
        return false;
      } else if (parent === child) {
        return true;
      } else {
        return isNodeOrChild(parent, child.parentElement);
      }
    };
    var isPrimaryPointer = (event) => {
      if (event.pointerType === "mouse") {
        return typeof event.button !== "number" || event.button <= 0;
      } else {
        return event.isPrimary !== false;
      }
    };
    var focusableElements = /* @__PURE__ */ new Set([
      "BUTTON",
      "INPUT",
      "SELECT",
      "TEXTAREA",
      "A"
    ]);
    function isElementKeyboardAccessible(element) {
      return focusableElements.has(element.tagName) || element.tabIndex !== -1;
    }
    var isPressing = /* @__PURE__ */ new WeakSet();
    function filterEvents(callback) {
      return (event) => {
        if (event.key !== "Enter")
          return;
        callback(event);
      };
    }
    function firePointerEvent(target, type) {
      target.dispatchEvent(new PointerEvent("pointer" + type, { isPrimary: true, bubbles: true }));
    }
    var enableKeyboardPress = (focusEvent, eventOptions) => {
      const element = focusEvent.currentTarget;
      if (!element)
        return;
      const handleKeydown = filterEvents(() => {
        if (isPressing.has(element))
          return;
        firePointerEvent(element, "down");
        const handleKeyup = filterEvents(() => {
          firePointerEvent(element, "up");
        });
        const handleBlur = () => firePointerEvent(element, "cancel");
        element.addEventListener("keyup", handleKeyup, eventOptions);
        element.addEventListener("blur", handleBlur, eventOptions);
      });
      element.addEventListener("keydown", handleKeydown, eventOptions);
      element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
    };
    function isValidPressEvent(event) {
      return isPrimaryPointer(event) && !isDragActive();
    }
    function press(targetOrSelector, onPressStart, options = {}) {
      const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);
      const startPress = (startEvent) => {
        const target = startEvent.currentTarget;
        if (!isValidPressEvent(startEvent) || isPressing.has(target))
          return;
        isPressing.add(target);
        const onPressEnd = onPressStart(target, startEvent);
        const onPointerEnd = (endEvent, success) => {
          window.removeEventListener("pointerup", onPointerUp);
          window.removeEventListener("pointercancel", onPointerCancel);
          if (!isValidPressEvent(endEvent) || !isPressing.has(target)) {
            return;
          }
          isPressing.delete(target);
          if (typeof onPressEnd === "function") {
            onPressEnd(endEvent, { success });
          }
        };
        const onPointerUp = (upEvent) => {
          onPointerEnd(upEvent, target === window || target === document || options.useGlobalTarget || isNodeOrChild(target, upEvent.target));
        };
        const onPointerCancel = (cancelEvent) => {
          onPointerEnd(cancelEvent, false);
        };
        window.addEventListener("pointerup", onPointerUp, eventOptions);
        window.addEventListener("pointercancel", onPointerCancel, eventOptions);
      };
      targets.forEach((target) => {
        const pointerDownTarget = options.useGlobalTarget ? window : target;
        pointerDownTarget.addEventListener("pointerdown", startPress, eventOptions);
        if (target instanceof HTMLElement) {
          target.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions));
          if (!isElementKeyboardAccessible(target) && !target.hasAttribute("tabindex")) {
            target.tabIndex = 0;
          }
        }
      });
      return cancelEvents;
    }
    function getComputedStyle$1(element, name) {
      const computedStyle = window.getComputedStyle(element);
      return isCSSVar(name) ? computedStyle.getPropertyValue(name) : computedStyle[name];
    }
    function observeTimeline(update, timeline) {
      let prevProgress;
      const onFrame = () => {
        const { currentTime } = timeline;
        const percentage = currentTime === null ? 0 : currentTime.value;
        const progress = percentage / 100;
        if (prevProgress !== progress) {
          update(progress);
        }
        prevProgress = progress;
      };
      frame.preUpdate(onFrame, true);
      return () => cancelFrame(onFrame);
    }
    function record() {
      const { value } = statsBuffer;
      if (value === null) {
        cancelFrame(record);
        return;
      }
      value.frameloop.rate.push(frameData.delta);
      value.animations.mainThread.push(activeAnimations.mainThread);
      value.animations.waapi.push(activeAnimations.waapi);
      value.animations.layout.push(activeAnimations.layout);
    }
    function mean(values) {
      return values.reduce((acc, value) => acc + value, 0) / values.length;
    }
    function summarise(values, calcAverage = mean) {
      if (values.length === 0) {
        return {
          min: 0,
          max: 0,
          avg: 0
        };
      }
      return {
        min: Math.min(...values),
        max: Math.max(...values),
        avg: calcAverage(values)
      };
    }
    var msToFps = (ms) => Math.round(1e3 / ms);
    function clearStatsBuffer() {
      statsBuffer.value = null;
      statsBuffer.addProjectionMetrics = null;
    }
    function reportStats() {
      const { value } = statsBuffer;
      if (!value) {
        throw new Error("Stats are not being measured");
      }
      clearStatsBuffer();
      cancelFrame(record);
      const summary = {
        frameloop: {
          setup: summarise(value.frameloop.setup),
          rate: summarise(value.frameloop.rate),
          read: summarise(value.frameloop.read),
          resolveKeyframes: summarise(value.frameloop.resolveKeyframes),
          preUpdate: summarise(value.frameloop.preUpdate),
          update: summarise(value.frameloop.update),
          preRender: summarise(value.frameloop.preRender),
          render: summarise(value.frameloop.render),
          postRender: summarise(value.frameloop.postRender)
        },
        animations: {
          mainThread: summarise(value.animations.mainThread),
          waapi: summarise(value.animations.waapi),
          layout: summarise(value.animations.layout)
        },
        layoutProjection: {
          nodes: summarise(value.layoutProjection.nodes),
          calculatedTargetDeltas: summarise(value.layoutProjection.calculatedTargetDeltas),
          calculatedProjections: summarise(value.layoutProjection.calculatedProjections)
        }
      };
      const { rate } = summary.frameloop;
      rate.min = msToFps(rate.min);
      rate.max = msToFps(rate.max);
      rate.avg = msToFps(rate.avg);
      [rate.min, rate.max] = [rate.max, rate.min];
      return summary;
    }
    function recordStats() {
      if (statsBuffer.value) {
        clearStatsBuffer();
        throw new Error("Stats are already being measured");
      }
      const newStatsBuffer = statsBuffer;
      newStatsBuffer.value = {
        frameloop: {
          setup: [],
          rate: [],
          read: [],
          resolveKeyframes: [],
          preUpdate: [],
          update: [],
          preRender: [],
          render: [],
          postRender: []
        },
        animations: {
          mainThread: [],
          waapi: [],
          layout: []
        },
        layoutProjection: {
          nodes: [],
          calculatedTargetDeltas: [],
          calculatedProjections: []
        }
      };
      newStatsBuffer.addProjectionMetrics = (metrics) => {
        const { layoutProjection } = newStatsBuffer.value;
        layoutProjection.nodes.push(metrics.nodes);
        layoutProjection.calculatedTargetDeltas.push(metrics.calculatedTargetDeltas);
        layoutProjection.calculatedProjections.push(metrics.calculatedProjections);
      };
      frame.postRender(record, true);
      return reportStats;
    }
    function transform(...args) {
      const useImmediate = !Array.isArray(args[0]);
      const argOffset = useImmediate ? 0 : -1;
      const inputValue = args[0 + argOffset];
      const inputRange = args[1 + argOffset];
      const outputRange = args[2 + argOffset];
      const options = args[3 + argOffset];
      const interpolator = interpolate(inputRange, outputRange, options);
      return useImmediate ? interpolator(inputValue) : interpolator;
    }
    var MAX_VELOCITY_DELTA = 30;
    var isFloat = (value) => {
      return !isNaN(parseFloat(value));
    };
    var collectMotionValues = {
      current: void 0
    };
    var MotionValue = class {
      /**
       * @param init - The initiating value
       * @param config - Optional configuration options
       *
       * -  `transformer`: A function to transform incoming values with.
       */
      constructor(init, options = {}) {
        this.version = "__VERSION__";
        this.canTrackVelocity = null;
        this.events = {};
        this.updateAndNotify = (v, render = true) => {
          var _a, _b;
          const currentTime = time.now();
          if (this.updatedAt !== currentTime) {
            this.setPrevFrameValue();
          }
          this.prev = this.current;
          this.setCurrent(v);
          if (this.current !== this.prev) {
            (_a = this.events.change) == null ? void 0 : _a.notify(this.current);
          }
          if (render) {
            (_b = this.events.renderRequest) == null ? void 0 : _b.notify(this.current);
          }
        };
        this.hasAnimated = false;
        this.setCurrent(init);
        this.owner = options.owner;
      }
      setCurrent(current2) {
        this.current = current2;
        this.updatedAt = time.now();
        if (this.canTrackVelocity === null && current2 !== void 0) {
          this.canTrackVelocity = isFloat(this.current);
        }
      }
      setPrevFrameValue(prevFrameValue = this.current) {
        this.prevFrameValue = prevFrameValue;
        this.prevUpdatedAt = this.updatedAt;
      }
      /**
       * Adds a function that will be notified when the `MotionValue` is updated.
       *
       * It returns a function that, when called, will cancel the subscription.
       *
       * When calling `onChange` inside a React component, it should be wrapped with the
       * `useEffect` hook. As it returns an unsubscribe function, this should be returned
       * from the `useEffect` function to ensure you don't add duplicate subscribers..
       *
       * ```jsx
       * export const MyComponent = () => {
       *   const x = useMotionValue(0)
       *   const y = useMotionValue(0)
       *   const opacity = useMotionValue(1)
       *
       *   useEffect(() => {
       *     function updateOpacity() {
       *       const maxXY = Math.max(x.get(), y.get())
       *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
       *       opacity.set(newOpacity)
       *     }
       *
       *     const unsubscribeX = x.on("change", updateOpacity)
       *     const unsubscribeY = y.on("change", updateOpacity)
       *
       *     return () => {
       *       unsubscribeX()
       *       unsubscribeY()
       *     }
       *   }, [])
       *
       *   return <motion.div style={{ x }} />
       * }
       * ```
       *
       * @param subscriber - A function that receives the latest value.
       * @returns A function that, when called, will cancel this subscription.
       *
       * @deprecated
       */
      onChange(subscription) {
        if (true) {
          motionUtils.warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on("change", callback).`);
        }
        return this.on("change", subscription);
      }
      on(eventName, callback) {
        if (!this.events[eventName]) {
          this.events[eventName] = new motionUtils.SubscriptionManager();
        }
        const unsubscribe = this.events[eventName].add(callback);
        if (eventName === "change") {
          return () => {
            unsubscribe();
            frame.read(() => {
              if (!this.events.change.getSize()) {
                this.stop();
              }
            });
          };
        }
        return unsubscribe;
      }
      clearListeners() {
        for (const eventManagers in this.events) {
          this.events[eventManagers].clear();
        }
      }
      /**
       * Attaches a passive effect to the `MotionValue`.
       */
      attach(passiveEffect, stopPassiveEffect) {
        this.passiveEffect = passiveEffect;
        this.stopPassiveEffect = stopPassiveEffect;
      }
      /**
       * Sets the state of the `MotionValue`.
       *
       * @remarks
       *
       * ```jsx
       * const x = useMotionValue(0)
       * x.set(10)
       * ```
       *
       * @param latest - Latest value to set.
       * @param render - Whether to notify render subscribers. Defaults to `true`
       *
       * @public
       */
      set(v, render = true) {
        if (!render || !this.passiveEffect) {
          this.updateAndNotify(v, render);
        } else {
          this.passiveEffect(v, this.updateAndNotify);
        }
      }
      setWithVelocity(prev, current2, delta) {
        this.set(current2);
        this.prev = void 0;
        this.prevFrameValue = prev;
        this.prevUpdatedAt = this.updatedAt - delta;
      }
      /**
       * Set the state of the `MotionValue`, stopping any active animations,
       * effects, and resets velocity to `0`.
       */
      jump(v, endAnimation = true) {
        this.updateAndNotify(v);
        this.prev = v;
        this.prevUpdatedAt = this.prevFrameValue = void 0;
        endAnimation && this.stop();
        if (this.stopPassiveEffect)
          this.stopPassiveEffect();
      }
      /**
       * Returns the latest state of `MotionValue`
       *
       * @returns - The latest state of `MotionValue`
       *
       * @public
       */
      get() {
        if (collectMotionValues.current) {
          collectMotionValues.current.push(this);
        }
        return this.current;
      }
      /**
       * @public
       */
      getPrevious() {
        return this.prev;
      }
      /**
       * Returns the latest velocity of `MotionValue`
       *
       * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
       *
       * @public
       */
      getVelocity() {
        const currentTime = time.now();
        if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
          return 0;
        }
        const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
        return motionUtils.velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
      }
      /**
       * Registers a new animation to control this `MotionValue`. Only one
       * animation can drive a `MotionValue` at one time.
       *
       * ```jsx
       * value.start()
       * ```
       *
       * @param animation - A function that starts the provided animation
       */
      start(startAnimation) {
        this.stop();
        return new Promise((resolve) => {
          this.hasAnimated = true;
          this.animation = startAnimation(resolve);
          if (this.events.animationStart) {
            this.events.animationStart.notify();
          }
        }).then(() => {
          if (this.events.animationComplete) {
            this.events.animationComplete.notify();
          }
          this.clearAnimation();
        });
      }
      /**
       * Stop the currently active animation.
       *
       * @public
       */
      stop() {
        if (this.animation) {
          this.animation.stop();
          if (this.events.animationCancel) {
            this.events.animationCancel.notify();
          }
        }
        this.clearAnimation();
      }
      /**
       * Returns `true` if this value is currently animating.
       *
       * @public
       */
      isAnimating() {
        return !!this.animation;
      }
      clearAnimation() {
        delete this.animation;
      }
      /**
       * Destroy and clean up subscribers to this `MotionValue`.
       *
       * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
       * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
       * created a `MotionValue` via the `motionValue` function.
       *
       * @public
       */
      destroy() {
        var _a;
        (_a = this.events.destroy) == null ? void 0 : _a.notify();
        this.clearListeners();
        this.stop();
        if (this.stopPassiveEffect) {
          this.stopPassiveEffect();
        }
      }
    };
    function motionValue(init, options) {
      return new MotionValue(init, options);
    }
    function subscribeValue(inputValues, outputValue, getLatest) {
      const update = () => outputValue.set(getLatest());
      const scheduleUpdate = () => frame.preRender(update, false, true);
      const subscriptions = inputValues.map((v) => v.on("change", scheduleUpdate));
      outputValue.on("destroy", () => {
        subscriptions.forEach((unsubscribe) => unsubscribe());
        cancelFrame(update);
      });
    }
    function transformValue(transform2) {
      const collectedValues = [];
      collectMotionValues.current = collectedValues;
      const initialValue = transform2();
      collectMotionValues.current = void 0;
      const value = motionValue(initialValue);
      subscribeValue(collectedValues, value, transform2);
      return value;
    }
    function mapValue(inputValue, inputRange, outputRange, options) {
      const map = transform(inputRange, outputRange, options);
      return transformValue(() => map(inputValue.get()));
    }
    var valueTypes = [...dimensionValueTypes, color, complex];
    var findValueType = (v) => valueTypes.find(testValueType(v));
    var getValueAsType = (value, type) => {
      return type && typeof value === "number" ? type.transform(value) : value;
    };
    function chooseLayerType(valueName) {
      if (valueName === "layout")
        return "group";
      if (valueName === "enter" || valueName === "new")
        return "new";
      if (valueName === "exit" || valueName === "old")
        return "old";
      return "group";
    }
    var pendingRules = {};
    var style = null;
    var css = {
      set: (selector, values) => {
        pendingRules[selector] = values;
      },
      commit: () => {
        if (!style) {
          style = document.createElement("style");
          style.id = "motion-view";
        }
        let cssText = "";
        for (const selector in pendingRules) {
          const rule = pendingRules[selector];
          cssText += `${selector} {
`;
          for (const [property, value] of Object.entries(rule)) {
            cssText += `  ${property}: ${value};
`;
          }
          cssText += "}\n";
        }
        style.textContent = cssText;
        document.head.appendChild(style);
        pendingRules = {};
      },
      remove: () => {
        if (style && style.parentElement) {
          style.parentElement.removeChild(style);
        }
      }
    };
    function getLayerName(pseudoElement) {
      const match = pseudoElement.match(/::view-transition-(old|new|group|image-pair)\((.*?)\)/);
      if (!match)
        return null;
      return { layer: match[2], type: match[1] };
    }
    function filterViewAnimations(animation) {
      var _a;
      const { effect } = animation;
      if (!effect)
        return false;
      return effect.target === document.documentElement && ((_a = effect.pseudoElement) == null ? void 0 : _a.startsWith("::view-transition"));
    }
    function getViewAnimations() {
      return document.getAnimations().filter(filterViewAnimations);
    }
    function hasTarget(target, targets) {
      return targets.has(target) && Object.keys(targets.get(target)).length > 0;
    }
    var definitionNames = ["layout", "enter", "exit", "new", "old"];
    function startViewAnimation(builder) {
      const { update, targets, options: defaultOptions } = builder;
      if (!document.startViewTransition) {
        return new Promise(async (resolve) => {
          await update();
          resolve(new GroupAnimation([]));
        });
      }
      if (!hasTarget("root", targets)) {
        css.set(":root", {
          "view-transition-name": "none"
        });
      }
      css.set("::view-transition-group(*), ::view-transition-old(*), ::view-transition-new(*)", { "animation-timing-function": "linear !important" });
      css.commit();
      const transition = document.startViewTransition(async () => {
        await update();
      });
      transition.finished.finally(() => {
        css.remove();
      });
      return new Promise((resolve) => {
        transition.ready.then(() => {
          const generatedViewAnimations = getViewAnimations();
          const animations = [];
          targets.forEach((definition, target) => {
            for (const key of definitionNames) {
              if (!definition[key])
                continue;
              const { keyframes: keyframes2, options } = definition[key];
              for (let [valueName, valueKeyframes] of Object.entries(keyframes2)) {
                if (!valueKeyframes)
                  continue;
                const valueOptions = {
                  ...getValueTransition(defaultOptions, valueName),
                  ...getValueTransition(options, valueName)
                };
                const type = chooseLayerType(key);
                if (valueName === "opacity" && !Array.isArray(valueKeyframes)) {
                  const initialValue = type === "new" ? 0 : 1;
                  valueKeyframes = [initialValue, valueKeyframes];
                }
                if (typeof valueOptions.delay === "function") {
                  valueOptions.delay = valueOptions.delay(0, 1);
                }
                valueOptions.duration && (valueOptions.duration = motionUtils.secondsToMilliseconds(valueOptions.duration));
                valueOptions.delay && (valueOptions.delay = motionUtils.secondsToMilliseconds(valueOptions.delay));
                const animation = new NativeAnimation({
                  ...valueOptions,
                  element: document.documentElement,
                  name: valueName,
                  pseudoElement: `::view-transition-${type}(${target})`,
                  keyframes: valueKeyframes
                });
                animations.push(animation);
              }
            }
          });
          for (const animation of generatedViewAnimations) {
            if (animation.playState === "finished")
              continue;
            const { effect } = animation;
            if (!effect || !(effect instanceof KeyframeEffect))
              continue;
            const { pseudoElement } = effect;
            if (!pseudoElement)
              continue;
            const name = getLayerName(pseudoElement);
            if (!name)
              continue;
            const targetDefinition = targets.get(name.layer);
            if (!targetDefinition) {
              const transitionName = name.type === "group" ? "layout" : "";
              let animationTransition = {
                ...getValueTransition(defaultOptions, transitionName)
              };
              animationTransition.duration && (animationTransition.duration = motionUtils.secondsToMilliseconds(animationTransition.duration));
              animationTransition = applyGeneratorOptions(animationTransition);
              const easing = mapEasingToNativeEasing(animationTransition.ease, animationTransition.duration);
              effect.updateTiming({
                delay: motionUtils.secondsToMilliseconds(animationTransition.delay ?? 0),
                duration: animationTransition.duration,
                easing
              });
              animations.push(new NativeAnimationWrapper(animation));
            } else if (hasOpacity(targetDefinition, "enter") && hasOpacity(targetDefinition, "exit") && effect.getKeyframes().some((keyframe) => keyframe.mixBlendMode)) {
              animations.push(new NativeAnimationWrapper(animation));
            } else {
              animation.cancel();
            }
          }
          resolve(new GroupAnimation(animations));
        });
      });
    }
    function hasOpacity(target, key) {
      var _a;
      return (_a = target == null ? void 0 : target[key]) == null ? void 0 : _a.keyframes.opacity;
    }
    var builders = [];
    var current = null;
    function next() {
      current = null;
      const [nextBuilder] = builders;
      if (nextBuilder)
        start(nextBuilder);
    }
    function start(builder) {
      motionUtils.removeItem(builders, builder);
      current = builder;
      startViewAnimation(builder).then((animation) => {
        builder.notifyReady(animation);
        animation.finished.finally(next);
      });
    }
    function processQueue() {
      var _a;
      for (let i = builders.length - 1; i >= 0; i--) {
        const builder = builders[i];
        const { interrupt } = builder.options;
        if (interrupt === "immediate") {
          const batchedUpdates = builders.slice(0, i + 1).map((b) => b.update);
          const remaining = builders.slice(i + 1);
          builder.update = () => {
            batchedUpdates.forEach((update) => update());
          };
          builders = [builder, ...remaining];
          break;
        }
      }
      if (!current || ((_a = builders[0]) == null ? void 0 : _a.options.interrupt) === "immediate") {
        next();
      }
    }
    function addToQueue(builder) {
      builders.push(builder);
      microtask.render(processQueue);
    }
    var ViewTransitionBuilder = class {
      constructor(update, options = {}) {
        this.currentTarget = "root";
        this.targets = /* @__PURE__ */ new Map();
        this.notifyReady = motionUtils.noop;
        this.readyPromise = new Promise((resolve) => {
          this.notifyReady = resolve;
        });
        this.update = update;
        this.options = {
          interrupt: "wait",
          ...options
        };
        addToQueue(this);
      }
      get(selector) {
        this.currentTarget = selector;
        return this;
      }
      layout(keyframes2, options) {
        this.updateTarget("layout", keyframes2, options);
        return this;
      }
      new(keyframes2, options) {
        this.updateTarget("new", keyframes2, options);
        return this;
      }
      old(keyframes2, options) {
        this.updateTarget("old", keyframes2, options);
        return this;
      }
      enter(keyframes2, options) {
        this.updateTarget("enter", keyframes2, options);
        return this;
      }
      exit(keyframes2, options) {
        this.updateTarget("exit", keyframes2, options);
        return this;
      }
      crossfade(options) {
        this.updateTarget("enter", { opacity: 1 }, options);
        this.updateTarget("exit", { opacity: 0 }, options);
        return this;
      }
      updateTarget(target, keyframes2, options = {}) {
        const { currentTarget, targets } = this;
        if (!targets.has(currentTarget)) {
          targets.set(currentTarget, {});
        }
        const targetData = targets.get(currentTarget);
        targetData[target] = { keyframes: keyframes2, options };
      }
      then(resolve, reject) {
        return this.readyPromise.then(resolve, reject);
      }
    };
    function animateView(update, defaultOptions = {}) {
      return new ViewTransitionBuilder(update, defaultOptions);
    }
    var sync = frame;
    var cancelSync = stepsOrder.reduce((acc, key) => {
      acc[key] = (process2) => cancelFrame(process2);
      return acc;
    }, {});
    exports.AsyncMotionValueAnimation = AsyncMotionValueAnimation;
    exports.DOMKeyframesResolver = DOMKeyframesResolver;
    exports.GroupAnimation = GroupAnimation;
    exports.GroupAnimationWithThen = GroupAnimationWithThen;
    exports.JSAnimation = JSAnimation;
    exports.KeyframeResolver = KeyframeResolver;
    exports.MotionValue = MotionValue;
    exports.NativeAnimation = NativeAnimation;
    exports.NativeAnimationExtended = NativeAnimationExtended;
    exports.NativeAnimationWrapper = NativeAnimationWrapper;
    exports.ViewTransitionBuilder = ViewTransitionBuilder;
    exports.acceleratedValues = acceleratedValues;
    exports.activeAnimations = activeAnimations;
    exports.alpha = alpha;
    exports.analyseComplexValue = analyseComplexValue;
    exports.animateValue = animateValue;
    exports.animateView = animateView;
    exports.animationMapKey = animationMapKey;
    exports.applyPxDefaults = applyPxDefaults;
    exports.calcGeneratorDuration = calcGeneratorDuration;
    exports.cancelFrame = cancelFrame;
    exports.cancelMicrotask = cancelMicrotask;
    exports.cancelSync = cancelSync;
    exports.collectMotionValues = collectMotionValues;
    exports.color = color;
    exports.complex = complex;
    exports.convertOffsetToTimes = convertOffsetToTimes;
    exports.createGeneratorEasing = createGeneratorEasing;
    exports.createRenderBatcher = createRenderBatcher;
    exports.cubicBezierAsString = cubicBezierAsString;
    exports.defaultEasing = defaultEasing;
    exports.defaultOffset = defaultOffset;
    exports.defaultValueTypes = defaultValueTypes;
    exports.degrees = degrees;
    exports.dimensionValueTypes = dimensionValueTypes;
    exports.fillOffset = fillOffset;
    exports.fillWildcards = fillWildcards;
    exports.findDimensionValueType = findDimensionValueType;
    exports.findValueType = findValueType;
    exports.flushKeyframeResolvers = flushKeyframeResolvers;
    exports.frame = frame;
    exports.frameData = frameData;
    exports.frameSteps = frameSteps;
    exports.generateLinearEasing = generateLinearEasing;
    exports.getAnimatableNone = getAnimatableNone;
    exports.getAnimationMap = getAnimationMap;
    exports.getComputedStyle = getComputedStyle$1;
    exports.getDefaultValueType = getDefaultValueType;
    exports.getMixer = getMixer;
    exports.getValueAsType = getValueAsType;
    exports.getValueTransition = getValueTransition;
    exports.getVariableValue = getVariableValue;
    exports.hex = hex;
    exports.hover = hover;
    exports.hsla = hsla;
    exports.hslaToRgba = hslaToRgba;
    exports.inertia = inertia;
    exports.interpolate = interpolate;
    exports.invisibleValues = invisibleValues;
    exports.isCSSVariableName = isCSSVariableName;
    exports.isCSSVariableToken = isCSSVariableToken;
    exports.isDragActive = isDragActive;
    exports.isDragging = isDragging;
    exports.isGenerator = isGenerator;
    exports.isNodeOrChild = isNodeOrChild;
    exports.isPrimaryPointer = isPrimaryPointer;
    exports.isWaapiSupportedEasing = isWaapiSupportedEasing;
    exports.keyframes = keyframes;
    exports.mapEasingToNativeEasing = mapEasingToNativeEasing;
    exports.mapValue = mapValue;
    exports.maxGeneratorDuration = maxGeneratorDuration;
    exports.microtask = microtask;
    exports.mix = mix;
    exports.mixArray = mixArray;
    exports.mixColor = mixColor;
    exports.mixComplex = mixComplex;
    exports.mixImmediate = mixImmediate;
    exports.mixLinearColor = mixLinearColor;
    exports.mixNumber = mixNumber$1;
    exports.mixObject = mixObject;
    exports.mixVisibility = mixVisibility;
    exports.motionValue = motionValue;
    exports.number = number;
    exports.numberValueTypes = numberValueTypes;
    exports.observeTimeline = observeTimeline;
    exports.parseCSSVariable = parseCSSVariable;
    exports.parseValueFromTransform = parseValueFromTransform;
    exports.percent = percent;
    exports.positionalKeys = positionalKeys;
    exports.press = press;
    exports.progressPercentage = progressPercentage;
    exports.px = px;
    exports.readTransformValue = readTransformValue;
    exports.recordStats = recordStats;
    exports.resolveElements = resolveElements;
    exports.rgbUnit = rgbUnit;
    exports.rgba = rgba;
    exports.scale = scale;
    exports.setDragLock = setDragLock;
    exports.setStyle = setStyle;
    exports.spring = spring;
    exports.startWaapiAnimation = startWaapiAnimation;
    exports.statsBuffer = statsBuffer;
    exports.styleEffect = styleEffect;
    exports.supportedWaapiEasing = supportedWaapiEasing;
    exports.supportsBrowserAnimation = supportsBrowserAnimation;
    exports.supportsFlags = supportsFlags;
    exports.supportsLinearEasing = supportsLinearEasing;
    exports.supportsPartialKeyframes = supportsPartialKeyframes;
    exports.supportsScrollTimeline = supportsScrollTimeline;
    exports.sync = sync;
    exports.testValueType = testValueType;
    exports.time = time;
    exports.transform = transform;
    exports.transformPropOrder = transformPropOrder;
    exports.transformProps = transformProps;
    exports.transformValue = transformValue;
    exports.transformValueTypes = transformValueTypes;
    exports.vh = vh;
    exports.vw = vw;
  }
});

// optional-peer-dep:__vite-optional-peer-dep:@emotion/is-prop-valid:framer-motion
var require_is_prop_valid_framer_motion = __commonJS({
  "optional-peer-dep:__vite-optional-peer-dep:@emotion/is-prop-valid:framer-motion"() {
    throw new Error(`Could not resolve "@emotion/is-prop-valid" imported by "framer-motion". Is it installed?`);
  }
});

// node_modules/framer-motion/dist/cjs/create-C0aMAGDw.js
var require_create_C0aMAGDw = __commonJS({
  "node_modules/framer-motion/dist/cjs/create-C0aMAGDw.js"(exports) {
    "use strict";
    var motionDom = require_cjs2();
    var motionUtils = require_cjs();
    var jsxRuntime = require_jsx_runtime();
    var React = require_react();
    var LayoutGroupContext = React.createContext({});
    function useConstant(init) {
      const ref = React.useRef(null);
      if (ref.current === null) {
        ref.current = init();
      }
      return ref.current;
    }
    var isBrowser = typeof window !== "undefined";
    var useIsomorphicLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;
    var PresenceContext = React.createContext(null);
    var MotionConfigContext = React.createContext({
      transformPagePoint: (p) => p,
      isStatic: false,
      reducedMotion: "never"
    });
    function usePresence(subscribe = true) {
      const context = React.useContext(PresenceContext);
      if (context === null)
        return [true, null];
      const { isPresent: isPresent2, onExitComplete, register } = context;
      const id2 = React.useId();
      React.useEffect(() => {
        if (subscribe) {
          return register(id2);
        }
      }, [subscribe]);
      const safeToRemove = React.useCallback(() => subscribe && onExitComplete && onExitComplete(id2), [id2, onExitComplete, subscribe]);
      return !isPresent2 && onExitComplete ? [false, safeToRemove] : [true];
    }
    function useIsPresent() {
      return isPresent(React.useContext(PresenceContext));
    }
    function isPresent(context) {
      return context === null ? true : context.isPresent;
    }
    var SCALE_PRECISION = 1e-4;
    var SCALE_MIN = 1 - SCALE_PRECISION;
    var SCALE_MAX = 1 + SCALE_PRECISION;
    var TRANSLATE_PRECISION = 0.01;
    var TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
    var TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
    function calcLength(axis) {
      return axis.max - axis.min;
    }
    function isNear(value, target, maxDistance) {
      return Math.abs(value - target) <= maxDistance;
    }
    function calcAxisDelta(delta, source, target, origin = 0.5) {
      delta.origin = origin;
      delta.originPoint = motionDom.mixNumber(source.min, source.max, delta.origin);
      delta.scale = calcLength(target) / calcLength(source);
      delta.translate = motionDom.mixNumber(target.min, target.max, delta.origin) - delta.originPoint;
      if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
        delta.scale = 1;
      }
      if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
        delta.translate = 0;
      }
    }
    function calcBoxDelta(delta, source, target, origin) {
      calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
      calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
    }
    function calcRelativeAxis(target, relative, parent) {
      target.min = parent.min + relative.min;
      target.max = target.min + calcLength(relative);
    }
    function calcRelativeBox(target, relative, parent) {
      calcRelativeAxis(target.x, relative.x, parent.x);
      calcRelativeAxis(target.y, relative.y, parent.y);
    }
    function calcRelativeAxisPosition(target, layout2, parent) {
      target.min = layout2.min - parent.min;
      target.max = target.min + calcLength(layout2);
    }
    function calcRelativePosition(target, layout2, parent) {
      calcRelativeAxisPosition(target.x, layout2.x, parent.x);
      calcRelativeAxisPosition(target.y, layout2.y, parent.y);
    }
    var isMotionValue = (value) => Boolean(value && value.getVelocity);
    var isNotNull = (value) => value !== null;
    function getFinalKeyframe(keyframes, { repeat, repeatType = "loop" }, finalKeyframe) {
      const resolvedKeyframes = keyframes.filter(isNotNull);
      const index = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
      return !index || finalKeyframe === void 0 ? resolvedKeyframes[index] : finalKeyframe;
    }
    var underDampedSpring = {
      type: "spring",
      stiffness: 500,
      damping: 25,
      restSpeed: 10
    };
    var criticallyDampedSpring = (target) => ({
      type: "spring",
      stiffness: 550,
      damping: target === 0 ? 2 * Math.sqrt(550) : 30,
      restSpeed: 10
    });
    var keyframesTransition = {
      type: "keyframes",
      duration: 0.8
    };
    var ease = {
      type: "keyframes",
      ease: [0.25, 0.1, 0.35, 1],
      duration: 0.3
    };
    var getDefaultTransition = (valueKey, { keyframes }) => {
      if (keyframes.length > 2) {
        return keyframesTransition;
      } else if (motionDom.transformProps.has(valueKey)) {
        return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes[1]) : underDampedSpring;
      }
      return ease;
    };
    function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
      return !!Object.keys(transition).length;
    }
    var animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
      const valueTransition = motionDom.getValueTransition(transition, name) || {};
      const delay2 = valueTransition.delay || transition.delay || 0;
      let { elapsed = 0 } = transition;
      elapsed = elapsed - motionUtils.secondsToMilliseconds(delay2);
      const options = {
        keyframes: Array.isArray(target) ? target : [null, target],
        ease: "easeOut",
        velocity: value.getVelocity(),
        ...valueTransition,
        delay: -elapsed,
        onUpdate: (v) => {
          value.set(v);
          valueTransition.onUpdate && valueTransition.onUpdate(v);
        },
        onComplete: () => {
          onComplete();
          valueTransition.onComplete && valueTransition.onComplete();
        },
        name,
        motionValue: value,
        element: isHandoff ? void 0 : element
      };
      if (!isTransitionDefined(valueTransition)) {
        Object.assign(options, getDefaultTransition(name, options));
      }
      options.duration && (options.duration = motionUtils.secondsToMilliseconds(options.duration));
      options.repeatDelay && (options.repeatDelay = motionUtils.secondsToMilliseconds(options.repeatDelay));
      if (options.from !== void 0) {
        options.keyframes[0] = options.from;
      }
      let shouldSkip = false;
      if (options.type === false || options.duration === 0 && !options.repeatDelay) {
        options.duration = 0;
        if (options.delay === 0) {
          shouldSkip = true;
        }
      }
      if (motionUtils.MotionGlobalConfig.instantAnimations || motionUtils.MotionGlobalConfig.skipAnimations) {
        shouldSkip = true;
        options.duration = 0;
        options.delay = 0;
      }
      options.allowFlatten = !valueTransition.type && !valueTransition.ease;
      if (shouldSkip && !isHandoff && value.get() !== void 0) {
        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
        if (finalKeyframe !== void 0) {
          motionDom.frame.update(() => {
            options.onUpdate(finalKeyframe);
            options.onComplete();
          });
          return;
        }
      }
      return new motionDom.AsyncMotionValueAnimation(options);
    };
    function animateSingleValue(value, keyframes, options) {
      const motionValue = isMotionValue(value) ? value : motionDom.motionValue(value);
      motionValue.start(animateMotionValue("", motionValue, keyframes, options));
      return motionValue.animation;
    }
    var camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();
    var optimizedAppearDataId = "framerAppearId";
    var optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
    function getOptimisedAppearId(visualElement) {
      return visualElement.props[optimizedAppearDataAttribute];
    }
    function isSVGElement(element) {
      return element instanceof SVGElement && element.tagName !== "svg";
    }
    var compareByDepth = (a, b) => a.depth - b.depth;
    var FlatTree = class {
      constructor() {
        this.children = [];
        this.isDirty = false;
      }
      add(child) {
        motionUtils.addUniqueItem(this.children, child);
        this.isDirty = true;
      }
      remove(child) {
        motionUtils.removeItem(this.children, child);
        this.isDirty = true;
      }
      forEach(callback) {
        this.isDirty && this.children.sort(compareByDepth);
        this.isDirty = false;
        this.children.forEach(callback);
      }
    };
    function delay(callback, timeout) {
      const start = motionDom.time.now();
      const checkElapsed = ({ timestamp }) => {
        const elapsed = timestamp - start;
        if (elapsed >= timeout) {
          motionDom.cancelFrame(checkElapsed);
          callback(elapsed - timeout);
        }
      };
      motionDom.frame.setup(checkElapsed, true);
      return () => motionDom.cancelFrame(checkElapsed);
    }
    function resolveMotionValue(value) {
      return isMotionValue(value) ? value.get() : value;
    }
    var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
    var numBorders = borders.length;
    var asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
    var isPx = (value) => typeof value === "number" || motionDom.px.test(value);
    function mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {
      if (shouldCrossfadeOpacity) {
        target.opacity = motionDom.mixNumber(0, lead.opacity ?? 1, easeCrossfadeIn(progress));
        target.opacityExit = motionDom.mixNumber(follow.opacity ?? 1, 0, easeCrossfadeOut(progress));
      } else if (isOnlyMember) {
        target.opacity = motionDom.mixNumber(follow.opacity ?? 1, lead.opacity ?? 1, progress);
      }
      for (let i = 0; i < numBorders; i++) {
        const borderLabel = `border${borders[i]}Radius`;
        let followRadius = getRadius(follow, borderLabel);
        let leadRadius = getRadius(lead, borderLabel);
        if (followRadius === void 0 && leadRadius === void 0)
          continue;
        followRadius || (followRadius = 0);
        leadRadius || (leadRadius = 0);
        const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
        if (canMix) {
          target[borderLabel] = Math.max(motionDom.mixNumber(asNumber(followRadius), asNumber(leadRadius), progress), 0);
          if (motionDom.percent.test(leadRadius) || motionDom.percent.test(followRadius)) {
            target[borderLabel] += "%";
          }
        } else {
          target[borderLabel] = leadRadius;
        }
      }
      if (follow.rotate || lead.rotate) {
        target.rotate = motionDom.mixNumber(follow.rotate || 0, lead.rotate || 0, progress);
      }
    }
    function getRadius(values, radiusName) {
      return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
    }
    var easeCrossfadeIn = compress(0, 0.5, motionUtils.circOut);
    var easeCrossfadeOut = compress(0.5, 0.95, motionUtils.noop);
    function compress(min, max, easing) {
      return (p) => {
        if (p < min)
          return 0;
        if (p > max)
          return 1;
        return easing(motionUtils.progress(min, max, p));
      };
    }
    function copyAxisInto(axis, originAxis) {
      axis.min = originAxis.min;
      axis.max = originAxis.max;
    }
    function copyBoxInto(box, originBox) {
      copyAxisInto(box.x, originBox.x);
      copyAxisInto(box.y, originBox.y);
    }
    function copyAxisDeltaInto(delta, originDelta) {
      delta.translate = originDelta.translate;
      delta.scale = originDelta.scale;
      delta.originPoint = originDelta.originPoint;
      delta.origin = originDelta.origin;
    }
    function isIdentityScale(scale) {
      return scale === void 0 || scale === 1;
    }
    function hasScale({ scale, scaleX, scaleY }) {
      return !isIdentityScale(scale) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
    }
    function hasTransform(values) {
      return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
    }
    function has2DTranslate(values) {
      return is2DTranslate(values.x) || is2DTranslate(values.y);
    }
    function is2DTranslate(value) {
      return value && value !== "0%";
    }
    function scalePoint(point, scale, originPoint) {
      const distanceFromOrigin = point - originPoint;
      const scaled = scale * distanceFromOrigin;
      return originPoint + scaled;
    }
    function applyPointDelta(point, translate, scale, originPoint, boxScale) {
      if (boxScale !== void 0) {
        point = scalePoint(point, boxScale, originPoint);
      }
      return scalePoint(point, scale, originPoint) + translate;
    }
    function applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {
      axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);
      axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);
    }
    function applyBoxDelta(box, { x, y }) {
      applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
      applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
    }
    var TREE_SCALE_SNAP_MIN = 0.999999999999;
    var TREE_SCALE_SNAP_MAX = 1.0000000000001;
    function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
      const treeLength = treePath.length;
      if (!treeLength)
        return;
      treeScale.x = treeScale.y = 1;
      let node;
      let delta;
      for (let i = 0; i < treeLength; i++) {
        node = treePath[i];
        delta = node.projectionDelta;
        const { visualElement } = node.options;
        if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
          continue;
        }
        if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(box, {
            x: -node.scroll.offset.x,
            y: -node.scroll.offset.y
          });
        }
        if (delta) {
          treeScale.x *= delta.x.scale;
          treeScale.y *= delta.y.scale;
          applyBoxDelta(box, delta);
        }
        if (isSharedTransition && hasTransform(node.latestValues)) {
          transformBox(box, node.latestValues);
        }
      }
      if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
        treeScale.x = 1;
      }
      if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
        treeScale.y = 1;
      }
    }
    function translateAxis(axis, distance2) {
      axis.min = axis.min + distance2;
      axis.max = axis.max + distance2;
    }
    function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
      const originPoint = motionDom.mixNumber(axis.min, axis.max, axisOrigin);
      applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
    }
    function transformBox(box, transform) {
      transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);
      transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);
    }
    function removePointDelta(point, translate, scale, originPoint, boxScale) {
      point -= translate;
      point = scalePoint(point, 1 / scale, originPoint);
      if (boxScale !== void 0) {
        point = scalePoint(point, 1 / boxScale, originPoint);
      }
      return point;
    }
    function removeAxisDelta(axis, translate = 0, scale = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
      if (motionDom.percent.test(translate)) {
        translate = parseFloat(translate);
        const relativeProgress = motionDom.mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);
        translate = relativeProgress - sourceAxis.min;
      }
      if (typeof translate !== "number")
        return;
      let originPoint = motionDom.mixNumber(originAxis.min, originAxis.max, origin);
      if (axis === originAxis)
        originPoint -= translate;
      axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);
      axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);
    }
    function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
      removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
    }
    var xKeys = ["x", "scaleX", "originX"];
    var yKeys = ["y", "scaleY", "originY"];
    function removeBoxTransforms(box, transforms, originBox, sourceBox) {
      removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
      removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
    }
    var createAxisDelta = () => ({
      translate: 0,
      scale: 1,
      origin: 0,
      originPoint: 0
    });
    var createDelta = () => ({
      x: createAxisDelta(),
      y: createAxisDelta()
    });
    var createAxis = () => ({ min: 0, max: 0 });
    var createBox = () => ({
      x: createAxis(),
      y: createAxis()
    });
    function isAxisDeltaZero(delta) {
      return delta.translate === 0 && delta.scale === 1;
    }
    function isDeltaZero(delta) {
      return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
    }
    function axisEquals(a, b) {
      return a.min === b.min && a.max === b.max;
    }
    function boxEquals(a, b) {
      return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);
    }
    function axisEqualsRounded(a, b) {
      return Math.round(a.min) === Math.round(b.min) && Math.round(a.max) === Math.round(b.max);
    }
    function boxEqualsRounded(a, b) {
      return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);
    }
    function aspectRatio(box) {
      return calcLength(box.x) / calcLength(box.y);
    }
    function axisDeltaEquals(a, b) {
      return a.translate === b.translate && a.scale === b.scale && a.originPoint === b.originPoint;
    }
    var NodeStack = class {
      constructor() {
        this.members = [];
      }
      add(node) {
        motionUtils.addUniqueItem(this.members, node);
        node.scheduleRender();
      }
      remove(node) {
        motionUtils.removeItem(this.members, node);
        if (node === this.prevLead) {
          this.prevLead = void 0;
        }
        if (node === this.lead) {
          const prevLead = this.members[this.members.length - 1];
          if (prevLead) {
            this.promote(prevLead);
          }
        }
      }
      relegate(node) {
        const indexOfNode = this.members.findIndex((member) => node === member);
        if (indexOfNode === 0)
          return false;
        let prevLead;
        for (let i = indexOfNode; i >= 0; i--) {
          const member = this.members[i];
          if (member.isPresent !== false) {
            prevLead = member;
            break;
          }
        }
        if (prevLead) {
          this.promote(prevLead);
          return true;
        } else {
          return false;
        }
      }
      promote(node, preserveFollowOpacity) {
        const prevLead = this.lead;
        if (node === prevLead)
          return;
        this.prevLead = prevLead;
        this.lead = node;
        node.show();
        if (prevLead) {
          prevLead.instance && prevLead.scheduleRender();
          node.scheduleRender();
          node.resumeFrom = prevLead;
          if (preserveFollowOpacity) {
            node.resumeFrom.preserveOpacity = true;
          }
          if (prevLead.snapshot) {
            node.snapshot = prevLead.snapshot;
            node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
          }
          if (node.root && node.root.isUpdating) {
            node.isLayoutDirty = true;
          }
          const { crossfade } = node.options;
          if (crossfade === false) {
            prevLead.hide();
          }
        }
      }
      exitAnimationComplete() {
        this.members.forEach((node) => {
          const { options, resumingFrom } = node;
          options.onExitComplete && options.onExitComplete();
          if (resumingFrom) {
            resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
          }
        });
      }
      scheduleRender() {
        this.members.forEach((node) => {
          node.instance && node.scheduleRender(false);
        });
      }
      /**
       * Clear any leads that have been removed this render to prevent them from being
       * used in future animations and to prevent memory leaks
       */
      removeLeadSnapshot() {
        if (this.lead && this.lead.snapshot) {
          this.lead.snapshot = void 0;
        }
      }
    };
    var scaleCorrectors = {};
    function addScaleCorrector(correctors) {
      for (const key in correctors) {
        scaleCorrectors[key] = correctors[key];
        if (motionDom.isCSSVariableName(key)) {
          scaleCorrectors[key].isCSSVariable = true;
        }
      }
    }
    function buildProjectionTransform(delta, treeScale, latestTransform) {
      let transform = "";
      const xTranslate = delta.x.translate / treeScale.x;
      const yTranslate = delta.y.translate / treeScale.y;
      const zTranslate = (latestTransform == null ? void 0 : latestTransform.z) || 0;
      if (xTranslate || yTranslate || zTranslate) {
        transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
      }
      if (treeScale.x !== 1 || treeScale.y !== 1) {
        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
      }
      if (latestTransform) {
        const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;
        if (transformPerspective)
          transform = `perspective(${transformPerspective}px) ${transform}`;
        if (rotate)
          transform += `rotate(${rotate}deg) `;
        if (rotateX)
          transform += `rotateX(${rotateX}deg) `;
        if (rotateY)
          transform += `rotateY(${rotateY}deg) `;
        if (skewX)
          transform += `skewX(${skewX}deg) `;
        if (skewY)
          transform += `skewY(${skewY}deg) `;
      }
      const elementScaleX = delta.x.scale * treeScale.x;
      const elementScaleY = delta.y.scale * treeScale.y;
      if (elementScaleX !== 1 || elementScaleY !== 1) {
        transform += `scale(${elementScaleX}, ${elementScaleY})`;
      }
      return transform || "none";
    }
    function eachAxis(callback) {
      return [callback("x"), callback("y")];
    }
    var globalProjectionState = {
      /**
       * Global flag as to whether the tree has animated since the last time
       * we resized the window
       */
      hasAnimatedSinceResize: true,
      /**
       * We set this to true once, on the first update. Any nodes added to the tree beyond that
       * update will be given a `data-projection-id` attribute.
       */
      hasEverUpdated: false
    };
    var metrics = {
      nodes: 0,
      calculatedTargetDeltas: 0,
      calculatedProjections: 0
    };
    var transformAxes = ["", "X", "Y", "Z"];
    var hiddenVisibility = { visibility: "hidden" };
    var animationTarget = 1e3;
    var id$1 = 0;
    function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
      const { latestValues } = visualElement;
      if (latestValues[key]) {
        values[key] = latestValues[key];
        visualElement.setStaticValue(key, 0);
        if (sharedAnimationValues) {
          sharedAnimationValues[key] = 0;
        }
      }
    }
    function cancelTreeOptimisedTransformAnimations(projectionNode) {
      projectionNode.hasCheckedOptimisedAppear = true;
      if (projectionNode.root === projectionNode)
        return;
      const { visualElement } = projectionNode.options;
      if (!visualElement)
        return;
      const appearId = getOptimisedAppearId(visualElement);
      if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
        const { layout: layout2, layoutId } = projectionNode.options;
        window.MotionCancelOptimisedAnimation(appearId, "transform", motionDom.frame, !(layout2 || layoutId));
      }
      const { parent } = projectionNode;
      if (parent && !parent.hasCheckedOptimisedAppear) {
        cancelTreeOptimisedTransformAnimations(parent);
      }
    }
    function createProjectionNode$1({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
      return class ProjectionNode {
        constructor(latestValues = {}, parent = defaultParent == null ? void 0 : defaultParent()) {
          this.id = id$1++;
          this.animationId = 0;
          this.children = /* @__PURE__ */ new Set();
          this.options = {};
          this.isTreeAnimating = false;
          this.isAnimationBlocked = false;
          this.isLayoutDirty = false;
          this.isProjectionDirty = false;
          this.isSharedProjectionDirty = false;
          this.isTransformDirty = false;
          this.updateManuallyBlocked = false;
          this.updateBlockedByResize = false;
          this.isUpdating = false;
          this.isSVG = false;
          this.needsReset = false;
          this.shouldResetTransform = false;
          this.hasCheckedOptimisedAppear = false;
          this.treeScale = { x: 1, y: 1 };
          this.eventHandlers = /* @__PURE__ */ new Map();
          this.hasTreeAnimated = false;
          this.updateScheduled = false;
          this.scheduleUpdate = () => this.update();
          this.projectionUpdateScheduled = false;
          this.checkUpdateFailed = () => {
            if (this.isUpdating) {
              this.isUpdating = false;
              this.clearAllSnapshots();
            }
          };
          this.updateProjection = () => {
            this.projectionUpdateScheduled = false;
            if (motionDom.statsBuffer.value) {
              metrics.nodes = metrics.calculatedTargetDeltas = metrics.calculatedProjections = 0;
            }
            this.nodes.forEach(propagateDirtyNodes);
            this.nodes.forEach(resolveTargetDelta);
            this.nodes.forEach(calcProjection);
            this.nodes.forEach(cleanDirtyNodes);
            if (motionDom.statsBuffer.addProjectionMetrics) {
              motionDom.statsBuffer.addProjectionMetrics(metrics);
            }
          };
          this.resolvedRelativeTargetAt = 0;
          this.hasProjected = false;
          this.isVisible = true;
          this.animationProgress = 0;
          this.sharedNodes = /* @__PURE__ */ new Map();
          this.latestValues = latestValues;
          this.root = parent ? parent.root || parent : this;
          this.path = parent ? [...parent.path, parent] : [];
          this.parent = parent;
          this.depth = parent ? parent.depth + 1 : 0;
          for (let i = 0; i < this.path.length; i++) {
            this.path[i].shouldResetTransform = true;
          }
          if (this.root === this)
            this.nodes = new FlatTree();
        }
        addEventListener(name, handler) {
          if (!this.eventHandlers.has(name)) {
            this.eventHandlers.set(name, new motionUtils.SubscriptionManager());
          }
          return this.eventHandlers.get(name).add(handler);
        }
        notifyListeners(name, ...args) {
          const subscriptionManager = this.eventHandlers.get(name);
          subscriptionManager && subscriptionManager.notify(...args);
        }
        hasListeners(name) {
          return this.eventHandlers.has(name);
        }
        /**
         * Lifecycles
         */
        mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
          if (this.instance)
            return;
          this.isSVG = isSVGElement(instance);
          this.instance = instance;
          const { layoutId, layout: layout2, visualElement } = this.options;
          if (visualElement && !visualElement.current) {
            visualElement.mount(instance);
          }
          this.root.nodes.add(this);
          this.parent && this.parent.children.add(this);
          if (isLayoutDirty && (layout2 || layoutId)) {
            this.isLayoutDirty = true;
          }
          if (attachResizeListener) {
            let cancelDelay;
            const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
            attachResizeListener(instance, () => {
              this.root.updateBlockedByResize = true;
              cancelDelay && cancelDelay();
              cancelDelay = delay(resizeUnblockUpdate, 250);
              if (globalProjectionState.hasAnimatedSinceResize) {
                globalProjectionState.hasAnimatedSinceResize = false;
                this.nodes.forEach(finishAnimation);
              }
            });
          }
          if (layoutId) {
            this.root.registerSharedNode(layoutId, this);
          }
          if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
            this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout }) => {
              if (this.isTreeAnimationBlocked()) {
                this.target = void 0;
                this.relativeTarget = void 0;
                return;
              }
              const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
              const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
              const hasTargetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout);
              const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
              if (this.options.layoutRoot || this.resumeFrom || hasOnlyRelativeTargetChanged || hasLayoutChanged && (hasTargetChanged || !this.currentAnimation)) {
                if (this.resumeFrom) {
                  this.resumingFrom = this.resumeFrom;
                  this.resumingFrom.resumingFrom = void 0;
                }
                this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
                const animationOptions = {
                  ...motionDom.getValueTransition(layoutTransition, "layout"),
                  onPlay: onLayoutAnimationStart,
                  onComplete: onLayoutAnimationComplete
                };
                if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
                  animationOptions.delay = 0;
                  animationOptions.type = false;
                }
                this.startAnimation(animationOptions);
              } else {
                if (!hasLayoutChanged) {
                  finishAnimation(this);
                }
                if (this.isLead() && this.options.onExitComplete) {
                  this.options.onExitComplete();
                }
              }
              this.targetLayout = newLayout;
            });
          }
        }
        unmount() {
          this.options.layoutId && this.willUpdate();
          this.root.nodes.remove(this);
          const stack = this.getStack();
          stack && stack.remove(this);
          this.parent && this.parent.children.delete(this);
          this.instance = void 0;
          this.eventHandlers.clear();
          motionDom.cancelFrame(this.updateProjection);
        }
        // only on the root
        blockUpdate() {
          this.updateManuallyBlocked = true;
        }
        unblockUpdate() {
          this.updateManuallyBlocked = false;
        }
        isUpdateBlocked() {
          return this.updateManuallyBlocked || this.updateBlockedByResize;
        }
        isTreeAnimationBlocked() {
          return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
        }
        // Note: currently only running on root node
        startUpdate() {
          if (this.isUpdateBlocked())
            return;
          this.isUpdating = true;
          this.nodes && this.nodes.forEach(resetSkewAndRotation);
          this.animationId++;
        }
        getTransformTemplate() {
          const { visualElement } = this.options;
          return visualElement && visualElement.getProps().transformTemplate;
        }
        willUpdate(shouldNotifyListeners = true) {
          this.root.hasTreeAnimated = true;
          if (this.root.isUpdateBlocked()) {
            this.options.onExitComplete && this.options.onExitComplete();
            return;
          }
          if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
            cancelTreeOptimisedTransformAnimations(this);
          }
          !this.root.isUpdating && this.root.startUpdate();
          if (this.isLayoutDirty)
            return;
          this.isLayoutDirty = true;
          for (let i = 0; i < this.path.length; i++) {
            const node = this.path[i];
            node.shouldResetTransform = true;
            node.updateScroll("snapshot");
            if (node.options.layoutRoot) {
              node.willUpdate(false);
            }
          }
          const { layoutId, layout: layout2 } = this.options;
          if (layoutId === void 0 && !layout2)
            return;
          const transformTemplate = this.getTransformTemplate();
          this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
          this.updateSnapshot();
          shouldNotifyListeners && this.notifyListeners("willUpdate");
        }
        update() {
          this.updateScheduled = false;
          const updateWasBlocked = this.isUpdateBlocked();
          if (updateWasBlocked) {
            this.unblockUpdate();
            this.clearAllSnapshots();
            this.nodes.forEach(clearMeasurements);
            return;
          }
          if (!this.isUpdating) {
            this.nodes.forEach(clearIsLayoutDirty);
          }
          this.isUpdating = false;
          this.nodes.forEach(resetTransformStyle);
          this.nodes.forEach(updateLayout);
          this.nodes.forEach(notifyLayoutUpdate);
          this.clearAllSnapshots();
          const now = motionDom.time.now();
          motionDom.frameData.delta = motionUtils.clamp(0, 1e3 / 60, now - motionDom.frameData.timestamp);
          motionDom.frameData.timestamp = now;
          motionDom.frameData.isProcessing = true;
          motionDom.frameSteps.update.process(motionDom.frameData);
          motionDom.frameSteps.preRender.process(motionDom.frameData);
          motionDom.frameSteps.render.process(motionDom.frameData);
          motionDom.frameData.isProcessing = false;
        }
        didUpdate() {
          if (!this.updateScheduled) {
            this.updateScheduled = true;
            motionDom.microtask.read(this.scheduleUpdate);
          }
        }
        clearAllSnapshots() {
          this.nodes.forEach(clearSnapshot);
          this.sharedNodes.forEach(removeLeadSnapshots);
        }
        scheduleUpdateProjection() {
          if (!this.projectionUpdateScheduled) {
            this.projectionUpdateScheduled = true;
            motionDom.frame.preRender(this.updateProjection, false, true);
          }
        }
        scheduleCheckAfterUnmount() {
          motionDom.frame.postRender(() => {
            if (this.isLayoutDirty) {
              this.root.didUpdate();
            } else {
              this.root.checkUpdateFailed();
            }
          });
        }
        /**
         * Update measurements
         */
        updateSnapshot() {
          if (this.snapshot || !this.instance)
            return;
          this.snapshot = this.measure();
          if (this.snapshot && !calcLength(this.snapshot.measuredBox.x) && !calcLength(this.snapshot.measuredBox.y)) {
            this.snapshot = void 0;
          }
        }
        updateLayout() {
          if (!this.instance)
            return;
          this.updateScroll();
          if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
            return;
          }
          if (this.resumeFrom && !this.resumeFrom.instance) {
            for (let i = 0; i < this.path.length; i++) {
              const node = this.path[i];
              node.updateScroll();
            }
          }
          const prevLayout = this.layout;
          this.layout = this.measure(false);
          this.layoutCorrected = createBox();
          this.isLayoutDirty = false;
          this.projectionDelta = void 0;
          this.notifyListeners("measure", this.layout.layoutBox);
          const { visualElement } = this.options;
          visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
        }
        updateScroll(phase = "measure") {
          let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
          if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
            needsMeasurement = false;
          }
          if (needsMeasurement) {
            const isRoot = checkIsScrollRoot(this.instance);
            this.scroll = {
              animationId: this.root.animationId,
              phase,
              isRoot,
              offset: measureScroll(this.instance),
              wasRoot: this.scroll ? this.scroll.isRoot : isRoot
            };
          }
        }
        resetTransform() {
          if (!resetTransform)
            return;
          const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
          const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
          const transformTemplate = this.getTransformTemplate();
          const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
          const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
          if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
            resetTransform(this.instance, transformTemplateValue);
            this.shouldResetTransform = false;
            this.scheduleRender();
          }
        }
        measure(removeTransform = true) {
          const pageBox = this.measurePageBox();
          let layoutBox = this.removeElementScroll(pageBox);
          if (removeTransform) {
            layoutBox = this.removeTransform(layoutBox);
          }
          roundBox(layoutBox);
          return {
            animationId: this.root.animationId,
            measuredBox: pageBox,
            layoutBox,
            latestValues: {},
            source: this.id
          };
        }
        measurePageBox() {
          var _a;
          const { visualElement } = this.options;
          if (!visualElement)
            return createBox();
          const box = visualElement.measureViewportBox();
          const wasInScrollRoot = ((_a = this.scroll) == null ? void 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot);
          if (!wasInScrollRoot) {
            const { scroll } = this.root;
            if (scroll) {
              translateAxis(box.x, scroll.offset.x);
              translateAxis(box.y, scroll.offset.y);
            }
          }
          return box;
        }
        removeElementScroll(box) {
          var _a;
          const boxWithoutScroll = createBox();
          copyBoxInto(boxWithoutScroll, box);
          if ((_a = this.scroll) == null ? void 0 : _a.wasRoot) {
            return boxWithoutScroll;
          }
          for (let i = 0; i < this.path.length; i++) {
            const node = this.path[i];
            const { scroll, options } = node;
            if (node !== this.root && scroll && options.layoutScroll) {
              if (scroll.wasRoot) {
                copyBoxInto(boxWithoutScroll, box);
              }
              translateAxis(boxWithoutScroll.x, scroll.offset.x);
              translateAxis(boxWithoutScroll.y, scroll.offset.y);
            }
          }
          return boxWithoutScroll;
        }
        applyTransform(box, transformOnly = false) {
          const withTransforms = createBox();
          copyBoxInto(withTransforms, box);
          for (let i = 0; i < this.path.length; i++) {
            const node = this.path[i];
            if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
              transformBox(withTransforms, {
                x: -node.scroll.offset.x,
                y: -node.scroll.offset.y
              });
            }
            if (!hasTransform(node.latestValues))
              continue;
            transformBox(withTransforms, node.latestValues);
          }
          if (hasTransform(this.latestValues)) {
            transformBox(withTransforms, this.latestValues);
          }
          return withTransforms;
        }
        removeTransform(box) {
          const boxWithoutTransform = createBox();
          copyBoxInto(boxWithoutTransform, box);
          for (let i = 0; i < this.path.length; i++) {
            const node = this.path[i];
            if (!node.instance)
              continue;
            if (!hasTransform(node.latestValues))
              continue;
            hasScale(node.latestValues) && node.updateSnapshot();
            const sourceBox = createBox();
            const nodeBox = node.measurePageBox();
            copyBoxInto(sourceBox, nodeBox);
            removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
          }
          if (hasTransform(this.latestValues)) {
            removeBoxTransforms(boxWithoutTransform, this.latestValues);
          }
          return boxWithoutTransform;
        }
        setTargetDelta(delta) {
          this.targetDelta = delta;
          this.root.scheduleUpdateProjection();
          this.isProjectionDirty = true;
        }
        setOptions(options) {
          this.options = {
            ...this.options,
            ...options,
            crossfade: options.crossfade !== void 0 ? options.crossfade : true
          };
        }
        clearMeasurements() {
          this.scroll = void 0;
          this.layout = void 0;
          this.snapshot = void 0;
          this.prevTransformTemplateValue = void 0;
          this.targetDelta = void 0;
          this.target = void 0;
          this.isLayoutDirty = false;
        }
        forceRelativeParentToResolveTarget() {
          if (!this.relativeParent)
            return;
          if (this.relativeParent.resolvedRelativeTargetAt !== motionDom.frameData.timestamp) {
            this.relativeParent.resolveTargetDelta(true);
          }
        }
        resolveTargetDelta(forceRecalculation = false) {
          var _a;
          const lead = this.getLead();
          this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
          this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
          this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
          const isShared = Boolean(this.resumingFrom) || this !== lead;
          const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a = this.parent) == null ? void 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
          if (canSkip)
            return;
          const { layout: layout2, layoutId } = this.options;
          if (!this.layout || !(layout2 || layoutId))
            return;
          this.resolvedRelativeTargetAt = motionDom.frameData.timestamp;
          if (!this.targetDelta && !this.relativeTarget) {
            const relativeParent = this.getClosestProjectingParent();
            if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
              this.relativeParent = relativeParent;
              this.forceRelativeParentToResolveTarget();
              this.relativeTarget = createBox();
              this.relativeTargetOrigin = createBox();
              calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
              copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
            } else {
              this.relativeParent = this.relativeTarget = void 0;
            }
          }
          if (!this.relativeTarget && !this.targetDelta)
            return;
          if (!this.target) {
            this.target = createBox();
            this.targetWithTransforms = createBox();
          }
          if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
            this.forceRelativeParentToResolveTarget();
            calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
          } else if (this.targetDelta) {
            if (Boolean(this.resumingFrom)) {
              this.target = this.applyTransform(this.layout.layoutBox);
            } else {
              copyBoxInto(this.target, this.layout.layoutBox);
            }
            applyBoxDelta(this.target, this.targetDelta);
          } else {
            copyBoxInto(this.target, this.layout.layoutBox);
          }
          if (this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = false;
            const relativeParent = this.getClosestProjectingParent();
            if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
              this.relativeParent = relativeParent;
              this.forceRelativeParentToResolveTarget();
              this.relativeTarget = createBox();
              this.relativeTargetOrigin = createBox();
              calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
              copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
            } else {
              this.relativeParent = this.relativeTarget = void 0;
            }
          }
          if (motionDom.statsBuffer.value) {
            metrics.calculatedTargetDeltas++;
          }
        }
        getClosestProjectingParent() {
          if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
            return void 0;
          }
          if (this.parent.isProjecting()) {
            return this.parent;
          } else {
            return this.parent.getClosestProjectingParent();
          }
        }
        isProjecting() {
          return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
        }
        calcProjection() {
          var _a;
          const lead = this.getLead();
          const isShared = Boolean(this.resumingFrom) || this !== lead;
          let canSkip = true;
          if (this.isProjectionDirty || ((_a = this.parent) == null ? void 0 : _a.isProjectionDirty)) {
            canSkip = false;
          }
          if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
            canSkip = false;
          }
          if (this.resolvedRelativeTargetAt === motionDom.frameData.timestamp) {
            canSkip = false;
          }
          if (canSkip)
            return;
          const { layout: layout2, layoutId } = this.options;
          this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
          if (!this.isTreeAnimating) {
            this.targetDelta = this.relativeTarget = void 0;
          }
          if (!this.layout || !(layout2 || layoutId))
            return;
          copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
          const prevTreeScaleX = this.treeScale.x;
          const prevTreeScaleY = this.treeScale.y;
          applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
          if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
            lead.target = lead.layout.layoutBox;
            lead.targetWithTransforms = createBox();
          }
          const { target } = lead;
          if (!target) {
            if (this.prevProjectionDelta) {
              this.createProjectionDeltas();
              this.scheduleRender();
            }
            return;
          }
          if (!this.projectionDelta || !this.prevProjectionDelta) {
            this.createProjectionDeltas();
          } else {
            copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
            copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
          }
          calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
          if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
            this.hasProjected = true;
            this.scheduleRender();
            this.notifyListeners("projectionUpdate", target);
          }
          if (motionDom.statsBuffer.value) {
            metrics.calculatedProjections++;
          }
        }
        hide() {
          this.isVisible = false;
        }
        show() {
          this.isVisible = true;
        }
        scheduleRender(notifyAll = true) {
          var _a;
          (_a = this.options.visualElement) == null ? void 0 : _a.scheduleRender();
          if (notifyAll) {
            const stack = this.getStack();
            stack && stack.scheduleRender();
          }
          if (this.resumingFrom && !this.resumingFrom.instance) {
            this.resumingFrom = void 0;
          }
        }
        createProjectionDeltas() {
          this.prevProjectionDelta = createDelta();
          this.projectionDelta = createDelta();
          this.projectionDeltaWithTransform = createDelta();
        }
        setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
          const snapshot = this.snapshot;
          const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
          const mixedValues = { ...this.latestValues };
          const targetDelta = createDelta();
          if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
            this.relativeTarget = this.relativeTargetOrigin = void 0;
          }
          this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
          const relativeLayout = createBox();
          const snapshotSource = snapshot ? snapshot.source : void 0;
          const layoutSource = this.layout ? this.layout.source : void 0;
          const isSharedLayoutAnimation = snapshotSource !== layoutSource;
          const stack = this.getStack();
          const isOnlyMember = !stack || stack.members.length <= 1;
          const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
          this.animationProgress = 0;
          let prevRelativeTarget;
          this.mixTargetDelta = (latest) => {
            const progress = latest / 1e3;
            mixAxisDelta(targetDelta.x, delta.x, progress);
            mixAxisDelta(targetDelta.y, delta.y, progress);
            this.setTargetDelta(targetDelta);
            if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
              calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
              mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress);
              if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
                this.isProjectionDirty = false;
              }
              if (!prevRelativeTarget)
                prevRelativeTarget = createBox();
              copyBoxInto(prevRelativeTarget, this.relativeTarget);
            }
            if (isSharedLayoutAnimation) {
              this.animationValues = mixedValues;
              mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);
            }
            this.root.scheduleUpdateProjection();
            this.scheduleRender();
            this.animationProgress = progress;
          };
          this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
        }
        startAnimation(options) {
          this.notifyListeners("animationStart");
          this.currentAnimation && this.currentAnimation.stop();
          if (this.resumingFrom && this.resumingFrom.currentAnimation) {
            this.resumingFrom.currentAnimation.stop();
          }
          if (this.pendingAnimation) {
            motionDom.cancelFrame(this.pendingAnimation);
            this.pendingAnimation = void 0;
          }
          this.pendingAnimation = motionDom.frame.update(() => {
            globalProjectionState.hasAnimatedSinceResize = true;
            motionDom.activeAnimations.layout++;
            this.currentAnimation = animateSingleValue(0, animationTarget, {
              ...options,
              onUpdate: (latest) => {
                this.mixTargetDelta(latest);
                options.onUpdate && options.onUpdate(latest);
              },
              onStop: () => {
                motionDom.activeAnimations.layout--;
              },
              onComplete: () => {
                motionDom.activeAnimations.layout--;
                options.onComplete && options.onComplete();
                this.completeAnimation();
              }
            });
            if (this.resumingFrom) {
              this.resumingFrom.currentAnimation = this.currentAnimation;
            }
            this.pendingAnimation = void 0;
          });
        }
        completeAnimation() {
          if (this.resumingFrom) {
            this.resumingFrom.currentAnimation = void 0;
            this.resumingFrom.preserveOpacity = void 0;
          }
          const stack = this.getStack();
          stack && stack.exitAnimationComplete();
          this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
          this.notifyListeners("animationComplete");
        }
        finishAnimation() {
          if (this.currentAnimation) {
            this.mixTargetDelta && this.mixTargetDelta(animationTarget);
            this.currentAnimation.stop();
          }
          this.completeAnimation();
        }
        applyTransformsToTarget() {
          const lead = this.getLead();
          let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
          if (!targetWithTransforms || !target || !layout2)
            return;
          if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
            target = this.target || createBox();
            const xLength = calcLength(this.layout.layoutBox.x);
            target.x.min = lead.target.x.min;
            target.x.max = target.x.min + xLength;
            const yLength = calcLength(this.layout.layoutBox.y);
            target.y.min = lead.target.y.min;
            target.y.max = target.y.min + yLength;
          }
          copyBoxInto(targetWithTransforms, target);
          transformBox(targetWithTransforms, latestValues);
          calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
        }
        registerSharedNode(layoutId, node) {
          if (!this.sharedNodes.has(layoutId)) {
            this.sharedNodes.set(layoutId, new NodeStack());
          }
          const stack = this.sharedNodes.get(layoutId);
          stack.add(node);
          const config = node.options.initialPromotionConfig;
          node.promote({
            transition: config ? config.transition : void 0,
            preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node) : void 0
          });
        }
        isLead() {
          const stack = this.getStack();
          return stack ? stack.lead === this : true;
        }
        getLead() {
          var _a;
          const { layoutId } = this.options;
          return layoutId ? ((_a = this.getStack()) == null ? void 0 : _a.lead) || this : this;
        }
        getPrevLead() {
          var _a;
          const { layoutId } = this.options;
          return layoutId ? (_a = this.getStack()) == null ? void 0 : _a.prevLead : void 0;
        }
        getStack() {
          const { layoutId } = this.options;
          if (layoutId)
            return this.root.sharedNodes.get(layoutId);
        }
        promote({ needsReset, transition, preserveFollowOpacity } = {}) {
          const stack = this.getStack();
          if (stack)
            stack.promote(this, preserveFollowOpacity);
          if (needsReset) {
            this.projectionDelta = void 0;
            this.needsReset = true;
          }
          if (transition)
            this.setOptions({ transition });
        }
        relegate() {
          const stack = this.getStack();
          if (stack) {
            return stack.relegate(this);
          } else {
            return false;
          }
        }
        resetSkewAndRotation() {
          const { visualElement } = this.options;
          if (!visualElement)
            return;
          let hasDistortingTransform = false;
          const { latestValues } = visualElement;
          if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
            hasDistortingTransform = true;
          }
          if (!hasDistortingTransform)
            return;
          const resetValues = {};
          if (latestValues.z) {
            resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
          }
          for (let i = 0; i < transformAxes.length; i++) {
            resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
            resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
          }
          visualElement.render();
          for (const key in resetValues) {
            visualElement.setStaticValue(key, resetValues[key]);
            if (this.animationValues) {
              this.animationValues[key] = resetValues[key];
            }
          }
          visualElement.scheduleRender();
        }
        getProjectionStyles(styleProp) {
          if (!this.instance || this.isSVG)
            return void 0;
          if (!this.isVisible) {
            return hiddenVisibility;
          }
          const styles = {
            visibility: ""
          };
          const transformTemplate = this.getTransformTemplate();
          if (this.needsReset) {
            this.needsReset = false;
            styles.opacity = "";
            styles.pointerEvents = resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "";
            styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
            return styles;
          }
          const lead = this.getLead();
          if (!this.projectionDelta || !this.layout || !lead.target) {
            const emptyStyles = {};
            if (this.options.layoutId) {
              emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
              emptyStyles.pointerEvents = resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "";
            }
            if (this.hasProjected && !hasTransform(this.latestValues)) {
              emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
              this.hasProjected = false;
            }
            return emptyStyles;
          }
          const valuesToRender = lead.animationValues || lead.latestValues;
          this.applyTransformsToTarget();
          styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
          if (transformTemplate) {
            styles.transform = transformTemplate(valuesToRender, styles.transform);
          }
          const { x, y } = this.projectionDelta;
          styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
          if (lead.animationValues) {
            styles.opacity = lead === this ? valuesToRender.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
          } else {
            styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
          }
          for (const key in scaleCorrectors) {
            if (valuesToRender[key] === void 0)
              continue;
            const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];
            const corrected = styles.transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
            if (applyTo) {
              const num = applyTo.length;
              for (let i = 0; i < num; i++) {
                styles[applyTo[i]] = corrected;
              }
            } else {
              if (isCSSVariable) {
                this.options.visualElement.renderState.vars[key] = corrected;
              } else {
                styles[key] = corrected;
              }
            }
          }
          if (this.options.layoutId) {
            styles.pointerEvents = lead === this ? resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "" : "none";
          }
          return styles;
        }
        clearSnapshot() {
          this.resumeFrom = this.snapshot = void 0;
        }
        // Only run on root
        resetTree() {
          this.root.nodes.forEach((node) => {
            var _a;
            return (_a = node.currentAnimation) == null ? void 0 : _a.stop();
          });
          this.root.nodes.forEach(clearMeasurements);
          this.root.sharedNodes.clear();
        }
      };
    }
    function updateLayout(node) {
      node.updateLayout();
    }
    function notifyLayoutUpdate(node) {
      var _a;
      const snapshot = ((_a = node.resumeFrom) == null ? void 0 : _a.snapshot) || node.snapshot;
      if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
        const { layoutBox: layout2, measuredBox: measuredLayout } = node.layout;
        const { animationType } = node.options;
        const isShared = snapshot.source !== node.layout.source;
        if (animationType === "size") {
          eachAxis((axis) => {
            const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
            const length = calcLength(axisSnapshot);
            axisSnapshot.min = layout2[axis].min;
            axisSnapshot.max = axisSnapshot.min + length;
          });
        } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
          eachAxis((axis) => {
            const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
            const length = calcLength(layout2[axis]);
            axisSnapshot.max = axisSnapshot.min + length;
            if (node.relativeTarget && !node.currentAnimation) {
              node.isProjectionDirty = true;
              node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
            }
          });
        }
        const layoutDelta = createDelta();
        calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
        const visualDelta = createDelta();
        if (isShared) {
          calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
        } else {
          calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
        }
        const hasLayoutChanged = !isDeltaZero(layoutDelta);
        let hasRelativeLayoutChanged = false;
        if (!node.resumeFrom) {
          const relativeParent = node.getClosestProjectingParent();
          if (relativeParent && !relativeParent.resumeFrom) {
            const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
            if (parentSnapshot && parentLayout) {
              const relativeSnapshot = createBox();
              calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
              const relativeLayout = createBox();
              calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
              if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
                hasRelativeLayoutChanged = true;
              }
              if (relativeParent.options.layoutRoot) {
                node.relativeTarget = relativeLayout;
                node.relativeTargetOrigin = relativeSnapshot;
                node.relativeParent = relativeParent;
              }
            }
          }
        }
        node.notifyListeners("didUpdate", {
          layout: layout2,
          snapshot,
          delta: visualDelta,
          layoutDelta,
          hasLayoutChanged,
          hasRelativeLayoutChanged
        });
      } else if (node.isLead()) {
        const { onExitComplete } = node.options;
        onExitComplete && onExitComplete();
      }
      node.options.transition = void 0;
    }
    function propagateDirtyNodes(node) {
      if (motionDom.statsBuffer.value) {
        metrics.nodes++;
      }
      if (!node.parent)
        return;
      if (!node.isProjecting()) {
        node.isProjectionDirty = node.parent.isProjectionDirty;
      }
      node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));
      node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
    }
    function cleanDirtyNodes(node) {
      node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
    }
    function clearSnapshot(node) {
      node.clearSnapshot();
    }
    function clearMeasurements(node) {
      node.clearMeasurements();
    }
    function clearIsLayoutDirty(node) {
      node.isLayoutDirty = false;
    }
    function resetTransformStyle(node) {
      const { visualElement } = node.options;
      if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
        visualElement.notify("BeforeLayoutMeasure");
      }
      node.resetTransform();
    }
    function finishAnimation(node) {
      node.finishAnimation();
      node.targetDelta = node.relativeTarget = node.target = void 0;
      node.isProjectionDirty = true;
    }
    function resolveTargetDelta(node) {
      node.resolveTargetDelta();
    }
    function calcProjection(node) {
      node.calcProjection();
    }
    function resetSkewAndRotation(node) {
      node.resetSkewAndRotation();
    }
    function removeLeadSnapshots(stack) {
      stack.removeLeadSnapshot();
    }
    function mixAxisDelta(output, delta, p) {
      output.translate = motionDom.mixNumber(delta.translate, 0, p);
      output.scale = motionDom.mixNumber(delta.scale, 1, p);
      output.origin = delta.origin;
      output.originPoint = delta.originPoint;
    }
    function mixAxis(output, from, to, p) {
      output.min = motionDom.mixNumber(from.min, to.min, p);
      output.max = motionDom.mixNumber(from.max, to.max, p);
    }
    function mixBox(output, from, to, p) {
      mixAxis(output.x, from.x, to.x, p);
      mixAxis(output.y, from.y, to.y, p);
    }
    function hasOpacityCrossfade(node) {
      return node.animationValues && node.animationValues.opacityExit !== void 0;
    }
    var defaultLayoutTransition = {
      duration: 0.45,
      ease: [0.4, 0, 0.1, 1]
    };
    var userAgentContains = (string) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string);
    var roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : motionUtils.noop;
    function roundAxis(axis) {
      axis.min = roundPoint(axis.min);
      axis.max = roundPoint(axis.max);
    }
    function roundBox(box) {
      roundAxis(box.x);
      roundAxis(box.y);
    }
    function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
      return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
    }
    function checkNodeWasScrollRoot(node) {
      var _a;
      return node !== node.root && ((_a = node.scroll) == null ? void 0 : _a.wasRoot);
    }
    function addDomEvent(target, eventName, handler, options = { passive: true }) {
      target.addEventListener(eventName, handler, options);
      return () => target.removeEventListener(eventName, handler);
    }
    var DocumentProjectionNode = createProjectionNode$1({
      attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
      measureScroll: () => ({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
      }),
      checkIsScrollRoot: () => true
    });
    var rootProjectionNode = {
      current: void 0
    };
    var HTMLProjectionNode = createProjectionNode$1({
      measureScroll: (instance) => ({
        x: instance.scrollLeft,
        y: instance.scrollTop
      }),
      defaultParent: () => {
        if (!rootProjectionNode.current) {
          const documentNode = new DocumentProjectionNode({});
          documentNode.mount(window);
          documentNode.setOptions({ layoutScroll: true });
          rootProjectionNode.current = documentNode;
        }
        return rootProjectionNode.current;
      },
      resetTransform: (instance, value) => {
        instance.style.transform = value !== void 0 ? value : "none";
      },
      checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
    });
    function pixelsToPercent(pixels, axis) {
      if (axis.max === axis.min)
        return 0;
      return pixels / (axis.max - axis.min) * 100;
    }
    var correctBorderRadius = {
      correct: (latest, node) => {
        if (!node.target)
          return latest;
        if (typeof latest === "string") {
          if (motionDom.px.test(latest)) {
            latest = parseFloat(latest);
          } else {
            return latest;
          }
        }
        const x = pixelsToPercent(latest, node.target.x);
        const y = pixelsToPercent(latest, node.target.y);
        return `${x}% ${y}%`;
      }
    };
    var correctBoxShadow = {
      correct: (latest, { treeScale, projectionDelta }) => {
        const original = latest;
        const shadow = motionDom.complex.parse(latest);
        if (shadow.length > 5)
          return original;
        const template = motionDom.complex.createTransformer(latest);
        const offset = typeof shadow[0] !== "number" ? 1 : 0;
        const xScale = projectionDelta.x.scale * treeScale.x;
        const yScale = projectionDelta.y.scale * treeScale.y;
        shadow[0 + offset] /= xScale;
        shadow[1 + offset] /= yScale;
        const averageScale = motionDom.mixNumber(xScale, yScale, 0.5);
        if (typeof shadow[2 + offset] === "number")
          shadow[2 + offset] /= averageScale;
        if (typeof shadow[3 + offset] === "number")
          shadow[3 + offset] /= averageScale;
        return template(shadow);
      }
    };
    function convertBoundingBoxToBox({ top, left, right, bottom }) {
      return {
        x: { min: left, max: right },
        y: { min: top, max: bottom }
      };
    }
    function convertBoxToBoundingBox({ x, y }) {
      return { top: y.min, right: x.max, bottom: y.max, left: x.min };
    }
    function transformBoxPoints(point, transformPoint2) {
      if (!transformPoint2)
        return point;
      const topLeft = transformPoint2({ x: point.left, y: point.top });
      const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
      return {
        top: topLeft.y,
        left: topLeft.x,
        bottom: bottomRight.y,
        right: bottomRight.x
      };
    }
    function measureViewportBox(instance, transformPoint2) {
      return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
    }
    function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
      const viewportBox = measureViewportBox(element, transformPagePoint);
      const { scroll } = rootProjectionNode2;
      if (scroll) {
        translateAxis(viewportBox.x, scroll.offset.x);
        translateAxis(viewportBox.y, scroll.offset.y);
      }
      return viewportBox;
    }
    var featureProps = {
      animation: [
        "animate",
        "variants",
        "whileHover",
        "whileTap",
        "exit",
        "whileInView",
        "whileFocus",
        "whileDrag"
      ],
      exit: ["exit"],
      drag: ["drag", "dragControls"],
      focus: ["whileFocus"],
      hover: ["whileHover", "onHoverStart", "onHoverEnd"],
      tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
      pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
      inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
      layout: ["layout", "layoutId"]
    };
    var featureDefinitions = {};
    for (const key in featureProps) {
      featureDefinitions[key] = {
        isEnabled: (props) => featureProps[key].some((name) => !!props[name])
      };
    }
    var prefersReducedMotion = { current: null };
    var hasReducedMotionListener = { current: false };
    function initPrefersReducedMotion() {
      hasReducedMotionListener.current = true;
      if (!isBrowser)
        return;
      if (window.matchMedia) {
        const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
        const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
        motionMediaQuery.addListener(setReducedMotionPreferences);
        setReducedMotionPreferences();
      } else {
        prefersReducedMotion.current = false;
      }
    }
    var visualElementStore = /* @__PURE__ */ new WeakMap();
    function isAnimationControls(v) {
      return v !== null && typeof v === "object" && typeof v.start === "function";
    }
    function isVariantLabel(v) {
      return typeof v === "string" || Array.isArray(v);
    }
    var variantPriorityOrder = [
      "animate",
      "whileInView",
      "whileFocus",
      "whileHover",
      "whileTap",
      "whileDrag",
      "exit"
    ];
    var variantProps = ["initial", ...variantPriorityOrder];
    function isControllingVariants(props) {
      return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
    }
    function isVariantNode(props) {
      return Boolean(isControllingVariants(props) || props.variants);
    }
    function updateMotionValuesFromProps(element, next, prev) {
      for (const key in next) {
        const nextValue = next[key];
        const prevValue = prev[key];
        if (isMotionValue(nextValue)) {
          element.addValue(key, nextValue);
        } else if (isMotionValue(prevValue)) {
          element.addValue(key, motionDom.motionValue(nextValue, { owner: element }));
        } else if (prevValue !== nextValue) {
          if (element.hasValue(key)) {
            const existingValue = element.getValue(key);
            if (existingValue.liveStyle === true) {
              existingValue.jump(nextValue);
            } else if (!existingValue.hasAnimated) {
              existingValue.set(nextValue);
            }
          } else {
            const latestValue = element.getStaticValue(key);
            element.addValue(key, motionDom.motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
          }
        }
      }
      for (const key in prev) {
        if (next[key] === void 0)
          element.removeValue(key);
      }
      return next;
    }
    function getValueState(visualElement) {
      const state = [{}, {}];
      visualElement == null ? void 0 : visualElement.values.forEach((value, key) => {
        state[0][key] = value.get();
        state[1][key] = value.getVelocity();
      });
      return state;
    }
    function resolveVariantFromProps(props, definition, custom, visualElement) {
      if (typeof definition === "function") {
        const [current, velocity] = getValueState(visualElement);
        definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
      }
      if (typeof definition === "string") {
        definition = props.variants && props.variants[definition];
      }
      if (typeof definition === "function") {
        const [current, velocity] = getValueState(visualElement);
        definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
      }
      return definition;
    }
    var propEventHandlers = [
      "AnimationStart",
      "AnimationComplete",
      "Update",
      "BeforeLayoutMeasure",
      "LayoutMeasure",
      "LayoutAnimationStart",
      "LayoutAnimationComplete"
    ];
    var VisualElement = class {
      /**
       * This method takes React props and returns found MotionValues. For example, HTML
       * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
       *
       * This isn't an abstract method as it needs calling in the constructor, but it is
       * intended to be one.
       */
      scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
        return {};
      }
      constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
        this.current = null;
        this.children = /* @__PURE__ */ new Set();
        this.isVariantNode = false;
        this.isControllingVariants = false;
        this.shouldReduceMotion = null;
        this.values = /* @__PURE__ */ new Map();
        this.KeyframeResolver = motionDom.KeyframeResolver;
        this.features = {};
        this.valueSubscriptions = /* @__PURE__ */ new Map();
        this.prevMotionValues = {};
        this.events = {};
        this.propEventSubscriptions = {};
        this.notifyUpdate = () => this.notify("Update", this.latestValues);
        this.render = () => {
          if (!this.current)
            return;
          this.triggerBuild();
          this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
        };
        this.renderScheduledAt = 0;
        this.scheduleRender = () => {
          const now = motionDom.time.now();
          if (this.renderScheduledAt < now) {
            this.renderScheduledAt = now;
            motionDom.frame.render(this.render, false, true);
          }
        };
        const { latestValues, renderState } = visualState;
        this.latestValues = latestValues;
        this.baseTarget = { ...latestValues };
        this.initialValues = props.initial ? { ...latestValues } : {};
        this.renderState = renderState;
        this.parent = parent;
        this.props = props;
        this.presenceContext = presenceContext;
        this.depth = parent ? parent.depth + 1 : 0;
        this.reducedMotionConfig = reducedMotionConfig;
        this.options = options;
        this.blockInitialAnimation = Boolean(blockInitialAnimation);
        this.isControllingVariants = isControllingVariants(props);
        this.isVariantNode = isVariantNode(props);
        if (this.isVariantNode) {
          this.variantChildren = /* @__PURE__ */ new Set();
        }
        this.manuallyAnimateOnMount = Boolean(parent && parent.current);
        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
        for (const key in initialMotionValues) {
          const value = initialMotionValues[key];
          if (latestValues[key] !== void 0 && isMotionValue(value)) {
            value.set(latestValues[key], false);
          }
        }
      }
      mount(instance) {
        this.current = instance;
        visualElementStore.set(instance, this);
        if (this.projection && !this.projection.instance) {
          this.projection.mount(instance);
        }
        if (this.parent && this.isVariantNode && !this.isControllingVariants) {
          this.removeFromVariantTree = this.parent.addVariantChild(this);
        }
        this.values.forEach((value, key) => this.bindToMotionValue(key, value));
        if (!hasReducedMotionListener.current) {
          initPrefersReducedMotion();
        }
        this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
        if (true) {
          motionUtils.warnOnce(this.shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected.");
        }
        if (this.parent)
          this.parent.children.add(this);
        this.update(this.props, this.presenceContext);
      }
      unmount() {
        this.projection && this.projection.unmount();
        this.projection = void 0;
        motionDom.cancelFrame(this.notifyUpdate);
        motionDom.cancelFrame(this.render);
        this.valueSubscriptions.forEach((remove) => remove());
        this.valueSubscriptions.clear();
        this.removeFromVariantTree && this.removeFromVariantTree();
        this.parent && this.parent.children.delete(this);
        for (const key in this.events) {
          this.events[key].clear();
        }
        for (const key in this.features) {
          const feature = this.features[key];
          if (feature) {
            feature.unmount();
            feature.isMounted = false;
          }
        }
        this.current = null;
      }
      bindToMotionValue(key, value) {
        if (this.valueSubscriptions.has(key)) {
          this.valueSubscriptions.get(key)();
        }
        const valueIsTransform = motionDom.transformProps.has(key);
        if (valueIsTransform && this.onBindTransform) {
          this.onBindTransform();
        }
        const removeOnChange = value.on("change", (latestValue) => {
          this.latestValues[key] = latestValue;
          this.props.onUpdate && motionDom.frame.preRender(this.notifyUpdate);
          if (valueIsTransform && this.projection) {
            this.projection.isTransformDirty = true;
          }
        });
        const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
        let removeSyncCheck;
        if (window.MotionCheckAppearSync) {
          removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
        }
        this.valueSubscriptions.set(key, () => {
          removeOnChange();
          removeOnRenderRequest();
          if (removeSyncCheck)
            removeSyncCheck();
          if (value.owner)
            value.stop();
        });
      }
      sortNodePosition(other) {
        if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
          return 0;
        }
        return this.sortInstanceNodePosition(this.current, other.current);
      }
      updateFeatures() {
        let key = "animation";
        for (key in featureDefinitions) {
          const featureDefinition = featureDefinitions[key];
          if (!featureDefinition)
            continue;
          const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
          if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
            this.features[key] = new FeatureConstructor(this);
          }
          if (this.features[key]) {
            const feature = this.features[key];
            if (feature.isMounted) {
              feature.update();
            } else {
              feature.mount();
              feature.isMounted = true;
            }
          }
        }
      }
      triggerBuild() {
        this.build(this.renderState, this.latestValues, this.props);
      }
      /**
       * Measure the current viewport box with or without transforms.
       * Only measures axis-aligned boxes, rotate and skew must be manually
       * removed with a re-render to work.
       */
      measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
      }
      getStaticValue(key) {
        return this.latestValues[key];
      }
      setStaticValue(key, value) {
        this.latestValues[key] = value;
      }
      /**
       * Update the provided props. Ensure any newly-added motion values are
       * added to our map, old ones removed, and listeners updated.
       */
      update(props, presenceContext) {
        if (props.transformTemplate || this.props.transformTemplate) {
          this.scheduleRender();
        }
        this.prevProps = this.props;
        this.props = props;
        this.prevPresenceContext = this.presenceContext;
        this.presenceContext = presenceContext;
        for (let i = 0; i < propEventHandlers.length; i++) {
          const key = propEventHandlers[i];
          if (this.propEventSubscriptions[key]) {
            this.propEventSubscriptions[key]();
            delete this.propEventSubscriptions[key];
          }
          const listenerName = "on" + key;
          const listener = props[listenerName];
          if (listener) {
            this.propEventSubscriptions[key] = this.on(key, listener);
          }
        }
        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
        if (this.handleChildMotionValue) {
          this.handleChildMotionValue();
        }
      }
      getProps() {
        return this.props;
      }
      /**
       * Returns the variant definition with a given name.
       */
      getVariant(name) {
        return this.props.variants ? this.props.variants[name] : void 0;
      }
      /**
       * Returns the defined default transition on this component.
       */
      getDefaultTransition() {
        return this.props.transition;
      }
      getTransformPagePoint() {
        return this.props.transformPagePoint;
      }
      getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
      }
      /**
       * Add a child visual element to our set of children.
       */
      addVariantChild(child) {
        const closestVariantNode = this.getClosestVariantNode();
        if (closestVariantNode) {
          closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
          return () => closestVariantNode.variantChildren.delete(child);
        }
      }
      /**
       * Add a motion value and bind it to this visual element.
       */
      addValue(key, value) {
        const existingValue = this.values.get(key);
        if (value !== existingValue) {
          if (existingValue)
            this.removeValue(key);
          this.bindToMotionValue(key, value);
          this.values.set(key, value);
          this.latestValues[key] = value.get();
        }
      }
      /**
       * Remove a motion value and unbind any active subscriptions.
       */
      removeValue(key) {
        this.values.delete(key);
        const unsubscribe = this.valueSubscriptions.get(key);
        if (unsubscribe) {
          unsubscribe();
          this.valueSubscriptions.delete(key);
        }
        delete this.latestValues[key];
        this.removeValueFromRenderState(key, this.renderState);
      }
      /**
       * Check whether we have a motion value for this key
       */
      hasValue(key) {
        return this.values.has(key);
      }
      getValue(key, defaultValue) {
        if (this.props.values && this.props.values[key]) {
          return this.props.values[key];
        }
        let value = this.values.get(key);
        if (value === void 0 && defaultValue !== void 0) {
          value = motionDom.motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });
          this.addValue(key, value);
        }
        return value;
      }
      /**
       * If we're trying to animate to a previously unencountered value,
       * we need to check for it in our state and as a last resort read it
       * directly from the instance (which might have performance implications).
       */
      readValue(key, target) {
        let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.getBaseTargetFromProps(this.props, key) ?? this.readValueFromInstance(this.current, key, this.options);
        if (value !== void 0 && value !== null) {
          if (typeof value === "string" && (motionUtils.isNumericalString(value) || motionUtils.isZeroValueString(value))) {
            value = parseFloat(value);
          } else if (!motionDom.findValueType(value) && motionDom.complex.test(target)) {
            value = motionDom.getAnimatableNone(key, target);
          }
          this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
        }
        return isMotionValue(value) ? value.get() : value;
      }
      /**
       * Set the base target to later animate back to. This is currently
       * only hydrated on creation and when we first read a value.
       */
      setBaseTarget(key, value) {
        this.baseTarget[key] = value;
      }
      /**
       * Find the base target for a value thats been removed from all animation
       * props.
       */
      getBaseTarget(key) {
        var _a;
        const { initial } = this.props;
        let valueFromInitial;
        if (typeof initial === "string" || typeof initial === "object") {
          const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) == null ? void 0 : _a.custom);
          if (variant) {
            valueFromInitial = variant[key];
          }
        }
        if (initial && valueFromInitial !== void 0) {
          return valueFromInitial;
        }
        const target = this.getBaseTargetFromProps(this.props, key);
        if (target !== void 0 && !isMotionValue(target))
          return target;
        return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
      }
      on(eventName, callback) {
        if (!this.events[eventName]) {
          this.events[eventName] = new motionUtils.SubscriptionManager();
        }
        return this.events[eventName].add(callback);
      }
      notify(eventName, ...args) {
        if (this.events[eventName]) {
          this.events[eventName].notify(...args);
        }
      }
    };
    var DOMVisualElement = class extends VisualElement {
      constructor() {
        super(...arguments);
        this.KeyframeResolver = motionDom.DOMKeyframesResolver;
      }
      sortInstanceNodePosition(a, b) {
        return a.compareDocumentPosition(b) & 2 ? 1 : -1;
      }
      getBaseTargetFromProps(props, key) {
        return props.style ? props.style[key] : void 0;
      }
      removeValueFromRenderState(key, { vars, style }) {
        delete vars[key];
        delete style[key];
      }
      handleChildMotionValue() {
        if (this.childSubscription) {
          this.childSubscription();
          delete this.childSubscription;
        }
        const { children } = this.props;
        if (isMotionValue(children)) {
          this.childSubscription = children.on("change", (latest) => {
            if (this.current) {
              this.current.textContent = `${latest}`;
            }
          });
        }
      }
    };
    var translateAlias = {
      x: "translateX",
      y: "translateY",
      z: "translateZ",
      transformPerspective: "perspective"
    };
    var numTransforms = motionDom.transformPropOrder.length;
    function buildTransform(latestValues, transform, transformTemplate) {
      let transformString = "";
      let transformIsDefault = true;
      for (let i = 0; i < numTransforms; i++) {
        const key = motionDom.transformPropOrder[i];
        const value = latestValues[key];
        if (value === void 0)
          continue;
        let valueIsDefault = true;
        if (typeof value === "number") {
          valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
        } else {
          valueIsDefault = parseFloat(value) === 0;
        }
        if (!valueIsDefault || transformTemplate) {
          const valueAsType = motionDom.getValueAsType(value, motionDom.numberValueTypes[key]);
          if (!valueIsDefault) {
            transformIsDefault = false;
            const transformName = translateAlias[key] || key;
            transformString += `${transformName}(${valueAsType}) `;
          }
          if (transformTemplate) {
            transform[key] = valueAsType;
          }
        }
      }
      transformString = transformString.trim();
      if (transformTemplate) {
        transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
      } else if (transformIsDefault) {
        transformString = "none";
      }
      return transformString;
    }
    function buildHTMLStyles(state, latestValues, transformTemplate) {
      const { style, vars, transformOrigin } = state;
      let hasTransform2 = false;
      let hasTransformOrigin = false;
      for (const key in latestValues) {
        const value = latestValues[key];
        if (motionDom.transformProps.has(key)) {
          hasTransform2 = true;
          continue;
        } else if (motionDom.isCSSVariableName(key)) {
          vars[key] = value;
          continue;
        } else {
          const valueAsType = motionDom.getValueAsType(value, motionDom.numberValueTypes[key]);
          if (key.startsWith("origin")) {
            hasTransformOrigin = true;
            transformOrigin[key] = valueAsType;
          } else {
            style[key] = valueAsType;
          }
        }
      }
      if (!latestValues.transform) {
        if (hasTransform2 || transformTemplate) {
          style.transform = buildTransform(latestValues, state.transform, transformTemplate);
        } else if (style.transform) {
          style.transform = "none";
        }
      }
      if (hasTransformOrigin) {
        const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
        style.transformOrigin = `${originX} ${originY} ${originZ}`;
      }
    }
    function renderHTML(element, { style, vars }, styleProp, projection) {
      Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
      for (const key in vars) {
        element.style.setProperty(key, vars[key]);
      }
    }
    function isForcedMotionValue(key, { layout: layout2, layoutId }) {
      return motionDom.transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
    }
    function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
      var _a;
      const { style } = props;
      const newValues = {};
      for (const key in style) {
        if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || ((_a = visualElement == null ? void 0 : visualElement.getValue(key)) == null ? void 0 : _a.liveStyle) !== void 0) {
          newValues[key] = style[key];
        }
      }
      return newValues;
    }
    function getComputedStyle2(element) {
      return window.getComputedStyle(element);
    }
    var HTMLVisualElement = class extends DOMVisualElement {
      constructor() {
        super(...arguments);
        this.type = "html";
        this.renderInstance = renderHTML;
      }
      readValueFromInstance(instance, key) {
        if (motionDom.transformProps.has(key)) {
          return motionDom.readTransformValue(instance, key);
        } else {
          const computedStyle = getComputedStyle2(instance);
          const value = (motionDom.isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
          return typeof value === "string" ? value.trim() : value;
        }
      }
      measureInstanceViewportBox(instance, { transformPagePoint }) {
        return measureViewportBox(instance, transformPagePoint);
      }
      build(renderState, latestValues, props) {
        buildHTMLStyles(renderState, latestValues, props.transformTemplate);
      }
      scrapeMotionValuesFromProps(props, prevProps, visualElement) {
        return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
      }
    };
    var LazyContext = React.createContext({ strict: false });
    function loadFeatures(features) {
      for (const key in features) {
        featureDefinitions[key] = {
          ...featureDefinitions[key],
          ...features[key]
        };
      }
    }
    var validMotionProps = /* @__PURE__ */ new Set([
      "animate",
      "exit",
      "variants",
      "initial",
      "style",
      "values",
      "variants",
      "transition",
      "transformTemplate",
      "custom",
      "inherit",
      "onBeforeLayoutMeasure",
      "onAnimationStart",
      "onAnimationComplete",
      "onUpdate",
      "onDragStart",
      "onDrag",
      "onDragEnd",
      "onMeasureDragConstraints",
      "onDirectionLock",
      "onDragTransitionEnd",
      "_dragX",
      "_dragY",
      "onHoverStart",
      "onHoverEnd",
      "onViewportEnter",
      "onViewportLeave",
      "globalTapTarget",
      "ignoreStrict",
      "viewport"
    ]);
    function isValidMotionProp(key) {
      return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
    }
    var shouldForward = (key) => !isValidMotionProp(key);
    function loadExternalIsValidProp(isValidProp) {
      if (!isValidProp)
        return;
      shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
    }
    try {
      loadExternalIsValidProp(require_is_prop_valid_framer_motion().default);
    } catch {
    }
    function filterProps(props, isDom, forwardMotionProps) {
      const filteredProps = {};
      for (const key in props) {
        if (key === "values" && typeof props.values === "object")
          continue;
        if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
        props["draggable"] && key.startsWith("onDrag")) {
          filteredProps[key] = props[key];
        }
      }
      return filteredProps;
    }
    function resolveVariant(visualElement, definition, custom) {
      const props = visualElement.getProps();
      return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, visualElement);
    }
    var isKeyframesTarget = (v) => {
      return Array.isArray(v);
    };
    function setMotionValue(visualElement, key, value) {
      if (visualElement.hasValue(key)) {
        visualElement.getValue(key).set(value);
      } else {
        visualElement.addValue(key, motionDom.motionValue(value));
      }
    }
    function resolveFinalValueInKeyframes(v) {
      return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
    }
    function setTarget(visualElement, definition) {
      const resolved = resolveVariant(visualElement, definition);
      let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
      target = { ...target, ...transitionEnd };
      for (const key in target) {
        const value = resolveFinalValueInKeyframes(target[key]);
        setMotionValue(visualElement, key, value);
      }
    }
    function isWillChangeMotionValue(value) {
      return Boolean(isMotionValue(value) && value.add);
    }
    function addValueToWillChange(visualElement, key) {
      const willChange = visualElement.getValue("willChange");
      if (isWillChangeMotionValue(willChange)) {
        return willChange.add(key);
      } else if (!willChange && motionUtils.MotionGlobalConfig.WillChange) {
        const newWillChange = new motionUtils.MotionGlobalConfig.WillChange("auto");
        visualElement.addValue("willChange", newWillChange);
        newWillChange.add(key);
      }
    }
    function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
      const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
      needsAnimating[key] = false;
      return shouldBlock;
    }
    function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
      let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
      if (transitionOverride)
        transition = transitionOverride;
      const animations2 = [];
      const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
      for (const key in target) {
        const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);
        const valueTarget = target[key];
        if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
          continue;
        }
        const valueTransition = {
          delay: delay2,
          ...motionDom.getValueTransition(transition || {}, key)
        };
        const currentValue = value.get();
        if (currentValue !== void 0 && !value.isAnimating && !Array.isArray(valueTarget) && valueTarget === currentValue && !valueTransition.velocity) {
          continue;
        }
        let isHandoff = false;
        if (window.MotionHandoffAnimation) {
          const appearId = getOptimisedAppearId(visualElement);
          if (appearId) {
            const startTime = window.MotionHandoffAnimation(appearId, key, motionDom.frame);
            if (startTime !== null) {
              valueTransition.startTime = startTime;
              isHandoff = true;
            }
          }
        }
        addValueToWillChange(visualElement, key);
        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && motionDom.positionalKeys.has(key) ? { type: false } : valueTransition, visualElement, isHandoff));
        const animation = value.animation;
        if (animation) {
          animations2.push(animation);
        }
      }
      if (transitionEnd) {
        Promise.all(animations2).then(() => {
          motionDom.frame.update(() => {
            transitionEnd && setTarget(visualElement, transitionEnd);
          });
        });
      }
      return animations2;
    }
    function animateVariant(visualElement, variant, options = {}) {
      var _a;
      const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? (_a = visualElement.presenceContext) == null ? void 0 : _a.custom : void 0);
      let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
      if (options.transitionOverride) {
        transition = options.transitionOverride;
      }
      const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
      const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
        const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
        return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
      } : () => Promise.resolve();
      const { when } = transition;
      if (when) {
        const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
        return first().then(() => last());
      } else {
        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
      }
    }
    function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
      const animations2 = [];
      const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
      const generateStaggerDuration = staggerDirection === 1 ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;
      Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {
        child.notify("AnimationStart", variant);
        animations2.push(animateVariant(child, variant, {
          ...options,
          delay: delayChildren + generateStaggerDuration(i)
        }).then(() => child.notify("AnimationComplete", variant)));
      });
      return Promise.all(animations2);
    }
    function sortByTreeOrder(a, b) {
      return a.sortNodePosition(b);
    }
    function animateVisualElement(visualElement, definition, options = {}) {
      visualElement.notify("AnimationStart", definition);
      let animation;
      if (Array.isArray(definition)) {
        const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
        animation = Promise.all(animations2);
      } else if (typeof definition === "string") {
        animation = animateVariant(visualElement, definition, options);
      } else {
        const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
        animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
      }
      return animation.then(() => {
        visualElement.notify("AnimationComplete", definition);
      });
    }
    function shallowCompare(next, prev) {
      if (!Array.isArray(prev))
        return false;
      const prevLength = prev.length;
      if (prevLength !== next.length)
        return false;
      for (let i = 0; i < prevLength; i++) {
        if (prev[i] !== next[i])
          return false;
      }
      return true;
    }
    var numVariantProps = variantProps.length;
    function getVariantContext(visualElement) {
      if (!visualElement)
        return void 0;
      if (!visualElement.isControllingVariants) {
        const context2 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
        if (visualElement.props.initial !== void 0) {
          context2.initial = visualElement.props.initial;
        }
        return context2;
      }
      const context = {};
      for (let i = 0; i < numVariantProps; i++) {
        const name = variantProps[i];
        const prop = visualElement.props[name];
        if (isVariantLabel(prop) || prop === false) {
          context[name] = prop;
        }
      }
      return context;
    }
    var reversePriorityOrder = [...variantPriorityOrder].reverse();
    var numAnimationTypes = variantPriorityOrder.length;
    function animateList(visualElement) {
      return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
    }
    function createAnimationState(visualElement) {
      let animate = animateList(visualElement);
      let state = createState();
      let isInitialRender = true;
      const buildResolvedTypeValues = (type) => (acc, definition) => {
        var _a;
        const resolved = resolveVariant(visualElement, definition, type === "exit" ? (_a = visualElement.presenceContext) == null ? void 0 : _a.custom : void 0);
        if (resolved) {
          const { transition, transitionEnd, ...target } = resolved;
          acc = { ...acc, ...target, ...transitionEnd };
        }
        return acc;
      };
      function setAnimateFunction(makeAnimator) {
        animate = makeAnimator(visualElement);
      }
      function animateChanges(changedActiveType) {
        const { props } = visualElement;
        const context = getVariantContext(visualElement.parent) || {};
        const animations2 = [];
        const removedKeys = /* @__PURE__ */ new Set();
        let encounteredKeys = {};
        let removedVariantIndex = Infinity;
        for (let i = 0; i < numAnimationTypes; i++) {
          const type = reversePriorityOrder[i];
          const typeState = state[type];
          const prop = props[type] !== void 0 ? props[type] : context[type];
          const propIsVariant = isVariantLabel(prop);
          const activeDelta = type === changedActiveType ? typeState.isActive : null;
          if (activeDelta === false)
            removedVariantIndex = i;
          let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
          if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
            isInherited = false;
          }
          typeState.protectedKeys = { ...encounteredKeys };
          if (
            // If it isn't active and hasn't *just* been set as inactive
            !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
            !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
            isAnimationControls(prop) || typeof prop === "boolean"
          ) {
            continue;
          }
          const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
          let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
          type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
          i > removedVariantIndex && propIsVariant;
          let handledRemovedValues = false;
          const definitionList = Array.isArray(prop) ? prop : [prop];
          let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
          if (activeDelta === false)
            resolvedValues = {};
          const { prevResolvedValues = {} } = typeState;
          const allKeys = {
            ...prevResolvedValues,
            ...resolvedValues
          };
          const markToAnimate = (key) => {
            shouldAnimateType = true;
            if (removedKeys.has(key)) {
              handledRemovedValues = true;
              removedKeys.delete(key);
            }
            typeState.needsAnimating[key] = true;
            const motionValue = visualElement.getValue(key);
            if (motionValue)
              motionValue.liveStyle = false;
          };
          for (const key in allKeys) {
            const next = resolvedValues[key];
            const prev = prevResolvedValues[key];
            if (encounteredKeys.hasOwnProperty(key))
              continue;
            let valueHasChanged = false;
            if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
              valueHasChanged = !shallowCompare(next, prev);
            } else {
              valueHasChanged = next !== prev;
            }
            if (valueHasChanged) {
              if (next !== void 0 && next !== null) {
                markToAnimate(key);
              } else {
                removedKeys.add(key);
              }
            } else if (next !== void 0 && removedKeys.has(key)) {
              markToAnimate(key);
            } else {
              typeState.protectedKeys[key] = true;
            }
          }
          typeState.prevProp = prop;
          typeState.prevResolvedValues = resolvedValues;
          if (typeState.isActive) {
            encounteredKeys = { ...encounteredKeys, ...resolvedValues };
          }
          if (isInitialRender && visualElement.blockInitialAnimation) {
            shouldAnimateType = false;
          }
          const willAnimateViaParent = isInherited && variantDidChange;
          const needsAnimating = !willAnimateViaParent || handledRemovedValues;
          if (shouldAnimateType && needsAnimating) {
            animations2.push(...definitionList.map((animation) => ({
              animation,
              options: { type }
            })));
          }
        }
        if (removedKeys.size) {
          const fallbackAnimation = {};
          if (typeof props.initial !== "boolean") {
            const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial);
            if (initialTransition && initialTransition.transition) {
              fallbackAnimation.transition = initialTransition.transition;
            }
          }
          removedKeys.forEach((key) => {
            const fallbackTarget = visualElement.getBaseTarget(key);
            const motionValue = visualElement.getValue(key);
            if (motionValue)
              motionValue.liveStyle = true;
            fallbackAnimation[key] = fallbackTarget ?? null;
          });
          animations2.push({ animation: fallbackAnimation });
        }
        let shouldAnimate = Boolean(animations2.length);
        if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
          shouldAnimate = false;
        }
        isInitialRender = false;
        return shouldAnimate ? animate(animations2) : Promise.resolve();
      }
      function setActive(type, isActive) {
        var _a;
        if (state[type].isActive === isActive)
          return Promise.resolve();
        (_a = visualElement.variantChildren) == null ? void 0 : _a.forEach((child) => {
          var _a2;
          return (_a2 = child.animationState) == null ? void 0 : _a2.setActive(type, isActive);
        });
        state[type].isActive = isActive;
        const animations2 = animateChanges(type);
        for (const key in state) {
          state[key].protectedKeys = {};
        }
        return animations2;
      }
      return {
        animateChanges,
        setActive,
        setAnimateFunction,
        getState: () => state,
        reset: () => {
          state = createState();
          isInitialRender = true;
        }
      };
    }
    function checkVariantsDidChange(prev, next) {
      if (typeof next === "string") {
        return next !== prev;
      } else if (Array.isArray(next)) {
        return !shallowCompare(next, prev);
      }
      return false;
    }
    function createTypeState(isActive = false) {
      return {
        isActive,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
      };
    }
    function createState() {
      return {
        animate: createTypeState(true),
        whileInView: createTypeState(),
        whileHover: createTypeState(),
        whileTap: createTypeState(),
        whileDrag: createTypeState(),
        whileFocus: createTypeState(),
        exit: createTypeState()
      };
    }
    var Feature = class {
      constructor(node) {
        this.isMounted = false;
        this.node = node;
      }
      update() {
      }
    };
    var AnimationFeature = class extends Feature {
      /**
       * We dynamically generate the AnimationState manager as it contains a reference
       * to the underlying animation library. We only want to load that if we load this,
       * so people can optionally code split it out using the `m` component.
       */
      constructor(node) {
        super(node);
        node.animationState || (node.animationState = createAnimationState(node));
      }
      updateAnimationControlsSubscription() {
        const { animate } = this.node.getProps();
        if (isAnimationControls(animate)) {
          this.unmountControls = animate.subscribe(this.node);
        }
      }
      /**
       * Subscribe any provided AnimationControls to the component's VisualElement
       */
      mount() {
        this.updateAnimationControlsSubscription();
      }
      update() {
        const { animate } = this.node.getProps();
        const { animate: prevAnimate } = this.node.prevProps || {};
        if (animate !== prevAnimate) {
          this.updateAnimationControlsSubscription();
        }
      }
      unmount() {
        var _a;
        this.node.animationState.reset();
        (_a = this.unmountControls) == null ? void 0 : _a.call(this);
      }
    };
    var id = 0;
    var ExitAnimationFeature = class extends Feature {
      constructor() {
        super(...arguments);
        this.id = id++;
      }
      update() {
        if (!this.node.presenceContext)
          return;
        const { isPresent: isPresent2, onExitComplete } = this.node.presenceContext;
        const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
        if (!this.node.animationState || isPresent2 === prevIsPresent) {
          return;
        }
        const exitAnimation = this.node.animationState.setActive("exit", !isPresent2);
        if (onExitComplete && !isPresent2) {
          exitAnimation.then(() => {
            onExitComplete(this.id);
          });
        }
      }
      mount() {
        const { register, onExitComplete } = this.node.presenceContext || {};
        if (onExitComplete) {
          onExitComplete(this.id);
        }
        if (register) {
          this.unmount = register(this.id);
        }
      }
      unmount() {
      }
    };
    var animations = {
      animation: {
        Feature: AnimationFeature
      },
      exit: {
        Feature: ExitAnimationFeature
      }
    };
    function extractEventInfo(event) {
      return {
        point: {
          x: event.pageX,
          y: event.pageY
        }
      };
    }
    var addPointerInfo = (handler) => {
      return (event) => motionDom.isPrimaryPointer(event) && handler(event, extractEventInfo(event));
    };
    function addPointerEvent(target, eventName, handler, options) {
      return addDomEvent(target, eventName, addPointerInfo(handler), options);
    }
    var getContextWindow = ({ current }) => {
      return current ? current.ownerDocument.defaultView : null;
    };
    function isRefObject(ref) {
      return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
    }
    var distance = (a, b) => Math.abs(a - b);
    function distance2D(a, b) {
      const xDelta = distance(a.x, b.x);
      const yDelta = distance(a.y, b.y);
      return Math.sqrt(xDelta ** 2 + yDelta ** 2);
    }
    var PanSession = class {
      constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {
        this.startEvent = null;
        this.lastMoveEvent = null;
        this.lastMoveEventInfo = null;
        this.handlers = {};
        this.contextWindow = window;
        this.updatePoint = () => {
          if (!(this.lastMoveEvent && this.lastMoveEventInfo))
            return;
          const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
          const isPanStarted = this.startEvent !== null;
          const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
          if (!isPanStarted && !isDistancePastThreshold)
            return;
          const { point: point2 } = info2;
          const { timestamp: timestamp2 } = motionDom.frameData;
          this.history.push({ ...point2, timestamp: timestamp2 });
          const { onStart, onMove } = this.handlers;
          if (!isPanStarted) {
            onStart && onStart(this.lastMoveEvent, info2);
            this.startEvent = this.lastMoveEvent;
          }
          onMove && onMove(this.lastMoveEvent, info2);
        };
        this.handlePointerMove = (event2, info2) => {
          this.lastMoveEvent = event2;
          this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
          motionDom.frame.update(this.updatePoint, true);
        };
        this.handlePointerUp = (event2, info2) => {
          this.end();
          const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
          if (this.dragSnapToOrigin)
            resumeAnimation && resumeAnimation();
          if (!(this.lastMoveEvent && this.lastMoveEventInfo))
            return;
          const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
          if (this.startEvent && onEnd) {
            onEnd(event2, panInfo);
          }
          onSessionEnd && onSessionEnd(event2, panInfo);
        };
        if (!motionDom.isPrimaryPointer(event))
          return;
        this.dragSnapToOrigin = dragSnapToOrigin;
        this.handlers = handlers;
        this.transformPagePoint = transformPagePoint;
        this.contextWindow = contextWindow || window;
        const info = extractEventInfo(event);
        const initialInfo = transformPoint(info, this.transformPagePoint);
        const { point } = initialInfo;
        const { timestamp } = motionDom.frameData;
        this.history = [{ ...point, timestamp }];
        const { onSessionStart } = handlers;
        onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
        this.removeListeners = motionUtils.pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
      }
      updateHandlers(handlers) {
        this.handlers = handlers;
      }
      end() {
        this.removeListeners && this.removeListeners();
        motionDom.cancelFrame(this.updatePoint);
      }
    };
    function transformPoint(info, transformPagePoint) {
      return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
    }
    function subtractPoint(a, b) {
      return { x: a.x - b.x, y: a.y - b.y };
    }
    function getPanInfo({ point }, history) {
      return {
        point,
        delta: subtractPoint(point, lastDevicePoint(history)),
        offset: subtractPoint(point, startDevicePoint(history)),
        velocity: getVelocity(history, 0.1)
      };
    }
    function startDevicePoint(history) {
      return history[0];
    }
    function lastDevicePoint(history) {
      return history[history.length - 1];
    }
    function getVelocity(history, timeDelta) {
      if (history.length < 2) {
        return { x: 0, y: 0 };
      }
      let i = history.length - 1;
      let timestampedPoint = null;
      const lastPoint = lastDevicePoint(history);
      while (i >= 0) {
        timestampedPoint = history[i];
        if (lastPoint.timestamp - timestampedPoint.timestamp > motionUtils.secondsToMilliseconds(timeDelta)) {
          break;
        }
        i--;
      }
      if (!timestampedPoint) {
        return { x: 0, y: 0 };
      }
      const time = motionUtils.millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
      if (time === 0) {
        return { x: 0, y: 0 };
      }
      const currentVelocity = {
        x: (lastPoint.x - timestampedPoint.x) / time,
        y: (lastPoint.y - timestampedPoint.y) / time
      };
      if (currentVelocity.x === Infinity) {
        currentVelocity.x = 0;
      }
      if (currentVelocity.y === Infinity) {
        currentVelocity.y = 0;
      }
      return currentVelocity;
    }
    function applyConstraints(point, { min, max }, elastic) {
      if (min !== void 0 && point < min) {
        point = elastic ? motionDom.mixNumber(min, point, elastic.min) : Math.max(point, min);
      } else if (max !== void 0 && point > max) {
        point = elastic ? motionDom.mixNumber(max, point, elastic.max) : Math.min(point, max);
      }
      return point;
    }
    function calcRelativeAxisConstraints(axis, min, max) {
      return {
        min: min !== void 0 ? axis.min + min : void 0,
        max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
      };
    }
    function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
      return {
        x: calcRelativeAxisConstraints(layoutBox.x, left, right),
        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
      };
    }
    function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
      let min = constraintsAxis.min - layoutAxis.min;
      let max = constraintsAxis.max - layoutAxis.max;
      if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
        [min, max] = [max, min];
      }
      return { min, max };
    }
    function calcViewportConstraints(layoutBox, constraintsBox) {
      return {
        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
      };
    }
    function calcOrigin(source, target) {
      let origin = 0.5;
      const sourceLength = calcLength(source);
      const targetLength = calcLength(target);
      if (targetLength > sourceLength) {
        origin = motionUtils.progress(target.min, target.max - sourceLength, source.min);
      } else if (sourceLength > targetLength) {
        origin = motionUtils.progress(source.min, source.max - targetLength, target.min);
      }
      return motionUtils.clamp(0, 1, origin);
    }
    function rebaseAxisConstraints(layout2, constraints) {
      const relativeConstraints = {};
      if (constraints.min !== void 0) {
        relativeConstraints.min = constraints.min - layout2.min;
      }
      if (constraints.max !== void 0) {
        relativeConstraints.max = constraints.max - layout2.min;
      }
      return relativeConstraints;
    }
    var defaultElastic = 0.35;
    function resolveDragElastic(dragElastic = defaultElastic) {
      if (dragElastic === false) {
        dragElastic = 0;
      } else if (dragElastic === true) {
        dragElastic = defaultElastic;
      }
      return {
        x: resolveAxisElastic(dragElastic, "left", "right"),
        y: resolveAxisElastic(dragElastic, "top", "bottom")
      };
    }
    function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
      return {
        min: resolvePointElastic(dragElastic, minLabel),
        max: resolvePointElastic(dragElastic, maxLabel)
      };
    }
    function resolvePointElastic(dragElastic, label) {
      return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
    }
    var elementDragControls = /* @__PURE__ */ new WeakMap();
    var VisualElementDragControls = class {
      constructor(visualElement) {
        this.openDragLock = null;
        this.isDragging = false;
        this.currentDirection = null;
        this.originPoint = { x: 0, y: 0 };
        this.constraints = false;
        this.hasMutatedConstraints = false;
        this.elastic = createBox();
        this.visualElement = visualElement;
      }
      start(originEvent, { snapToCursor = false } = {}) {
        const { presenceContext } = this.visualElement;
        if (presenceContext && presenceContext.isPresent === false)
          return;
        const onSessionStart = (event) => {
          const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
          dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
          if (snapToCursor) {
            this.snapToCursor(extractEventInfo(event).point);
          }
        };
        const onStart = (event, info) => {
          const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
          if (drag2 && !dragPropagation) {
            if (this.openDragLock)
              this.openDragLock();
            this.openDragLock = motionDom.setDragLock(drag2);
            if (!this.openDragLock)
              return;
          }
          this.isDragging = true;
          this.currentDirection = null;
          this.resolveConstraints();
          if (this.visualElement.projection) {
            this.visualElement.projection.isAnimationBlocked = true;
            this.visualElement.projection.target = void 0;
          }
          eachAxis((axis) => {
            let current = this.getAxisMotionValue(axis).get() || 0;
            if (motionDom.percent.test(current)) {
              const { projection } = this.visualElement;
              if (projection && projection.layout) {
                const measuredAxis = projection.layout.layoutBox[axis];
                if (measuredAxis) {
                  const length = calcLength(measuredAxis);
                  current = length * (parseFloat(current) / 100);
                }
              }
            }
            this.originPoint[axis] = current;
          });
          if (onDragStart) {
            motionDom.frame.postRender(() => onDragStart(event, info));
          }
          addValueToWillChange(this.visualElement, "transform");
          const { animationState } = this.visualElement;
          animationState && animationState.setActive("whileDrag", true);
        };
        const onMove = (event, info) => {
          const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
          if (!dragPropagation && !this.openDragLock)
            return;
          const { offset } = info;
          if (dragDirectionLock && this.currentDirection === null) {
            this.currentDirection = getCurrentDirection(offset);
            if (this.currentDirection !== null) {
              onDirectionLock && onDirectionLock(this.currentDirection);
            }
            return;
          }
          this.updateAxis("x", info.point, offset);
          this.updateAxis("y", info.point, offset);
          this.visualElement.render();
          onDrag && onDrag(event, info);
        };
        const onSessionEnd = (event, info) => this.stop(event, info);
        const resumeAnimation = () => eachAxis((axis) => {
          var _a;
          return this.getAnimationState(axis) === "paused" && ((_a = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a.play());
        });
        const { dragSnapToOrigin } = this.getProps();
        this.panSession = new PanSession(originEvent, {
          onSessionStart,
          onStart,
          onMove,
          onSessionEnd,
          resumeAnimation
        }, {
          transformPagePoint: this.visualElement.getTransformPagePoint(),
          dragSnapToOrigin,
          contextWindow: getContextWindow(this.visualElement)
        });
      }
      stop(event, info) {
        const isDragging = this.isDragging;
        this.cancel();
        if (!isDragging)
          return;
        const { velocity } = info;
        this.startAnimation(velocity);
        const { onDragEnd } = this.getProps();
        if (onDragEnd) {
          motionDom.frame.postRender(() => onDragEnd(event, info));
        }
      }
      cancel() {
        this.isDragging = false;
        const { projection, animationState } = this.visualElement;
        if (projection) {
          projection.isAnimationBlocked = false;
        }
        this.panSession && this.panSession.end();
        this.panSession = void 0;
        const { dragPropagation } = this.getProps();
        if (!dragPropagation && this.openDragLock) {
          this.openDragLock();
          this.openDragLock = null;
        }
        animationState && animationState.setActive("whileDrag", false);
      }
      updateAxis(axis, _point, offset) {
        const { drag: drag2 } = this.getProps();
        if (!offset || !shouldDrag(axis, drag2, this.currentDirection))
          return;
        const axisValue = this.getAxisMotionValue(axis);
        let next = this.originPoint[axis] + offset[axis];
        if (this.constraints && this.constraints[axis]) {
          next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
        }
        axisValue.set(next);
      }
      resolveConstraints() {
        var _a;
        const { dragConstraints, dragElastic } = this.getProps();
        const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_a = this.visualElement.projection) == null ? void 0 : _a.layout;
        const prevConstraints = this.constraints;
        if (dragConstraints && isRefObject(dragConstraints)) {
          if (!this.constraints) {
            this.constraints = this.resolveRefConstraints();
          }
        } else {
          if (dragConstraints && layout2) {
            this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
          } else {
            this.constraints = false;
          }
        }
        this.elastic = resolveDragElastic(dragElastic);
        if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
          eachAxis((axis) => {
            if (this.constraints !== false && this.getAxisMotionValue(axis)) {
              this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
            }
          });
        }
      }
      resolveRefConstraints() {
        const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
        if (!constraints || !isRefObject(constraints))
          return false;
        const constraintsElement = constraints.current;
        motionUtils.invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
        const { projection } = this.visualElement;
        if (!projection || !projection.layout)
          return false;
        const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
        let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
        if (onMeasureDragConstraints) {
          const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
          this.hasMutatedConstraints = !!userConstraints;
          if (userConstraints) {
            measuredConstraints = convertBoundingBoxToBox(userConstraints);
          }
        }
        return measuredConstraints;
      }
      startAnimation(velocity) {
        const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
        const constraints = this.constraints || {};
        const momentumAnimations = eachAxis((axis) => {
          if (!shouldDrag(axis, drag2, this.currentDirection)) {
            return;
          }
          let transition = constraints && constraints[axis] || {};
          if (dragSnapToOrigin)
            transition = { min: 0, max: 0 };
          const bounceStiffness = dragElastic ? 200 : 1e6;
          const bounceDamping = dragElastic ? 40 : 1e7;
          const inertia = {
            type: "inertia",
            velocity: dragMomentum ? velocity[axis] : 0,
            bounceStiffness,
            bounceDamping,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...dragTransition,
            ...transition
          };
          return this.startAxisValueAnimation(axis, inertia);
        });
        return Promise.all(momentumAnimations).then(onDragTransitionEnd);
      }
      startAxisValueAnimation(axis, transition) {
        const axisValue = this.getAxisMotionValue(axis);
        addValueToWillChange(this.visualElement, axis);
        return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
      }
      stopAnimation() {
        eachAxis((axis) => this.getAxisMotionValue(axis).stop());
      }
      pauseAnimation() {
        eachAxis((axis) => {
          var _a;
          return (_a = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a.pause();
        });
      }
      getAnimationState(axis) {
        var _a;
        return (_a = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a.state;
      }
      /**
       * Drag works differently depending on which props are provided.
       *
       * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
       * - Otherwise, we apply the delta to the x/y motion values.
       */
      getAxisMotionValue(axis) {
        const dragKey = `_drag${axis.toUpperCase()}`;
        const props = this.visualElement.getProps();
        const externalMotionValue = props[dragKey];
        return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
      }
      snapToCursor(point) {
        eachAxis((axis) => {
          const { drag: drag2 } = this.getProps();
          if (!shouldDrag(axis, drag2, this.currentDirection))
            return;
          const { projection } = this.visualElement;
          const axisValue = this.getAxisMotionValue(axis);
          if (projection && projection.layout) {
            const { min, max } = projection.layout.layoutBox[axis];
            axisValue.set(point[axis] - motionDom.mixNumber(min, max, 0.5));
          }
        });
      }
      /**
       * When the viewport resizes we want to check if the measured constraints
       * have changed and, if so, reposition the element within those new constraints
       * relative to where it was before the resize.
       */
      scalePositionWithinConstraints() {
        if (!this.visualElement.current)
          return;
        const { drag: drag2, dragConstraints } = this.getProps();
        const { projection } = this.visualElement;
        if (!isRefObject(dragConstraints) || !projection || !this.constraints)
          return;
        this.stopAnimation();
        const boxProgress = { x: 0, y: 0 };
        eachAxis((axis) => {
          const axisValue = this.getAxisMotionValue(axis);
          if (axisValue && this.constraints !== false) {
            const latest = axisValue.get();
            boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
          }
        });
        const { transformTemplate } = this.visualElement.getProps();
        this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
        projection.root && projection.root.updateScroll();
        projection.updateLayout();
        this.resolveConstraints();
        eachAxis((axis) => {
          if (!shouldDrag(axis, drag2, null))
            return;
          const axisValue = this.getAxisMotionValue(axis);
          const { min, max } = this.constraints[axis];
          axisValue.set(motionDom.mixNumber(min, max, boxProgress[axis]));
        });
      }
      addListeners() {
        if (!this.visualElement.current)
          return;
        elementDragControls.set(this.visualElement, this);
        const element = this.visualElement.current;
        const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
          const { drag: drag2, dragListener = true } = this.getProps();
          drag2 && dragListener && this.start(event);
        });
        const measureDragConstraints = () => {
          const { dragConstraints } = this.getProps();
          if (isRefObject(dragConstraints) && dragConstraints.current) {
            this.constraints = this.resolveRefConstraints();
          }
        };
        const { projection } = this.visualElement;
        const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
        if (projection && !projection.layout) {
          projection.root && projection.root.updateScroll();
          projection.updateLayout();
        }
        motionDom.frame.read(measureDragConstraints);
        const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
        const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
          if (this.isDragging && hasLayoutChanged) {
            eachAxis((axis) => {
              const motionValue = this.getAxisMotionValue(axis);
              if (!motionValue)
                return;
              this.originPoint[axis] += delta[axis].translate;
              motionValue.set(motionValue.get() + delta[axis].translate);
            });
            this.visualElement.render();
          }
        });
        return () => {
          stopResizeListener();
          stopPointerListener();
          stopMeasureLayoutListener();
          stopLayoutUpdateListener && stopLayoutUpdateListener();
        };
      }
      getProps() {
        const props = this.visualElement.getProps();
        const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
        return {
          ...props,
          drag: drag2,
          dragDirectionLock,
          dragPropagation,
          dragConstraints,
          dragElastic,
          dragMomentum
        };
      }
    };
    function shouldDrag(direction, drag2, currentDirection) {
      return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
    }
    function getCurrentDirection(offset, lockThreshold = 10) {
      let direction = null;
      if (Math.abs(offset.y) > lockThreshold) {
        direction = "y";
      } else if (Math.abs(offset.x) > lockThreshold) {
        direction = "x";
      }
      return direction;
    }
    var DragGesture = class extends Feature {
      constructor(node) {
        super(node);
        this.removeGroupControls = motionUtils.noop;
        this.removeListeners = motionUtils.noop;
        this.controls = new VisualElementDragControls(node);
      }
      mount() {
        const { dragControls } = this.node.getProps();
        if (dragControls) {
          this.removeGroupControls = dragControls.subscribe(this.controls);
        }
        this.removeListeners = this.controls.addListeners() || motionUtils.noop;
      }
      unmount() {
        this.removeGroupControls();
        this.removeListeners();
      }
    };
    var asyncHandler = (handler) => (event, info) => {
      if (handler) {
        motionDom.frame.postRender(() => handler(event, info));
      }
    };
    var PanGesture = class extends Feature {
      constructor() {
        super(...arguments);
        this.removePointerDownListener = motionUtils.noop;
      }
      onPointerDown(pointerDownEvent) {
        this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
          transformPagePoint: this.node.getTransformPagePoint(),
          contextWindow: getContextWindow(this.node)
        });
      }
      createPanHandlers() {
        const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
        return {
          onSessionStart: asyncHandler(onPanSessionStart),
          onStart: asyncHandler(onPanStart),
          onMove: onPan,
          onEnd: (event, info) => {
            delete this.session;
            if (onPanEnd) {
              motionDom.frame.postRender(() => onPanEnd(event, info));
            }
          }
        };
      }
      mount() {
        this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
      }
      update() {
        this.session && this.session.updateHandlers(this.createPanHandlers());
      }
      unmount() {
        this.removePointerDownListener();
        this.session && this.session.end();
      }
    };
    var SwitchLayoutGroupContext = React.createContext({});
    var MeasureLayoutWithContext = class extends React.Component {
      /**
       * This only mounts projection nodes for components that
       * need measuring, we might want to do it for all components
       * in order to incorporate transforms
       */
      componentDidMount() {
        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
        const { projection } = visualElement;
        addScaleCorrector(defaultScaleCorrectors);
        if (projection) {
          if (layoutGroup.group)
            layoutGroup.group.add(projection);
          if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
            switchLayoutGroup.register(projection);
          }
          projection.root.didUpdate();
          projection.addEventListener("animationComplete", () => {
            this.safeToRemove();
          });
          projection.setOptions({
            ...projection.options,
            onExitComplete: () => this.safeToRemove()
          });
        }
        globalProjectionState.hasEverUpdated = true;
      }
      getSnapshotBeforeUpdate(prevProps) {
        const { layoutDependency, visualElement, drag: drag2, isPresent: isPresent2 } = this.props;
        const projection = visualElement.projection;
        if (!projection)
          return null;
        projection.isPresent = isPresent2;
        if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 || prevProps.isPresent !== isPresent2) {
          projection.willUpdate();
        } else {
          this.safeToRemove();
        }
        if (prevProps.isPresent !== isPresent2) {
          if (isPresent2) {
            projection.promote();
          } else if (!projection.relegate()) {
            motionDom.frame.postRender(() => {
              const stack = projection.getStack();
              if (!stack || !stack.members.length) {
                this.safeToRemove();
              }
            });
          }
        }
        return null;
      }
      componentDidUpdate() {
        const { projection } = this.props.visualElement;
        if (projection) {
          projection.root.didUpdate();
          motionDom.microtask.postRender(() => {
            if (!projection.currentAnimation && projection.isLead()) {
              this.safeToRemove();
            }
          });
        }
      }
      componentWillUnmount() {
        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
        const { projection } = visualElement;
        if (projection) {
          projection.scheduleCheckAfterUnmount();
          if (layoutGroup && layoutGroup.group)
            layoutGroup.group.remove(projection);
          if (promoteContext && promoteContext.deregister)
            promoteContext.deregister(projection);
        }
      }
      safeToRemove() {
        const { safeToRemove } = this.props;
        safeToRemove && safeToRemove();
      }
      render() {
        return null;
      }
    };
    function MeasureLayout(props) {
      const [isPresent2, safeToRemove] = usePresence();
      const layoutGroup = React.useContext(LayoutGroupContext);
      return jsxRuntime.jsx(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: React.useContext(SwitchLayoutGroupContext), isPresent: isPresent2, safeToRemove });
    }
    var defaultScaleCorrectors = {
      borderRadius: {
        ...correctBorderRadius,
        applyTo: [
          "borderTopLeftRadius",
          "borderTopRightRadius",
          "borderBottomLeftRadius",
          "borderBottomRightRadius"
        ]
      },
      borderTopLeftRadius: correctBorderRadius,
      borderTopRightRadius: correctBorderRadius,
      borderBottomLeftRadius: correctBorderRadius,
      borderBottomRightRadius: correctBorderRadius,
      boxShadow: correctBoxShadow
    };
    var drag = {
      pan: {
        Feature: PanGesture
      },
      drag: {
        Feature: DragGesture,
        ProjectionNode: HTMLProjectionNode,
        MeasureLayout
      }
    };
    function handleHoverEvent(node, event, lifecycle) {
      const { props } = node;
      if (node.animationState && props.whileHover) {
        node.animationState.setActive("whileHover", lifecycle === "Start");
      }
      const eventName = "onHover" + lifecycle;
      const callback = props[eventName];
      if (callback) {
        motionDom.frame.postRender(() => callback(event, extractEventInfo(event)));
      }
    }
    var HoverGesture = class extends Feature {
      mount() {
        const { current } = this.node;
        if (!current)
          return;
        this.unmount = motionDom.hover(current, (_element, startEvent) => {
          handleHoverEvent(this.node, startEvent, "Start");
          return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
        });
      }
      unmount() {
      }
    };
    var FocusGesture = class extends Feature {
      constructor() {
        super(...arguments);
        this.isActive = false;
      }
      onFocus() {
        let isFocusVisible = false;
        try {
          isFocusVisible = this.node.current.matches(":focus-visible");
        } catch (e) {
          isFocusVisible = true;
        }
        if (!isFocusVisible || !this.node.animationState)
          return;
        this.node.animationState.setActive("whileFocus", true);
        this.isActive = true;
      }
      onBlur() {
        if (!this.isActive || !this.node.animationState)
          return;
        this.node.animationState.setActive("whileFocus", false);
        this.isActive = false;
      }
      mount() {
        this.unmount = motionUtils.pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
      }
      unmount() {
      }
    };
    function handlePressEvent(node, event, lifecycle) {
      const { props } = node;
      if (node.current instanceof HTMLButtonElement && node.current.disabled) {
        return;
      }
      if (node.animationState && props.whileTap) {
        node.animationState.setActive("whileTap", lifecycle === "Start");
      }
      const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
      const callback = props[eventName];
      if (callback) {
        motionDom.frame.postRender(() => callback(event, extractEventInfo(event)));
      }
    }
    var PressGesture = class extends Feature {
      mount() {
        const { current } = this.node;
        if (!current)
          return;
        this.unmount = motionDom.press(current, (_element, startEvent) => {
          handlePressEvent(this.node, startEvent, "Start");
          return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
        }, { useGlobalTarget: this.node.props.globalTapTarget });
      }
      unmount() {
      }
    };
    var observerCallbacks = /* @__PURE__ */ new WeakMap();
    var observers = /* @__PURE__ */ new WeakMap();
    var fireObserverCallback = (entry) => {
      const callback = observerCallbacks.get(entry.target);
      callback && callback(entry);
    };
    var fireAllObserverCallbacks = (entries) => {
      entries.forEach(fireObserverCallback);
    };
    function initIntersectionObserver({ root, ...options }) {
      const lookupRoot = root || document;
      if (!observers.has(lookupRoot)) {
        observers.set(lookupRoot, {});
      }
      const rootObservers = observers.get(lookupRoot);
      const key = JSON.stringify(options);
      if (!rootObservers[key]) {
        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });
      }
      return rootObservers[key];
    }
    function observeIntersection(element, options, callback) {
      const rootInteresectionObserver = initIntersectionObserver(options);
      observerCallbacks.set(element, callback);
      rootInteresectionObserver.observe(element);
      return () => {
        observerCallbacks.delete(element);
        rootInteresectionObserver.unobserve(element);
      };
    }
    var thresholdNames = {
      some: 0,
      all: 1
    };
    var InViewFeature = class extends Feature {
      constructor() {
        super(...arguments);
        this.hasEnteredView = false;
        this.isInView = false;
      }
      startObserver() {
        this.unmount();
        const { viewport = {} } = this.node.getProps();
        const { root, margin: rootMargin, amount = "some", once } = viewport;
        const options = {
          root: root ? root.current : void 0,
          rootMargin,
          threshold: typeof amount === "number" ? amount : thresholdNames[amount]
        };
        const onIntersectionUpdate = (entry) => {
          const { isIntersecting } = entry;
          if (this.isInView === isIntersecting)
            return;
          this.isInView = isIntersecting;
          if (once && !isIntersecting && this.hasEnteredView) {
            return;
          } else if (isIntersecting) {
            this.hasEnteredView = true;
          }
          if (this.node.animationState) {
            this.node.animationState.setActive("whileInView", isIntersecting);
          }
          const { onViewportEnter, onViewportLeave } = this.node.getProps();
          const callback = isIntersecting ? onViewportEnter : onViewportLeave;
          callback && callback(entry);
        };
        return observeIntersection(this.node.current, options, onIntersectionUpdate);
      }
      mount() {
        this.startObserver();
      }
      update() {
        if (typeof IntersectionObserver === "undefined")
          return;
        const { props, prevProps } = this.node;
        const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
        if (hasOptionsChanged) {
          this.startObserver();
        }
      }
      unmount() {
      }
    };
    function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
      return (name) => viewport[name] !== prevViewport[name];
    }
    var gestureAnimations = {
      inView: {
        Feature: InViewFeature
      },
      tap: {
        Feature: PressGesture
      },
      focus: {
        Feature: FocusGesture
      },
      hover: {
        Feature: HoverGesture
      }
    };
    var layout = {
      layout: {
        ProjectionNode: HTMLProjectionNode,
        MeasureLayout
      }
    };
    var MotionContext = React.createContext({});
    function getCurrentTreeVariants(props, context) {
      if (isControllingVariants(props)) {
        const { initial, animate } = props;
        return {
          initial: initial === false || isVariantLabel(initial) ? initial : void 0,
          animate: isVariantLabel(animate) ? animate : void 0
        };
      }
      return props.inherit !== false ? context : {};
    }
    function useCreateMotionContext(props) {
      const { initial, animate } = getCurrentTreeVariants(props, React.useContext(MotionContext));
      return React.useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
    }
    function variantLabelsAsDependency(prop) {
      return Array.isArray(prop) ? prop.join(" ") : prop;
    }
    var motionComponentSymbol = Symbol.for("motionComponentSymbol");
    function useMotionRef(visualState, visualElement, externalRef) {
      return React.useCallback(
        (instance) => {
          if (instance) {
            visualState.onMount && visualState.onMount(instance);
          }
          if (visualElement) {
            if (instance) {
              visualElement.mount(instance);
            } else {
              visualElement.unmount();
            }
          }
          if (externalRef) {
            if (typeof externalRef === "function") {
              externalRef(instance);
            } else if (isRefObject(externalRef)) {
              externalRef.current = instance;
            }
          }
        },
        /**
         * Only pass a new ref callback to React if we've received a visual element
         * factory. Otherwise we'll be mounting/remounting every time externalRef
         * or other dependencies change.
         */
        [visualElement]
      );
    }
    function useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {
      var _a, _b;
      const { visualElement: parent } = React.useContext(MotionContext);
      const lazyContext = React.useContext(LazyContext);
      const presenceContext = React.useContext(PresenceContext);
      const reducedMotionConfig = React.useContext(MotionConfigContext).reducedMotion;
      const visualElementRef = React.useRef(null);
      createVisualElement = createVisualElement || lazyContext.renderer;
      if (!visualElementRef.current && createVisualElement) {
        visualElementRef.current = createVisualElement(Component, {
          visualState,
          parent,
          props,
          presenceContext,
          blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
          reducedMotionConfig
        });
      }
      const visualElement = visualElementRef.current;
      const initialLayoutGroupConfig = React.useContext(SwitchLayoutGroupContext);
      if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
        createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
      }
      const isMounted = React.useRef(false);
      React.useInsertionEffect(() => {
        if (visualElement && isMounted.current) {
          visualElement.update(props, presenceContext);
        }
      });
      const optimisedAppearId = props[optimizedAppearDataAttribute];
      const wantsHandoff = React.useRef(Boolean(optimisedAppearId) && !((_a = window.MotionHandoffIsComplete) == null ? void 0 : _a.call(window, optimisedAppearId)) && ((_b = window.MotionHasOptimisedAnimation) == null ? void 0 : _b.call(window, optimisedAppearId)));
      useIsomorphicLayoutEffect(() => {
        if (!visualElement)
          return;
        isMounted.current = true;
        window.MotionIsMounted = true;
        visualElement.updateFeatures();
        motionDom.microtask.render(visualElement.render);
        if (wantsHandoff.current && visualElement.animationState) {
          visualElement.animationState.animateChanges();
        }
      });
      React.useEffect(() => {
        if (!visualElement)
          return;
        if (!wantsHandoff.current && visualElement.animationState) {
          visualElement.animationState.animateChanges();
        }
        if (wantsHandoff.current) {
          queueMicrotask(() => {
            var _a2;
            (_a2 = window.MotionHandoffMarkAsComplete) == null ? void 0 : _a2.call(window, optimisedAppearId);
          });
          wantsHandoff.current = false;
        }
      });
      return visualElement;
    }
    function createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
      const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade } = props;
      visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
      visualElement.projection.setOptions({
        layoutId,
        layout: layout2,
        alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
        visualElement,
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof layout2 === "string" ? layout2 : "both",
        initialPromotionConfig,
        crossfade: layoutCrossfade,
        layoutScroll,
        layoutRoot
      });
    }
    function getClosestProjectingNode(visualElement) {
      if (!visualElement)
        return void 0;
      return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
    }
    function createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component }) {
      preloadedFeatures && loadFeatures(preloadedFeatures);
      function MotionComponent(props, externalRef) {
        let MeasureLayout2;
        const configAndProps = {
          ...React.useContext(MotionConfigContext),
          ...props,
          layoutId: useLayoutId(props)
        };
        const { isStatic } = configAndProps;
        const context = useCreateMotionContext(props);
        const visualState = useVisualState(props, isStatic);
        if (!isStatic && isBrowser) {
          useStrictMode(configAndProps, preloadedFeatures);
          const layoutProjection = getProjectionFunctionality(configAndProps);
          MeasureLayout2 = layoutProjection.MeasureLayout;
          context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
        }
        return jsxRuntime.jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout2 && context.visualElement ? jsxRuntime.jsx(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] });
      }
      MotionComponent.displayName = `motion.${typeof Component === "string" ? Component : `create(${Component.displayName ?? Component.name ?? ""})`}`;
      const ForwardRefMotionComponent = React.forwardRef(MotionComponent);
      ForwardRefMotionComponent[motionComponentSymbol] = Component;
      return ForwardRefMotionComponent;
    }
    function useLayoutId({ layoutId }) {
      const layoutGroupId = React.useContext(LayoutGroupContext).id;
      return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
    }
    function useStrictMode(configAndProps, preloadedFeatures) {
      const isStrict = React.useContext(LazyContext).strict;
      if (preloadedFeatures && isStrict) {
        const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
        configAndProps.ignoreStrict ? motionUtils.warning(false, strictMessage) : motionUtils.invariant(false, strictMessage);
      }
    }
    function getProjectionFunctionality(props) {
      const { drag: drag2, layout: layout2 } = featureDefinitions;
      if (!drag2 && !layout2)
        return {};
      const combined = { ...drag2, ...layout2 };
      return {
        MeasureLayout: (drag2 == null ? void 0 : drag2.isEnabled(props)) || (layout2 == null ? void 0 : layout2.isEnabled(props)) ? combined.MeasureLayout : void 0,
        ProjectionNode: combined.ProjectionNode
      };
    }
    var createHtmlRenderState = () => ({
      style: {},
      transform: {},
      transformOrigin: {},
      vars: {}
    });
    function copyRawValuesOnly(target, source, props) {
      for (const key in source) {
        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
          target[key] = source[key];
        }
      }
    }
    function useInitialMotionValues({ transformTemplate }, visualState) {
      return React.useMemo(() => {
        const state = createHtmlRenderState();
        buildHTMLStyles(state, visualState, transformTemplate);
        return Object.assign({}, state.vars, state.style);
      }, [visualState]);
    }
    function useStyle(props, visualState) {
      const styleProp = props.style || {};
      const style = {};
      copyRawValuesOnly(style, styleProp, props);
      Object.assign(style, useInitialMotionValues(props, visualState));
      return style;
    }
    function useHTMLProps(props, visualState) {
      const htmlProps = {};
      const style = useStyle(props, visualState);
      if (props.drag && props.dragListener !== false) {
        htmlProps.draggable = false;
        style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
        style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
      }
      if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
        htmlProps.tabIndex = 0;
      }
      htmlProps.style = style;
      return htmlProps;
    }
    var lowercaseSVGElements = [
      "animate",
      "circle",
      "defs",
      "desc",
      "ellipse",
      "g",
      "image",
      "line",
      "filter",
      "marker",
      "mask",
      "metadata",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "rect",
      "stop",
      "switch",
      "symbol",
      "svg",
      "text",
      "tspan",
      "use",
      "view"
    ];
    function isSVGComponent(Component) {
      if (
        /**
         * If it's not a string, it's a custom React component. Currently we only support
         * HTML custom React components.
         */
        typeof Component !== "string" || /**
         * If it contains a dash, the element is a custom HTML webcomponent.
         */
        Component.includes("-")
      ) {
        return false;
      } else if (
        /**
         * If it's in our list of lowercase SVG tags, it's an SVG component
         */
        lowercaseSVGElements.indexOf(Component) > -1 || /**
         * If it contains a capital letter, it's an SVG component
         */
        /[A-Z]/u.test(Component)
      ) {
        return true;
      }
      return false;
    }
    var dashKeys = {
      offset: "stroke-dashoffset",
      array: "stroke-dasharray"
    };
    var camelKeys = {
      offset: "strokeDashoffset",
      array: "strokeDasharray"
    };
    function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
      attrs.pathLength = 1;
      const keys = useDashCase ? dashKeys : camelKeys;
      attrs[keys.offset] = motionDom.px.transform(-offset);
      const pathLength = motionDom.px.transform(length);
      const pathSpacing = motionDom.px.transform(spacing);
      attrs[keys.array] = `${pathLength} ${pathSpacing}`;
    }
    function buildSVGAttrs(state, {
      attrX,
      attrY,
      attrScale,
      pathLength,
      pathSpacing = 1,
      pathOffset = 0,
      // This is object creation, which we try to avoid per-frame.
      ...latest
    }, isSVGTag2, transformTemplate) {
      buildHTMLStyles(state, latest, transformTemplate);
      if (isSVGTag2) {
        if (state.style.viewBox) {
          state.attrs.viewBox = state.style.viewBox;
        }
        return;
      }
      state.attrs = state.style;
      state.style = {};
      const { attrs, style } = state;
      if (attrs.transform) {
        style.transform = attrs.transform;
        delete attrs.transform;
      }
      if (style.transform || attrs.transformOrigin) {
        style.transformOrigin = attrs.transformOrigin ?? "50% 50%";
        delete attrs.transformOrigin;
      }
      if (style.transform) {
        style.transformBox = "fill-box";
        delete attrs.transformBox;
      }
      if (attrX !== void 0)
        attrs.x = attrX;
      if (attrY !== void 0)
        attrs.y = attrY;
      if (attrScale !== void 0)
        attrs.scale = attrScale;
      if (pathLength !== void 0) {
        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
      }
    }
    var createSvgRenderState = () => ({
      ...createHtmlRenderState(),
      attrs: {}
    });
    var isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
    function useSVGProps(props, visualState, _isStatic, Component) {
      const visualProps = React.useMemo(() => {
        const state = createSvgRenderState();
        buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate);
        return {
          ...state.attrs,
          style: { ...state.style }
        };
      }, [visualState]);
      if (props.style) {
        const rawStyles = {};
        copyRawValuesOnly(rawStyles, props.style, props);
        visualProps.style = { ...rawStyles, ...visualProps.style };
      }
      return visualProps;
    }
    function createUseRender(forwardMotionProps = false) {
      const useRender = (Component, props, ref, { latestValues }, isStatic) => {
        const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
        const visualProps = useVisualProps(props, latestValues, isStatic, Component);
        const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
        const elementProps = Component !== React.Fragment ? { ...filteredProps, ...visualProps, ref } : {};
        const { children } = props;
        const renderedChildren = React.useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
        return React.createElement(Component, {
          ...elementProps,
          children: renderedChildren
        });
      };
      return useRender;
    }
    function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState }, props, context, presenceContext) {
      const state = {
        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
        renderState: createRenderState()
      };
      return state;
    }
    var makeUseVisualState = (config) => (props, isStatic) => {
      const context = React.useContext(MotionContext);
      const presenceContext = React.useContext(PresenceContext);
      const make = () => makeState(config, props, context, presenceContext);
      return isStatic ? make() : useConstant(make);
    };
    function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
      const values = {};
      const motionValues = scrapeMotionValues(props, {});
      for (const key in motionValues) {
        values[key] = resolveMotionValue(motionValues[key]);
      }
      let { initial, animate } = props;
      const isControllingVariants$1 = isControllingVariants(props);
      const isVariantNode$1 = isVariantNode(props);
      if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
        if (initial === void 0)
          initial = context.initial;
        if (animate === void 0)
          animate = context.animate;
      }
      let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
      isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
      const variantToSet = isInitialAnimationBlocked ? animate : initial;
      if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
        const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
        for (let i = 0; i < list.length; i++) {
          const resolved = resolveVariantFromProps(props, list[i]);
          if (resolved) {
            const { transitionEnd, transition, ...target } = resolved;
            for (const key in target) {
              let valueTarget = target[key];
              if (Array.isArray(valueTarget)) {
                const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
                valueTarget = valueTarget[index];
              }
              if (valueTarget !== null) {
                values[key] = valueTarget;
              }
            }
            for (const key in transitionEnd) {
              values[key] = transitionEnd[key];
            }
          }
        }
      }
      return values;
    }
    var htmlMotionConfig = {
      useVisualState: makeUseVisualState({
        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
        createRenderState: createHtmlRenderState
      })
    };
    function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
      for (const key in props) {
        if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
          const targetKey = motionDom.transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
          newValues[targetKey] = props[key];
        }
      }
      return newValues;
    }
    var svgMotionConfig = {
      useVisualState: makeUseVisualState({
        scrapeMotionValuesFromProps,
        createRenderState: createSvgRenderState
      })
    };
    function createMotionComponentFactory(preloadedFeatures, createVisualElement) {
      return function createMotionComponent2(Component, { forwardMotionProps } = { forwardMotionProps: false }) {
        const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
        const config = {
          ...baseConfig,
          preloadedFeatures,
          useRender: createUseRender(forwardMotionProps),
          createVisualElement,
          Component
        };
        return createRendererMotionComponent(config);
      };
    }
    var camelCaseAttributes = /* @__PURE__ */ new Set([
      "baseFrequency",
      "diffuseConstant",
      "kernelMatrix",
      "kernelUnitLength",
      "keySplines",
      "keyTimes",
      "limitingConeAngle",
      "markerHeight",
      "markerWidth",
      "numOctaves",
      "targetX",
      "targetY",
      "surfaceScale",
      "specularConstant",
      "specularExponent",
      "stdDeviation",
      "tableValues",
      "viewBox",
      "gradientTransform",
      "pathLength",
      "startOffset",
      "textLength",
      "lengthAdjust"
    ]);
    function renderSVG(element, renderState, _styleProp, projection) {
      renderHTML(element, renderState, void 0, projection);
      for (const key in renderState.attrs) {
        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
      }
    }
    var SVGVisualElement = class extends DOMVisualElement {
      constructor() {
        super(...arguments);
        this.type = "svg";
        this.isSVGTag = false;
        this.measureInstanceViewportBox = createBox;
      }
      getBaseTargetFromProps(props, key) {
        return props[key];
      }
      readValueFromInstance(instance, key) {
        if (motionDom.transformProps.has(key)) {
          const defaultType = motionDom.getDefaultValueType(key);
          return defaultType ? defaultType.default || 0 : 0;
        }
        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
        return instance.getAttribute(key);
      }
      scrapeMotionValuesFromProps(props, prevProps, visualElement) {
        return scrapeMotionValuesFromProps(props, prevProps, visualElement);
      }
      build(renderState, latestValues, props) {
        buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);
      }
      renderInstance(instance, renderState, styleProp, projection) {
        renderSVG(instance, renderState, styleProp, projection);
      }
      mount(instance) {
        this.isSVGTag = isSVGTag(instance.tagName);
        super.mount(instance);
      }
    };
    var createDomVisualElement = (Component, options) => {
      return isSVGComponent(Component) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
        allowProjection: Component !== React.Fragment
      });
    };
    var createMotionComponent = createMotionComponentFactory({
      ...animations,
      ...gestureAnimations,
      ...drag,
      ...layout
    }, createDomVisualElement);
    exports.FlatTree = FlatTree;
    exports.HTMLVisualElement = HTMLVisualElement;
    exports.LayoutGroupContext = LayoutGroupContext;
    exports.LazyContext = LazyContext;
    exports.MotionConfigContext = MotionConfigContext;
    exports.MotionContext = MotionContext;
    exports.PresenceContext = PresenceContext;
    exports.SVGVisualElement = SVGVisualElement;
    exports.SwitchLayoutGroupContext = SwitchLayoutGroupContext;
    exports.VisualElement = VisualElement;
    exports.addDomEvent = addDomEvent;
    exports.addPointerEvent = addPointerEvent;
    exports.addPointerInfo = addPointerInfo;
    exports.addScaleCorrector = addScaleCorrector;
    exports.animateSingleValue = animateSingleValue;
    exports.animateTarget = animateTarget;
    exports.animateVisualElement = animateVisualElement;
    exports.animations = animations;
    exports.buildTransform = buildTransform;
    exports.calcLength = calcLength;
    exports.camelToDash = camelToDash;
    exports.createBox = createBox;
    exports.createDomVisualElement = createDomVisualElement;
    exports.createMotionComponent = createMotionComponent;
    exports.createMotionComponentFactory = createMotionComponentFactory;
    exports.createRendererMotionComponent = createRendererMotionComponent;
    exports.delay = delay;
    exports.distance = distance;
    exports.distance2D = distance2D;
    exports.drag = drag;
    exports.filterProps = filterProps;
    exports.gestureAnimations = gestureAnimations;
    exports.getOptimisedAppearId = getOptimisedAppearId;
    exports.hasReducedMotionListener = hasReducedMotionListener;
    exports.initPrefersReducedMotion = initPrefersReducedMotion;
    exports.isBrowser = isBrowser;
    exports.isMotionValue = isMotionValue;
    exports.isSVGElement = isSVGElement;
    exports.isValidMotionProp = isValidMotionProp;
    exports.layout = layout;
    exports.loadExternalIsValidProp = loadExternalIsValidProp;
    exports.loadFeatures = loadFeatures;
    exports.makeUseVisualState = makeUseVisualState;
    exports.motionComponentSymbol = motionComponentSymbol;
    exports.optimizedAppearDataAttribute = optimizedAppearDataAttribute;
    exports.optimizedAppearDataId = optimizedAppearDataId;
    exports.prefersReducedMotion = prefersReducedMotion;
    exports.resolveMotionValue = resolveMotionValue;
    exports.rootProjectionNode = rootProjectionNode;
    exports.setTarget = setTarget;
    exports.useConstant = useConstant;
    exports.useIsPresent = useIsPresent;
    exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;
    exports.usePresence = usePresence;
    exports.visualElementStore = visualElementStore;
  }
});

// node_modules/framer-motion/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/framer-motion/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsxRuntime = require_jsx_runtime();
    var React = require_react();
    var create = require_create_C0aMAGDw();
    var motionDom = require_cjs2();
    var motionUtils = require_cjs();
    function _interopNamespaceDefault(e) {
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n.default = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespaceDefault(React);
    var PopChildMeasure = class extends React__namespace.Component {
      getSnapshotBeforeUpdate(prevProps) {
        const element = this.props.childRef.current;
        if (element && prevProps.isPresent && !this.props.isPresent) {
          const parent = element.offsetParent;
          const parentWidth = parent instanceof HTMLElement ? parent.offsetWidth || 0 : 0;
          const size = this.props.sizeRef.current;
          size.height = element.offsetHeight || 0;
          size.width = element.offsetWidth || 0;
          size.top = element.offsetTop;
          size.left = element.offsetLeft;
          size.right = parentWidth - size.width - size.left;
        }
        return null;
      }
      /**
       * Required with getSnapshotBeforeUpdate to stop React complaining.
       */
      componentDidUpdate() {
      }
      render() {
        return this.props.children;
      }
    };
    function PopChild({ children, isPresent, anchorX }) {
      const id2 = React.useId();
      const ref = React.useRef(null);
      const size = React.useRef({
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        right: 0
      });
      const { nonce } = React.useContext(create.MotionConfigContext);
      React.useInsertionEffect(() => {
        const { width, height, top, left, right } = size.current;
        if (isPresent || !ref.current || !width || !height)
          return;
        const x = anchorX === "left" ? `left: ${left}` : `right: ${right}`;
        ref.current.dataset.motionPopId = id2;
        const style = document.createElement("style");
        if (nonce)
          style.nonce = nonce;
        document.head.appendChild(style);
        if (style.sheet) {
          style.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            ${x}px !important;
            top: ${top}px !important;
          }
        `);
        }
        return () => {
          document.head.removeChild(style);
        };
      }, [isPresent]);
      return jsxRuntime.jsx(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size, children: React__namespace.cloneElement(children, { ref }) });
    }
    var PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX }) => {
      const presenceChildren = create.useConstant(newChildrenMap);
      const id2 = React.useId();
      let isReusedContext = true;
      let context = React.useMemo(() => {
        isReusedContext = false;
        return {
          id: id2,
          initial,
          isPresent,
          custom,
          onExitComplete: (childId) => {
            presenceChildren.set(childId, true);
            for (const isComplete of presenceChildren.values()) {
              if (!isComplete)
                return;
            }
            onExitComplete && onExitComplete();
          },
          register: (childId) => {
            presenceChildren.set(childId, false);
            return () => presenceChildren.delete(childId);
          }
        };
      }, [isPresent, presenceChildren, onExitComplete]);
      if (presenceAffectsLayout && isReusedContext) {
        context = { ...context };
      }
      React.useMemo(() => {
        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
      }, [isPresent]);
      React__namespace.useEffect(() => {
        !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
      }, [isPresent]);
      if (mode === "popLayout") {
        children = jsxRuntime.jsx(PopChild, { isPresent, anchorX, children });
      }
      return jsxRuntime.jsx(create.PresenceContext.Provider, { value: context, children });
    };
    function newChildrenMap() {
      return /* @__PURE__ */ new Map();
    }
    var getChildKey = (child) => child.key || "";
    function onlyElements(children) {
      const filtered = [];
      React.Children.forEach(children, (child) => {
        if (React.isValidElement(child))
          filtered.push(child);
      });
      return filtered;
    }
    var AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", propagate = false, anchorX = "left" }) => {
      const [isParentPresent, safeToRemove] = create.usePresence(propagate);
      const presentChildren = React.useMemo(() => onlyElements(children), [children]);
      const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
      const isInitialRender = React.useRef(true);
      const pendingPresentChildren = React.useRef(presentChildren);
      const exitComplete = create.useConstant(() => /* @__PURE__ */ new Map());
      const [diffedChildren, setDiffedChildren] = React.useState(presentChildren);
      const [renderedChildren, setRenderedChildren] = React.useState(presentChildren);
      create.useIsomorphicLayoutEffect(() => {
        isInitialRender.current = false;
        pendingPresentChildren.current = presentChildren;
        for (let i = 0; i < renderedChildren.length; i++) {
          const key = getChildKey(renderedChildren[i]);
          if (!presentKeys.includes(key)) {
            if (exitComplete.get(key) !== true) {
              exitComplete.set(key, false);
            }
          } else {
            exitComplete.delete(key);
          }
        }
      }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
      const exitingChildren = [];
      if (presentChildren !== diffedChildren) {
        let nextChildren = [...presentChildren];
        for (let i = 0; i < renderedChildren.length; i++) {
          const child = renderedChildren[i];
          const key = getChildKey(child);
          if (!presentKeys.includes(key)) {
            nextChildren.splice(i, 0, child);
            exitingChildren.push(child);
          }
        }
        if (mode === "wait" && exitingChildren.length) {
          nextChildren = exitingChildren;
        }
        setRenderedChildren(onlyElements(nextChildren));
        setDiffedChildren(presentChildren);
        return null;
      }
      if (mode === "wait" && renderedChildren.length > 1) {
        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
      }
      const { forceRender } = React.useContext(create.LayoutGroupContext);
      return jsxRuntime.jsx(jsxRuntime.Fragment, { children: renderedChildren.map((child) => {
        const key = getChildKey(child);
        const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key);
        const onExit = () => {
          if (exitComplete.has(key)) {
            exitComplete.set(key, true);
          } else {
            return;
          }
          let isEveryExitComplete = true;
          exitComplete.forEach((isExitComplete) => {
            if (!isExitComplete)
              isEveryExitComplete = false;
          });
          if (isEveryExitComplete) {
            forceRender == null ? void 0 : forceRender();
            setRenderedChildren(pendingPresentChildren.current);
            propagate && (safeToRemove == null ? void 0 : safeToRemove());
            onExitComplete && onExitComplete();
          }
        };
        return jsxRuntime.jsx(PresenceChild, { isPresent, initial: !isInitialRender.current || initial ? void 0 : false, custom, presenceAffectsLayout, mode, onExitComplete: isPresent ? void 0 : onExit, anchorX, children: child }, key);
      }) });
    };
    var DeprecatedLayoutGroupContext = React.createContext(null);
    var notify = (node) => !node.isLayoutDirty && node.willUpdate(false);
    function nodeGroup() {
      const nodes = /* @__PURE__ */ new Set();
      const subscriptions = /* @__PURE__ */ new WeakMap();
      const dirtyAll = () => nodes.forEach(notify);
      return {
        add: (node) => {
          nodes.add(node);
          subscriptions.set(node, node.addEventListener("willUpdate", dirtyAll));
        },
        remove: (node) => {
          nodes.delete(node);
          const unsubscribe = subscriptions.get(node);
          if (unsubscribe) {
            unsubscribe();
            subscriptions.delete(node);
          }
          dirtyAll();
        },
        dirty: dirtyAll
      };
    }
    function useIsMounted() {
      const isMounted = React.useRef(false);
      create.useIsomorphicLayoutEffect(() => {
        isMounted.current = true;
        return () => {
          isMounted.current = false;
        };
      }, []);
      return isMounted;
    }
    function useForceUpdate() {
      const isMounted = useIsMounted();
      const [forcedRenderCount, setForcedRenderCount] = React.useState(0);
      const forceRender = React.useCallback(() => {
        isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
      }, [forcedRenderCount]);
      const deferredForceRender = React.useCallback(() => motionDom.frame.postRender(forceRender), [forceRender]);
      return [deferredForceRender, forcedRenderCount];
    }
    var shouldInheritGroup = (inherit) => inherit === true;
    var shouldInheritId = (inherit) => shouldInheritGroup(inherit === true) || inherit === "id";
    var LayoutGroup = ({ children, id: id2, inherit = true }) => {
      const layoutGroupContext = React.useContext(create.LayoutGroupContext);
      const deprecatedLayoutGroupContext = React.useContext(DeprecatedLayoutGroupContext);
      const [forceRender, key] = useForceUpdate();
      const context = React.useRef(null);
      const upstreamId = layoutGroupContext.id || deprecatedLayoutGroupContext;
      if (context.current === null) {
        if (shouldInheritId(inherit) && upstreamId) {
          id2 = id2 ? upstreamId + "-" + id2 : upstreamId;
        }
        context.current = {
          id: id2,
          group: shouldInheritGroup(inherit) ? layoutGroupContext.group || nodeGroup() : nodeGroup()
        };
      }
      const memoizedContext = React.useMemo(() => ({ ...context.current, forceRender }), [key]);
      return jsxRuntime.jsx(create.LayoutGroupContext.Provider, { value: memoizedContext, children });
    };
    function LazyMotion({ children, features, strict = false }) {
      const [, setIsLoaded] = React.useState(!isLazyBundle(features));
      const loadedRenderer = React.useRef(void 0);
      if (!isLazyBundle(features)) {
        const { renderer, ...loadedFeatures } = features;
        loadedRenderer.current = renderer;
        create.loadFeatures(loadedFeatures);
      }
      React.useEffect(() => {
        if (isLazyBundle(features)) {
          features().then(({ renderer, ...loadedFeatures }) => {
            create.loadFeatures(loadedFeatures);
            loadedRenderer.current = renderer;
            setIsLoaded(true);
          });
        }
      }, []);
      return jsxRuntime.jsx(create.LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict }, children });
    }
    function isLazyBundle(features) {
      return typeof features === "function";
    }
    function MotionConfig({ children, isValidProp, ...config }) {
      isValidProp && create.loadExternalIsValidProp(isValidProp);
      config = { ...React.useContext(create.MotionConfigContext), ...config };
      config.isStatic = create.useConstant(() => config.isStatic);
      const context = React.useMemo(() => config, [
        JSON.stringify(config.transition),
        config.transformPagePoint,
        config.reducedMotion
      ]);
      return jsxRuntime.jsx(create.MotionConfigContext.Provider, { value: context, children });
    }
    var ReorderContext = React.createContext(null);
    function createDOMMotionComponentProxy(componentFactory) {
      if (typeof Proxy === "undefined") {
        return componentFactory;
      }
      const componentCache = /* @__PURE__ */ new Map();
      const deprecatedFactoryFunction = (...args) => {
        if (true) {
          motionUtils.warnOnce(false, "motion() is deprecated. Use motion.create() instead.");
        }
        return componentFactory(...args);
      };
      return new Proxy(deprecatedFactoryFunction, {
        /**
         * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
         * The prop name is passed through as `key` and we can use that to generate a `motion`
         * DOM component with that name.
         */
        get: (_target, key) => {
          if (key === "create")
            return componentFactory;
          if (!componentCache.has(key)) {
            componentCache.set(key, componentFactory(key));
          }
          return componentCache.get(key);
        }
      });
    }
    var motion = createDOMMotionComponentProxy(create.createMotionComponent);
    function checkReorder(order, value, offset, velocity) {
      if (!velocity)
        return order;
      const index = order.findIndex((item2) => item2.value === value);
      if (index === -1)
        return order;
      const nextOffset = velocity > 0 ? 1 : -1;
      const nextItem = order[index + nextOffset];
      if (!nextItem)
        return order;
      const item = order[index];
      const nextLayout = nextItem.layout;
      const nextItemCenter = motionDom.mixNumber(nextLayout.min, nextLayout.max, 0.5);
      if (nextOffset === 1 && item.layout.max + offset > nextItemCenter || nextOffset === -1 && item.layout.min + offset < nextItemCenter) {
        return motionUtils.moveItem(order, index, index + nextOffset);
      }
      return order;
    }
    function ReorderGroupComponent({ children, as = "ul", axis = "y", onReorder, values, ...props }, externalRef) {
      const Component = create.useConstant(() => motion[as]);
      const order = [];
      const isReordering = React.useRef(false);
      motionUtils.invariant(Boolean(values), "Reorder.Group must be provided a values prop");
      const context = {
        axis,
        registerItem: (value, layout) => {
          const idx = order.findIndex((entry) => value === entry.value);
          if (idx !== -1) {
            order[idx].layout = layout[axis];
          } else {
            order.push({ value, layout: layout[axis] });
          }
          order.sort(compareMin);
        },
        updateOrder: (item, offset, velocity) => {
          if (isReordering.current)
            return;
          const newOrder = checkReorder(order, item, offset, velocity);
          if (order !== newOrder) {
            isReordering.current = true;
            onReorder(newOrder.map(getValue).filter((value) => values.indexOf(value) !== -1));
          }
        }
      };
      React.useEffect(() => {
        isReordering.current = false;
      });
      return jsxRuntime.jsx(Component, { ...props, ref: externalRef, ignoreStrict: true, children: jsxRuntime.jsx(ReorderContext.Provider, { value: context, children }) });
    }
    var ReorderGroup = React.forwardRef(ReorderGroupComponent);
    function getValue(item) {
      return item.value;
    }
    function compareMin(a, b) {
      return a.layout.min - b.layout.min;
    }
    function useMotionValue(initial) {
      const value = create.useConstant(() => motionDom.motionValue(initial));
      const { isStatic } = React.useContext(create.MotionConfigContext);
      if (isStatic) {
        const [, setLatest] = React.useState(initial);
        React.useEffect(() => value.on("change", setLatest), []);
      }
      return value;
    }
    function useCombineMotionValues(values, combineValues) {
      const value = useMotionValue(combineValues());
      const updateValue = () => value.set(combineValues());
      updateValue();
      create.useIsomorphicLayoutEffect(() => {
        const scheduleUpdate = () => motionDom.frame.preRender(updateValue, false, true);
        const subscriptions = values.map((v) => v.on("change", scheduleUpdate));
        return () => {
          subscriptions.forEach((unsubscribe) => unsubscribe());
          motionDom.cancelFrame(updateValue);
        };
      });
      return value;
    }
    function useComputed(compute) {
      motionDom.collectMotionValues.current = [];
      compute();
      const value = useCombineMotionValues(motionDom.collectMotionValues.current, compute);
      motionDom.collectMotionValues.current = void 0;
      return value;
    }
    function useTransform(input, inputRangeOrTransformer, outputRange, options) {
      if (typeof input === "function") {
        return useComputed(input);
      }
      const transformer = typeof inputRangeOrTransformer === "function" ? inputRangeOrTransformer : motionDom.transform(inputRangeOrTransformer, outputRange, options);
      return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([input], ([latest]) => transformer(latest));
    }
    function useListTransform(values, transformer) {
      const latest = create.useConstant(() => []);
      return useCombineMotionValues(values, () => {
        latest.length = 0;
        const numValues = values.length;
        for (let i = 0; i < numValues; i++) {
          latest[i] = values[i].get();
        }
        return transformer(latest);
      });
    }
    function useDefaultMotionValue(value, defaultValue = 0) {
      return create.isMotionValue(value) ? value : useMotionValue(defaultValue);
    }
    function ReorderItemComponent({ children, style = {}, value, as = "li", onDrag, layout = true, ...props }, externalRef) {
      const Component = create.useConstant(() => motion[as]);
      const context = React.useContext(ReorderContext);
      const point2 = {
        x: useDefaultMotionValue(style.x),
        y: useDefaultMotionValue(style.y)
      };
      const zIndex = useTransform([point2.x, point2.y], ([latestX, latestY]) => latestX || latestY ? 1 : "unset");
      motionUtils.invariant(Boolean(context), "Reorder.Item must be a child of Reorder.Group");
      const { axis, registerItem, updateOrder } = context;
      return jsxRuntime.jsx(Component, { drag: axis, ...props, dragSnapToOrigin: true, style: { ...style, x: point2.x, y: point2.y, zIndex }, layout, onDrag: (event, gesturePoint) => {
        const { velocity } = gesturePoint;
        velocity[axis] && updateOrder(value, point2[axis].get(), velocity[axis]);
        onDrag && onDrag(event, gesturePoint);
      }, onLayoutMeasure: (measured) => registerItem(value, measured), ref: externalRef, ignoreStrict: true, children });
    }
    var ReorderItem = React.forwardRef(ReorderItemComponent);
    var namespace = Object.freeze({
      __proto__: null,
      Group: ReorderGroup,
      Item: ReorderItem
    });
    function isDOMKeyframes(keyframes) {
      return typeof keyframes === "object" && !Array.isArray(keyframes);
    }
    function resolveSubjects(subject, keyframes, scope, selectorCache) {
      if (typeof subject === "string" && isDOMKeyframes(keyframes)) {
        return motionDom.resolveElements(subject, scope, selectorCache);
      } else if (subject instanceof NodeList) {
        return Array.from(subject);
      } else if (Array.isArray(subject)) {
        return subject;
      } else {
        return [subject];
      }
    }
    function calculateRepeatDuration(duration, repeat, _repeatDelay) {
      return duration * (repeat + 1);
    }
    function calcNextTime(current, next, prev, labels) {
      if (typeof next === "number") {
        return next;
      } else if (next.startsWith("-") || next.startsWith("+")) {
        return Math.max(0, current + parseFloat(next));
      } else if (next === "<") {
        return prev;
      } else {
        return labels.get(next) ?? current;
      }
    }
    function eraseKeyframes(sequence, startTime, endTime) {
      for (let i = 0; i < sequence.length; i++) {
        const keyframe = sequence[i];
        if (keyframe.at > startTime && keyframe.at < endTime) {
          motionUtils.removeItem(sequence, keyframe);
          i--;
        }
      }
    }
    function addKeyframes(sequence, keyframes, easing, offset, startTime, endTime) {
      eraseKeyframes(sequence, startTime, endTime);
      for (let i = 0; i < keyframes.length; i++) {
        sequence.push({
          value: keyframes[i],
          at: motionDom.mixNumber(startTime, endTime, offset[i]),
          easing: motionUtils.getEasingForSegment(easing, i)
        });
      }
    }
    function normalizeTimes(times, repeat) {
      for (let i = 0; i < times.length; i++) {
        times[i] = times[i] / (repeat + 1);
      }
    }
    function compareByTime(a, b) {
      if (a.at === b.at) {
        if (a.value === null)
          return 1;
        if (b.value === null)
          return -1;
        return 0;
      } else {
        return a.at - b.at;
      }
    }
    var defaultSegmentEasing = "easeInOut";
    var MAX_REPEAT = 20;
    function createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators) {
      const defaultDuration = defaultTransition.duration || 0.3;
      const animationDefinitions = /* @__PURE__ */ new Map();
      const sequences = /* @__PURE__ */ new Map();
      const elementCache = {};
      const timeLabels = /* @__PURE__ */ new Map();
      let prevTime = 0;
      let currentTime = 0;
      let totalDuration = 0;
      for (let i = 0; i < sequence.length; i++) {
        const segment = sequence[i];
        if (typeof segment === "string") {
          timeLabels.set(segment, currentTime);
          continue;
        } else if (!Array.isArray(segment)) {
          timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));
          continue;
        }
        let [subject, keyframes, transition = {}] = segment;
        if (transition.at !== void 0) {
          currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);
        }
        let maxDuration = 0;
        const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {
          const valueKeyframesAsList = keyframesAsList(valueKeyframes);
          const { delay = 0, times = motionDom.defaultOffset(valueKeyframesAsList), type = "keyframes", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;
          let { ease = defaultTransition.ease || "easeOut", duration } = valueTransition;
          const calculatedDelay = typeof delay === "function" ? delay(elementIndex, numSubjects) : delay;
          const numKeyframes = valueKeyframesAsList.length;
          const createGenerator = motionDom.isGenerator(type) ? type : generators == null ? void 0 : generators[type];
          if (numKeyframes <= 2 && createGenerator) {
            let absoluteDelta = 100;
            if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {
              const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];
              absoluteDelta = Math.abs(delta);
            }
            const springTransition = { ...remainingTransition };
            if (duration !== void 0) {
              springTransition.duration = motionUtils.secondsToMilliseconds(duration);
            }
            const springEasing = motionDom.createGeneratorEasing(springTransition, absoluteDelta, createGenerator);
            ease = springEasing.ease;
            duration = springEasing.duration;
          }
          duration ?? (duration = defaultDuration);
          const startTime = currentTime + calculatedDelay;
          if (times.length === 1 && times[0] === 0) {
            times[1] = 1;
          }
          const remainder = times.length - valueKeyframesAsList.length;
          remainder > 0 && motionDom.fillOffset(times, remainder);
          valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);
          if (repeat) {
            motionUtils.invariant(repeat < MAX_REPEAT, "Repeat count too high, must be less than 20");
            duration = calculateRepeatDuration(duration, repeat);
            const originalKeyframes = [...valueKeyframesAsList];
            const originalTimes = [...times];
            ease = Array.isArray(ease) ? [...ease] : [ease];
            const originalEase = [...ease];
            for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {
              valueKeyframesAsList.push(...originalKeyframes);
              for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {
                times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));
                ease.push(keyframeIndex === 0 ? "linear" : motionUtils.getEasingForSegment(originalEase, keyframeIndex - 1));
              }
            }
            normalizeTimes(times, repeat);
          }
          const targetTime = startTime + duration;
          addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);
          maxDuration = Math.max(calculatedDelay + duration, maxDuration);
          totalDuration = Math.max(targetTime, totalDuration);
        };
        if (create.isMotionValue(subject)) {
          const subjectSequence = getSubjectSequence(subject, sequences);
          resolveValueSequence(keyframes, transition, getValueSequence("default", subjectSequence));
        } else {
          const subjects = resolveSubjects(subject, keyframes, scope, elementCache);
          const numSubjects = subjects.length;
          for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {
            keyframes = keyframes;
            transition = transition;
            const thisSubject = subjects[subjectIndex];
            const subjectSequence = getSubjectSequence(thisSubject, sequences);
            for (const key in keyframes) {
              resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);
            }
          }
        }
        prevTime = currentTime;
        currentTime += maxDuration;
      }
      sequences.forEach((valueSequences, element) => {
        for (const key in valueSequences) {
          const valueSequence = valueSequences[key];
          valueSequence.sort(compareByTime);
          const keyframes = [];
          const valueOffset = [];
          const valueEasing = [];
          for (let i = 0; i < valueSequence.length; i++) {
            const { at, value, easing } = valueSequence[i];
            keyframes.push(value);
            valueOffset.push(motionUtils.progress(0, totalDuration, at));
            valueEasing.push(easing || "easeOut");
          }
          if (valueOffset[0] !== 0) {
            valueOffset.unshift(0);
            keyframes.unshift(keyframes[0]);
            valueEasing.unshift(defaultSegmentEasing);
          }
          if (valueOffset[valueOffset.length - 1] !== 1) {
            valueOffset.push(1);
            keyframes.push(null);
          }
          if (!animationDefinitions.has(element)) {
            animationDefinitions.set(element, {
              keyframes: {},
              transition: {}
            });
          }
          const definition = animationDefinitions.get(element);
          definition.keyframes[key] = keyframes;
          definition.transition[key] = {
            ...defaultTransition,
            duration: totalDuration,
            ease: valueEasing,
            times: valueOffset,
            ...sequenceTransition
          };
        }
      });
      return animationDefinitions;
    }
    function getSubjectSequence(subject, sequences) {
      !sequences.has(subject) && sequences.set(subject, {});
      return sequences.get(subject);
    }
    function getValueSequence(name, sequences) {
      if (!sequences[name])
        sequences[name] = [];
      return sequences[name];
    }
    function keyframesAsList(keyframes) {
      return Array.isArray(keyframes) ? keyframes : [keyframes];
    }
    function getValueTransition(transition, key) {
      return transition && transition[key] ? {
        ...transition,
        ...transition[key]
      } : { ...transition };
    }
    var isNumber = (keyframe) => typeof keyframe === "number";
    var isNumberKeyframesArray = (keyframes) => keyframes.every(isNumber);
    function isObjectKey(key, object) {
      return key in object;
    }
    var ObjectVisualElement = class extends create.VisualElement {
      constructor() {
        super(...arguments);
        this.type = "object";
      }
      readValueFromInstance(instance, key) {
        if (isObjectKey(key, instance)) {
          const value = instance[key];
          if (typeof value === "string" || typeof value === "number") {
            return value;
          }
        }
        return void 0;
      }
      getBaseTargetFromProps() {
        return void 0;
      }
      removeValueFromRenderState(key, renderState) {
        delete renderState.output[key];
      }
      measureInstanceViewportBox() {
        return create.createBox();
      }
      build(renderState, latestValues) {
        Object.assign(renderState.output, latestValues);
      }
      renderInstance(instance, { output }) {
        Object.assign(instance, output);
      }
      sortInstanceNodePosition() {
        return 0;
      }
    };
    function createDOMVisualElement(element) {
      const options = {
        presenceContext: null,
        props: {},
        visualState: {
          renderState: {
            transform: {},
            transformOrigin: {},
            style: {},
            vars: {},
            attrs: {}
          },
          latestValues: {}
        }
      };
      const node = create.isSVGElement(element) ? new create.SVGVisualElement(options) : new create.HTMLVisualElement(options);
      node.mount(element);
      create.visualElementStore.set(element, node);
    }
    function createObjectVisualElement(subject) {
      const options = {
        presenceContext: null,
        props: {},
        visualState: {
          renderState: {
            output: {}
          },
          latestValues: {}
        }
      };
      const node = new ObjectVisualElement(options);
      node.mount(subject);
      create.visualElementStore.set(subject, node);
    }
    function isSingleValue(subject, keyframes) {
      return create.isMotionValue(subject) || typeof subject === "number" || typeof subject === "string" && !isDOMKeyframes(keyframes);
    }
    function animateSubject(subject, keyframes, options, scope) {
      const animations = [];
      if (isSingleValue(subject, keyframes)) {
        animations.push(create.animateSingleValue(subject, isDOMKeyframes(keyframes) ? keyframes.default || keyframes : keyframes, options ? options.default || options : options));
      } else {
        const subjects = resolveSubjects(subject, keyframes, scope);
        const numSubjects = subjects.length;
        motionUtils.invariant(Boolean(numSubjects), "No valid elements provided.");
        for (let i = 0; i < numSubjects; i++) {
          const thisSubject = subjects[i];
          const createVisualElement = thisSubject instanceof Element ? createDOMVisualElement : createObjectVisualElement;
          if (!create.visualElementStore.has(thisSubject)) {
            createVisualElement(thisSubject);
          }
          const visualElement = create.visualElementStore.get(thisSubject);
          const transition = { ...options };
          if ("delay" in transition && typeof transition.delay === "function") {
            transition.delay = transition.delay(i, numSubjects);
          }
          animations.push(...create.animateTarget(visualElement, { ...keyframes, transition }, {}));
        }
      }
      return animations;
    }
    function animateSequence(sequence, options, scope) {
      const animations = [];
      const animationDefinitions = createAnimationsFromSequence(sequence, options, scope, { spring: motionDom.spring });
      animationDefinitions.forEach(({ keyframes, transition }, subject) => {
        animations.push(...animateSubject(subject, keyframes, transition));
      });
      return animations;
    }
    function isSequence(value) {
      return Array.isArray(value) && value.some(Array.isArray);
    }
    function createScopedAnimate(scope) {
      function scopedAnimate(subjectOrSequence, optionsOrKeyframes, options) {
        let animations = [];
        if (isSequence(subjectOrSequence)) {
          animations = animateSequence(subjectOrSequence, optionsOrKeyframes, scope);
        } else {
          animations = animateSubject(subjectOrSequence, optionsOrKeyframes, options, scope);
        }
        const animation = new motionDom.GroupAnimationWithThen(animations);
        if (scope) {
          scope.animations.push(animation);
        }
        return animation;
      }
      return scopedAnimate;
    }
    var animate = createScopedAnimate();
    function animateElements(elementOrSelector, keyframes, options, scope) {
      const elements = motionDom.resolveElements(elementOrSelector, scope);
      const numElements = elements.length;
      motionUtils.invariant(Boolean(numElements), "No valid element provided.");
      const animationDefinitions = [];
      for (let i = 0; i < numElements; i++) {
        const element = elements[i];
        const elementTransition = { ...options };
        if (typeof elementTransition.delay === "function") {
          elementTransition.delay = elementTransition.delay(i, numElements);
        }
        for (const valueName in keyframes) {
          let valueKeyframes = keyframes[valueName];
          if (!Array.isArray(valueKeyframes)) {
            valueKeyframes = [valueKeyframes];
          }
          const valueOptions = {
            ...motionDom.getValueTransition(elementTransition, valueName)
          };
          valueOptions.duration && (valueOptions.duration = motionUtils.secondsToMilliseconds(valueOptions.duration));
          valueOptions.delay && (valueOptions.delay = motionUtils.secondsToMilliseconds(valueOptions.delay));
          const map = motionDom.getAnimationMap(element);
          const key = motionDom.animationMapKey(valueName, valueOptions.pseudoElement || "");
          const currentAnimation = map.get(key);
          currentAnimation && currentAnimation.stop();
          animationDefinitions.push({
            map,
            key,
            unresolvedKeyframes: valueKeyframes,
            options: {
              ...valueOptions,
              element,
              name: valueName,
              allowFlatten: !elementTransition.type && !elementTransition.ease
            }
          });
        }
      }
      for (let i = 0; i < animationDefinitions.length; i++) {
        const { unresolvedKeyframes, options: animationOptions } = animationDefinitions[i];
        const { element, name, pseudoElement } = animationOptions;
        if (!pseudoElement && unresolvedKeyframes[0] === null) {
          unresolvedKeyframes[0] = motionDom.getComputedStyle(element, name);
        }
        motionDom.fillWildcards(unresolvedKeyframes);
        motionDom.applyPxDefaults(unresolvedKeyframes, name);
        if (!pseudoElement && unresolvedKeyframes.length < 2) {
          unresolvedKeyframes.unshift(motionDom.getComputedStyle(element, name));
        }
        animationOptions.keyframes = unresolvedKeyframes;
      }
      const animations = [];
      for (let i = 0; i < animationDefinitions.length; i++) {
        const { map, key, options: animationOptions } = animationDefinitions[i];
        const animation = new motionDom.NativeAnimation(animationOptions);
        map.set(key, animation);
        animation.finished.finally(() => map.delete(key));
        animations.push(animation);
      }
      return animations;
    }
    var createScopedWaapiAnimate = (scope) => {
      function scopedAnimate(elementOrSelector, keyframes, options) {
        return new motionDom.GroupAnimationWithThen(animateElements(elementOrSelector, keyframes, options, scope));
      }
      return scopedAnimate;
    };
    var animateMini = createScopedWaapiAnimate();
    var resizeHandlers = /* @__PURE__ */ new WeakMap();
    var observer;
    function getElementSize(target, borderBoxSize) {
      if (borderBoxSize) {
        const { inlineSize, blockSize } = borderBoxSize[0];
        return { width: inlineSize, height: blockSize };
      } else if (target instanceof SVGElement && "getBBox" in target) {
        return target.getBBox();
      } else {
        return {
          width: target.offsetWidth,
          height: target.offsetHeight
        };
      }
    }
    function notifyTarget({ target, contentRect, borderBoxSize }) {
      var _a;
      (_a = resizeHandlers.get(target)) == null ? void 0 : _a.forEach((handler) => {
        handler({
          target,
          contentSize: contentRect,
          get size() {
            return getElementSize(target, borderBoxSize);
          }
        });
      });
    }
    function notifyAll(entries) {
      entries.forEach(notifyTarget);
    }
    function createResizeObserver() {
      if (typeof ResizeObserver === "undefined")
        return;
      observer = new ResizeObserver(notifyAll);
    }
    function resizeElement(target, handler) {
      if (!observer)
        createResizeObserver();
      const elements = motionDom.resolveElements(target);
      elements.forEach((element) => {
        let elementHandlers = resizeHandlers.get(element);
        if (!elementHandlers) {
          elementHandlers = /* @__PURE__ */ new Set();
          resizeHandlers.set(element, elementHandlers);
        }
        elementHandlers.add(handler);
        observer == null ? void 0 : observer.observe(element);
      });
      return () => {
        elements.forEach((element) => {
          const elementHandlers = resizeHandlers.get(element);
          elementHandlers == null ? void 0 : elementHandlers.delete(handler);
          if (!(elementHandlers == null ? void 0 : elementHandlers.size)) {
            observer == null ? void 0 : observer.unobserve(element);
          }
        });
      };
    }
    var windowCallbacks = /* @__PURE__ */ new Set();
    var windowResizeHandler;
    function createWindowResizeHandler() {
      windowResizeHandler = () => {
        const size = {
          width: window.innerWidth,
          height: window.innerHeight
        };
        const info = {
          target: window,
          size,
          contentSize: size
        };
        windowCallbacks.forEach((callback) => callback(info));
      };
      window.addEventListener("resize", windowResizeHandler);
    }
    function resizeWindow(callback) {
      windowCallbacks.add(callback);
      if (!windowResizeHandler)
        createWindowResizeHandler();
      return () => {
        windowCallbacks.delete(callback);
        if (!windowCallbacks.size && windowResizeHandler) {
          windowResizeHandler = void 0;
        }
      };
    }
    function resize(a, b) {
      return typeof a === "function" ? resizeWindow(a) : resizeElement(a, b);
    }
    var maxElapsed = 50;
    var createAxisInfo = () => ({
      current: 0,
      offset: [],
      progress: 0,
      scrollLength: 0,
      targetOffset: 0,
      targetLength: 0,
      containerLength: 0,
      velocity: 0
    });
    var createScrollInfo = () => ({
      time: 0,
      x: createAxisInfo(),
      y: createAxisInfo()
    });
    var keys = {
      x: {
        length: "Width",
        position: "Left"
      },
      y: {
        length: "Height",
        position: "Top"
      }
    };
    function updateAxisInfo(element, axisName, info, time) {
      const axis = info[axisName];
      const { length, position } = keys[axisName];
      const prev = axis.current;
      const prevTime = info.time;
      axis.current = element[`scroll${position}`];
      axis.scrollLength = element[`scroll${length}`] - element[`client${length}`];
      axis.offset.length = 0;
      axis.offset[0] = 0;
      axis.offset[1] = axis.scrollLength;
      axis.progress = motionUtils.progress(0, axis.scrollLength, axis.current);
      const elapsed = time - prevTime;
      axis.velocity = elapsed > maxElapsed ? 0 : motionUtils.velocityPerSecond(axis.current - prev, elapsed);
    }
    function updateScrollInfo(element, info, time) {
      updateAxisInfo(element, "x", info, time);
      updateAxisInfo(element, "y", info, time);
      info.time = time;
    }
    function calcInset(element, container) {
      const inset = { x: 0, y: 0 };
      let current = element;
      while (current && current !== container) {
        if (current instanceof HTMLElement) {
          inset.x += current.offsetLeft;
          inset.y += current.offsetTop;
          current = current.offsetParent;
        } else if (current.tagName === "svg") {
          const svgBoundingBox = current.getBoundingClientRect();
          current = current.parentElement;
          const parentBoundingBox = current.getBoundingClientRect();
          inset.x += svgBoundingBox.left - parentBoundingBox.left;
          inset.y += svgBoundingBox.top - parentBoundingBox.top;
        } else if (current instanceof SVGGraphicsElement) {
          const { x, y } = current.getBBox();
          inset.x += x;
          inset.y += y;
          let svg = null;
          let parent = current.parentNode;
          while (!svg) {
            if (parent.tagName === "svg") {
              svg = parent;
            }
            parent = current.parentNode;
          }
          current = svg;
        } else {
          break;
        }
      }
      return inset;
    }
    var namedEdges = {
      start: 0,
      center: 0.5,
      end: 1
    };
    function resolveEdge(edge, length, inset = 0) {
      let delta = 0;
      if (edge in namedEdges) {
        edge = namedEdges[edge];
      }
      if (typeof edge === "string") {
        const asNumber2 = parseFloat(edge);
        if (edge.endsWith("px")) {
          delta = asNumber2;
        } else if (edge.endsWith("%")) {
          edge = asNumber2 / 100;
        } else if (edge.endsWith("vw")) {
          delta = asNumber2 / 100 * document.documentElement.clientWidth;
        } else if (edge.endsWith("vh")) {
          delta = asNumber2 / 100 * document.documentElement.clientHeight;
        } else {
          edge = asNumber2;
        }
      }
      if (typeof edge === "number") {
        delta = length * edge;
      }
      return inset + delta;
    }
    var defaultOffset = [0, 0];
    function resolveOffset(offset, containerLength, targetLength, targetInset) {
      let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;
      let targetPoint = 0;
      let containerPoint = 0;
      if (typeof offset === "number") {
        offsetDefinition = [offset, offset];
      } else if (typeof offset === "string") {
        offset = offset.trim();
        if (offset.includes(" ")) {
          offsetDefinition = offset.split(" ");
        } else {
          offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];
        }
      }
      targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);
      containerPoint = resolveEdge(offsetDefinition[1], containerLength);
      return targetPoint - containerPoint;
    }
    var ScrollOffset = {
      Enter: [
        [0, 1],
        [1, 1]
      ],
      Exit: [
        [0, 0],
        [1, 0]
      ],
      Any: [
        [1, 0],
        [0, 1]
      ],
      All: [
        [0, 0],
        [1, 1]
      ]
    };
    var point = { x: 0, y: 0 };
    function getTargetSize(target) {
      return "getBBox" in target && target.tagName !== "svg" ? target.getBBox() : { width: target.clientWidth, height: target.clientHeight };
    }
    function resolveOffsets(container, info, options) {
      const { offset: offsetDefinition = ScrollOffset.All } = options;
      const { target = container, axis = "y" } = options;
      const lengthLabel = axis === "y" ? "height" : "width";
      const inset = target !== container ? calcInset(target, container) : point;
      const targetSize = target === container ? { width: container.scrollWidth, height: container.scrollHeight } : getTargetSize(target);
      const containerSize = {
        width: container.clientWidth,
        height: container.clientHeight
      };
      info[axis].offset.length = 0;
      let hasChanged = !info[axis].interpolate;
      const numOffsets = offsetDefinition.length;
      for (let i = 0; i < numOffsets; i++) {
        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);
        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {
          hasChanged = true;
        }
        info[axis].offset[i] = offset;
      }
      if (hasChanged) {
        info[axis].interpolate = motionDom.interpolate(info[axis].offset, motionDom.defaultOffset(offsetDefinition), { clamp: false });
        info[axis].interpolatorOffsets = [...info[axis].offset];
      }
      info[axis].progress = motionUtils.clamp(0, 1, info[axis].interpolate(info[axis].current));
    }
    function measure(container, target = container, info) {
      info.x.targetOffset = 0;
      info.y.targetOffset = 0;
      if (target !== container) {
        let node = target;
        while (node && node !== container) {
          info.x.targetOffset += node.offsetLeft;
          info.y.targetOffset += node.offsetTop;
          node = node.offsetParent;
        }
      }
      info.x.targetLength = target === container ? target.scrollWidth : target.clientWidth;
      info.y.targetLength = target === container ? target.scrollHeight : target.clientHeight;
      info.x.containerLength = container.clientWidth;
      info.y.containerLength = container.clientHeight;
      if (true) {
        if (container && target && target !== container) {
          motionUtils.warnOnce(getComputedStyle(container).position !== "static", "Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.");
        }
      }
    }
    function createOnScrollHandler(element, onScroll, info, options = {}) {
      return {
        measure: () => measure(element, options.target, info),
        update: (time) => {
          updateScrollInfo(element, info, time);
          if (options.offset || options.target) {
            resolveOffsets(element, info, options);
          }
        },
        notify: () => onScroll(info)
      };
    }
    var scrollListeners = /* @__PURE__ */ new WeakMap();
    var resizeListeners = /* @__PURE__ */ new WeakMap();
    var onScrollHandlers = /* @__PURE__ */ new WeakMap();
    var getEventTarget = (element) => element === document.documentElement ? window : element;
    function scrollInfo(onScroll, { container = document.documentElement, ...options } = {}) {
      let containerHandlers = onScrollHandlers.get(container);
      if (!containerHandlers) {
        containerHandlers = /* @__PURE__ */ new Set();
        onScrollHandlers.set(container, containerHandlers);
      }
      const info = createScrollInfo();
      const containerHandler = createOnScrollHandler(container, onScroll, info, options);
      containerHandlers.add(containerHandler);
      if (!scrollListeners.has(container)) {
        const measureAll = () => {
          for (const handler of containerHandlers)
            handler.measure();
        };
        const updateAll = () => {
          for (const handler of containerHandlers) {
            handler.update(motionDom.frameData.timestamp);
          }
        };
        const notifyAll2 = () => {
          for (const handler of containerHandlers)
            handler.notify();
        };
        const listener2 = () => {
          motionDom.frame.read(measureAll, false, true);
          motionDom.frame.read(updateAll, false, true);
          motionDom.frame.preUpdate(notifyAll2, false, true);
        };
        scrollListeners.set(container, listener2);
        const target = getEventTarget(container);
        window.addEventListener("resize", listener2, { passive: true });
        if (container !== document.documentElement) {
          resizeListeners.set(container, resize(container, listener2));
        }
        target.addEventListener("scroll", listener2, { passive: true });
      }
      const listener = scrollListeners.get(container);
      motionDom.frame.read(listener, false, true);
      return () => {
        var _a;
        motionDom.cancelFrame(listener);
        const currentHandlers = onScrollHandlers.get(container);
        if (!currentHandlers)
          return;
        currentHandlers.delete(containerHandler);
        if (currentHandlers.size)
          return;
        const scrollListener = scrollListeners.get(container);
        scrollListeners.delete(container);
        if (scrollListener) {
          getEventTarget(container).removeEventListener("scroll", scrollListener);
          (_a = resizeListeners.get(container)) == null ? void 0 : _a();
          window.removeEventListener("resize", scrollListener);
        }
      };
    }
    var timelineCache = /* @__PURE__ */ new Map();
    function scrollTimelineFallback(options) {
      const currentTime = { value: 0 };
      const cancel = scrollInfo((info) => {
        currentTime.value = info[options.axis].progress * 100;
      }, options);
      return { currentTime, cancel };
    }
    function getTimeline({ source, container, ...options }) {
      const { axis } = options;
      if (source)
        container = source;
      const containerCache = timelineCache.get(container) ?? /* @__PURE__ */ new Map();
      timelineCache.set(container, containerCache);
      const targetKey = options.target ?? "self";
      const targetCache = containerCache.get(targetKey) ?? {};
      const axisKey = axis + (options.offset ?? []).join(",");
      if (!targetCache[axisKey]) {
        targetCache[axisKey] = !options.target && motionDom.supportsScrollTimeline() ? new ScrollTimeline({ source: container, axis }) : scrollTimelineFallback({ container, ...options });
      }
      return targetCache[axisKey];
    }
    function attachToAnimation(animation, options) {
      const timeline = getTimeline(options);
      return animation.attachTimeline({
        timeline: options.target ? void 0 : timeline,
        observe: (valueAnimation) => {
          valueAnimation.pause();
          return motionDom.observeTimeline((progress) => {
            valueAnimation.time = valueAnimation.duration * progress;
          }, timeline);
        }
      });
    }
    function isOnScrollWithInfo(onScroll) {
      return onScroll.length === 2;
    }
    function attachToFunction(onScroll, options) {
      if (isOnScrollWithInfo(onScroll)) {
        return scrollInfo((info) => {
          onScroll(info[options.axis].progress, info);
        }, options);
      } else {
        return motionDom.observeTimeline(onScroll, getTimeline(options));
      }
    }
    function scroll(onScroll, { axis = "y", container = document.documentElement, ...options } = {}) {
      if (container === document.documentElement && (axis === "y" && container.scrollHeight === container.clientHeight || axis === "x" && container.scrollWidth === container.clientWidth)) {
        container = document.body;
      }
      const optionsWithDefaults = { axis, container, ...options };
      return typeof onScroll === "function" ? attachToFunction(onScroll, optionsWithDefaults) : attachToAnimation(onScroll, optionsWithDefaults);
    }
    var thresholds = {
      some: 0,
      all: 1
    };
    function inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = "some" } = {}) {
      const elements = motionDom.resolveElements(elementOrSelector);
      const activeIntersections = /* @__PURE__ */ new WeakMap();
      const onIntersectionChange = (entries) => {
        entries.forEach((entry) => {
          const onEnd = activeIntersections.get(entry.target);
          if (entry.isIntersecting === Boolean(onEnd))
            return;
          if (entry.isIntersecting) {
            const newOnEnd = onStart(entry.target, entry);
            if (typeof newOnEnd === "function") {
              activeIntersections.set(entry.target, newOnEnd);
            } else {
              observer2.unobserve(entry.target);
            }
          } else if (typeof onEnd === "function") {
            onEnd(entry);
            activeIntersections.delete(entry.target);
          }
        });
      };
      const observer2 = new IntersectionObserver(onIntersectionChange, {
        root,
        rootMargin,
        threshold: typeof amount === "number" ? amount : thresholds[amount]
      });
      elements.forEach((element) => observer2.observe(element));
      return () => observer2.disconnect();
    }
    function getOriginIndex(from, total) {
      if (from === "first") {
        return 0;
      } else {
        const lastIndex = total - 1;
        return from === "last" ? lastIndex : lastIndex / 2;
      }
    }
    function stagger(duration = 0.1, { startDelay = 0, from = 0, ease } = {}) {
      return (i, total) => {
        const fromIndex = typeof from === "number" ? from : getOriginIndex(from, total);
        const distance = Math.abs(fromIndex - i);
        let delay = duration * distance;
        if (ease) {
          const maxDelay = total * duration;
          const easingFunction = motionUtils.easingDefinitionToFunction(ease);
          delay = easingFunction(delay / maxDelay) * maxDelay;
        }
        return startDelay + delay;
      };
    }
    var createMinimalMotionComponent = create.createMotionComponentFactory();
    var m = createDOMMotionComponentProxy(createMinimalMotionComponent);
    function useUnmountEffect(callback) {
      return React.useEffect(() => () => callback(), []);
    }
    var domAnimation = {
      renderer: create.createDomVisualElement,
      ...create.animations,
      ...create.gestureAnimations
    };
    var domMax = {
      ...domAnimation,
      ...create.drag,
      ...create.layout
    };
    var domMin = {
      renderer: create.createDomVisualElement,
      ...create.animations
    };
    function useMotionValueEvent(value, event, callback) {
      React.useInsertionEffect(() => value.on(event, callback), [value, event, callback]);
    }
    function refWarning(name, ref) {
      motionUtils.warning(Boolean(!ref || ref.current), `You have defined a ${name} options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its \`layoutEffect: false\` option.`);
    }
    var createScrollMotionValues = () => ({
      scrollX: motionDom.motionValue(0),
      scrollY: motionDom.motionValue(0),
      scrollXProgress: motionDom.motionValue(0),
      scrollYProgress: motionDom.motionValue(0)
    });
    function useScroll({ container, target, layoutEffect = true, ...options } = {}) {
      const values = create.useConstant(createScrollMotionValues);
      const useLifecycleEffect = layoutEffect ? create.useIsomorphicLayoutEffect : React.useEffect;
      useLifecycleEffect(() => {
        refWarning("target", target);
        refWarning("container", container);
        return scroll((_progress, { x, y }) => {
          values.scrollX.set(x.current);
          values.scrollXProgress.set(x.progress);
          values.scrollY.set(y.current);
          values.scrollYProgress.set(y.progress);
        }, {
          ...options,
          container: (container == null ? void 0 : container.current) || void 0,
          target: (target == null ? void 0 : target.current) || void 0
        });
      }, [container, target, JSON.stringify(options.offset)]);
      return values;
    }
    function useElementScroll(ref) {
      if (true) {
        motionUtils.warnOnce(false, "useElementScroll is deprecated. Convert to useScroll({ container: ref }).");
      }
      return useScroll({ container: ref });
    }
    function useViewportScroll() {
      if (true) {
        motionUtils.warnOnce(false, "useViewportScroll is deprecated. Convert to useScroll().");
      }
      return useScroll();
    }
    function useMotionTemplate(fragments, ...values) {
      const numFragments = fragments.length;
      function buildValue() {
        let output = ``;
        for (let i = 0; i < numFragments; i++) {
          output += fragments[i];
          const value = values[i];
          if (value) {
            output += create.isMotionValue(value) ? value.get() : value;
          }
        }
        return output;
      }
      return useCombineMotionValues(values.filter(create.isMotionValue), buildValue);
    }
    function useSpring(source, config = {}) {
      const { isStatic } = React.useContext(create.MotionConfigContext);
      const activeSpringAnimation = React.useRef(null);
      const initialValue = create.useConstant(() => create.isMotionValue(source) ? source.get() : source);
      const unit = create.useConstant(() => typeof initialValue === "string" ? initialValue.replace(/[\d.-]/g, "") : void 0);
      const value = useMotionValue(initialValue);
      const latestValue = React.useRef(initialValue);
      const latestSetter = React.useRef(motionUtils.noop);
      const startAnimation = () => {
        stopAnimation2();
        activeSpringAnimation.current = new motionDom.JSAnimation({
          keyframes: [asNumber(value.get()), asNumber(latestValue.current)],
          velocity: value.getVelocity(),
          type: "spring",
          restDelta: 1e-3,
          restSpeed: 0.01,
          ...config,
          onUpdate: latestSetter.current
        });
      };
      const stopAnimation2 = () => {
        if (activeSpringAnimation.current) {
          activeSpringAnimation.current.stop();
        }
      };
      React.useInsertionEffect(() => {
        return value.attach((v, set) => {
          if (isStatic)
            return set(v);
          latestValue.current = v;
          latestSetter.current = (latest) => set(parseValue(latest, unit));
          motionDom.frame.postRender(startAnimation);
          return value.get();
        }, stopAnimation2);
      }, [JSON.stringify(config)]);
      create.useIsomorphicLayoutEffect(() => {
        if (create.isMotionValue(source)) {
          return source.on("change", (v) => value.set(parseValue(v, unit)));
        }
      }, [value, unit]);
      return value;
    }
    function parseValue(v, unit) {
      return unit ? v + unit : v;
    }
    function asNumber(v) {
      return typeof v === "number" ? v : parseFloat(v);
    }
    function useAnimationFrame(callback) {
      const initialTimestamp = React.useRef(0);
      const { isStatic } = React.useContext(create.MotionConfigContext);
      React.useEffect(() => {
        if (isStatic)
          return;
        const provideTimeSinceStart = ({ timestamp, delta }) => {
          if (!initialTimestamp.current)
            initialTimestamp.current = timestamp;
          callback(timestamp - initialTimestamp.current, delta);
        };
        motionDom.frame.update(provideTimeSinceStart, true);
        return () => motionDom.cancelFrame(provideTimeSinceStart);
      }, [callback]);
    }
    function useTime() {
      const time = useMotionValue(0);
      useAnimationFrame((t) => time.set(t));
      return time;
    }
    function useVelocity(value) {
      const velocity = useMotionValue(value.getVelocity());
      const updateVelocity = () => {
        const latest = value.getVelocity();
        velocity.set(latest);
        if (latest)
          motionDom.frame.update(updateVelocity);
      };
      useMotionValueEvent(value, "change", () => {
        motionDom.frame.update(updateVelocity, false, true);
      });
      return velocity;
    }
    function getWillChangeName(name) {
      if (motionDom.transformProps.has(name)) {
        return "transform";
      } else if (motionDom.acceleratedValues.has(name)) {
        return create.camelToDash(name);
      }
    }
    var WillChangeMotionValue = class extends motionDom.MotionValue {
      constructor() {
        super(...arguments);
        this.values = [];
      }
      add(name) {
        const styleName = getWillChangeName(name);
        if (styleName) {
          motionUtils.addUniqueItem(this.values, styleName);
          this.update();
        }
      }
      update() {
        this.set(this.values.length ? this.values.join(", ") : "auto");
      }
    };
    function useWillChange() {
      return create.useConstant(() => new WillChangeMotionValue("auto"));
    }
    function useReducedMotion() {
      !create.hasReducedMotionListener.current && create.initPrefersReducedMotion();
      const [shouldReduceMotion] = React.useState(create.prefersReducedMotion.current);
      if (true) {
        motionUtils.warnOnce(shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected.");
      }
      return shouldReduceMotion;
    }
    function useReducedMotionConfig() {
      const reducedMotionPreference = useReducedMotion();
      const { reducedMotion } = React.useContext(create.MotionConfigContext);
      if (reducedMotion === "never") {
        return false;
      } else if (reducedMotion === "always") {
        return true;
      } else {
        return reducedMotionPreference;
      }
    }
    function stopAnimation(visualElement) {
      visualElement.values.forEach((value) => value.stop());
    }
    function setVariants(visualElement, variantLabels) {
      const reversedLabels = [...variantLabels].reverse();
      reversedLabels.forEach((key) => {
        const variant = visualElement.getVariant(key);
        variant && create.setTarget(visualElement, variant);
        if (visualElement.variantChildren) {
          visualElement.variantChildren.forEach((child) => {
            setVariants(child, variantLabels);
          });
        }
      });
    }
    function setValues(visualElement, definition) {
      if (Array.isArray(definition)) {
        return setVariants(visualElement, definition);
      } else if (typeof definition === "string") {
        return setVariants(visualElement, [definition]);
      } else {
        create.setTarget(visualElement, definition);
      }
    }
    function animationControls() {
      let hasMounted = false;
      const subscribers = /* @__PURE__ */ new Set();
      const controls = {
        subscribe(visualElement) {
          subscribers.add(visualElement);
          return () => void subscribers.delete(visualElement);
        },
        start(definition, transitionOverride) {
          motionUtils.invariant(hasMounted, "controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.");
          const animations = [];
          subscribers.forEach((visualElement) => {
            animations.push(create.animateVisualElement(visualElement, definition, {
              transitionOverride
            }));
          });
          return Promise.all(animations);
        },
        set(definition) {
          motionUtils.invariant(hasMounted, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.");
          return subscribers.forEach((visualElement) => {
            setValues(visualElement, definition);
          });
        },
        stop() {
          subscribers.forEach((visualElement) => {
            stopAnimation(visualElement);
          });
        },
        mount() {
          hasMounted = true;
          return () => {
            hasMounted = false;
            controls.stop();
          };
        }
      };
      return controls;
    }
    function useAnimate() {
      const scope = create.useConstant(() => ({
        current: null,
        // Will be hydrated by React
        animations: []
      }));
      const animate2 = create.useConstant(() => createScopedAnimate(scope));
      useUnmountEffect(() => {
        scope.animations.forEach((animation) => animation.stop());
      });
      return [scope, animate2];
    }
    function useAnimateMini() {
      const scope = create.useConstant(() => ({
        current: null,
        // Will be hydrated by React
        animations: []
      }));
      const animate2 = create.useConstant(() => createScopedWaapiAnimate(scope));
      useUnmountEffect(() => {
        scope.animations.forEach((animation) => animation.stop());
      });
      return [scope, animate2];
    }
    function useAnimationControls() {
      const controls = create.useConstant(animationControls);
      create.useIsomorphicLayoutEffect(controls.mount, []);
      return controls;
    }
    var useAnimation = useAnimationControls;
    function usePresenceData() {
      const context = React.useContext(create.PresenceContext);
      return context ? context.custom : void 0;
    }
    function useDomEvent(ref, eventName, handler, options) {
      React.useEffect(() => {
        const element = ref.current;
        if (handler && element) {
          return create.addDomEvent(element, eventName, handler, options);
        }
      }, [ref, eventName, handler, options]);
    }
    var DragControls = class {
      constructor() {
        this.componentControls = /* @__PURE__ */ new Set();
      }
      /**
       * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.
       *
       * @internal
       */
      subscribe(controls) {
        this.componentControls.add(controls);
        return () => this.componentControls.delete(controls);
      }
      /**
       * Start a drag gesture on every `motion` component that has this set of drag controls
       * passed into it via the `dragControls` prop.
       *
       * ```jsx
       * dragControls.start(e, {
       *   snapToCursor: true
       * })
       * ```
       *
       * @param event - PointerEvent
       * @param options - Options
       *
       * @public
       */
      start(event, options) {
        this.componentControls.forEach((controls) => {
          controls.start(event.nativeEvent || event, options);
        });
      }
    };
    var createDragControls = () => new DragControls();
    function useDragControls() {
      return create.useConstant(createDragControls);
    }
    function isMotionComponent(component) {
      return component !== null && typeof component === "object" && create.motionComponentSymbol in component;
    }
    function unwrapMotionComponent(component) {
      if (isMotionComponent(component)) {
        return component[create.motionComponentSymbol];
      }
      return void 0;
    }
    function useInstantLayoutTransition() {
      return startTransition;
    }
    function startTransition(callback) {
      if (!create.rootProjectionNode.current)
        return;
      create.rootProjectionNode.current.isUpdating = false;
      create.rootProjectionNode.current.blockUpdate();
      callback && callback();
    }
    function useResetProjection() {
      const reset = React.useCallback(() => {
        const root = create.rootProjectionNode.current;
        if (!root)
          return;
        root.resetTree();
      }, []);
      return reset;
    }
    function useCycle(...items) {
      const index = React.useRef(0);
      const [item, setItem] = React.useState(items[index.current]);
      const runCycle = React.useCallback(
        (next) => {
          index.current = typeof next !== "number" ? motionUtils.wrap(0, items.length, index.current + 1) : next;
          setItem(items[index.current]);
        },
        // The array will change on each call, but by putting items.length at
        // the front of this array, we guarantee the dependency comparison will match up
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [items.length, ...items]
      );
      return [item, runCycle];
    }
    function useInView(ref, { root, margin, amount, once = false, initial = false } = {}) {
      const [isInView, setInView] = React.useState(initial);
      React.useEffect(() => {
        if (!ref.current || once && isInView)
          return;
        const onEnter = () => {
          setInView(true);
          return once ? void 0 : () => setInView(false);
        };
        const options = {
          root: root && root.current || void 0,
          margin,
          amount
        };
        return inView(ref.current, onEnter, options);
      }, [root, ref, margin, once, amount]);
      return isInView;
    }
    function useInstantTransition() {
      const [forceUpdate, forcedRenderCount] = useForceUpdate();
      const startInstantLayoutTransition = useInstantLayoutTransition();
      const unlockOnFrameRef = React.useRef(-1);
      React.useEffect(() => {
        motionDom.frame.postRender(() => motionDom.frame.postRender(() => {
          if (forcedRenderCount !== unlockOnFrameRef.current)
            return;
          motionUtils.MotionGlobalConfig.instantAnimations = false;
        }));
      }, [forcedRenderCount]);
      return (callback) => {
        startInstantLayoutTransition(() => {
          motionUtils.MotionGlobalConfig.instantAnimations = true;
          forceUpdate();
          callback();
          unlockOnFrameRef.current = forcedRenderCount + 1;
        });
      };
    }
    function disableInstantTransitions() {
      motionUtils.MotionGlobalConfig.instantAnimations = false;
    }
    var appearAnimationStore = /* @__PURE__ */ new Map();
    var appearComplete = /* @__PURE__ */ new Map();
    var appearStoreId = (elementId, valueName) => {
      const key = motionDom.transformProps.has(valueName) ? "transform" : valueName;
      return `${elementId}: ${key}`;
    };
    function handoffOptimizedAppearAnimation(elementId, valueName, frame) {
      var _a;
      const storeId = appearStoreId(elementId, valueName);
      const optimisedAnimation = appearAnimationStore.get(storeId);
      if (!optimisedAnimation) {
        return null;
      }
      const { animation, startTime } = optimisedAnimation;
      function cancelAnimation() {
        var _a2;
        (_a2 = window.MotionCancelOptimisedAnimation) == null ? void 0 : _a2.call(window, elementId, valueName, frame);
      }
      animation.onfinish = cancelAnimation;
      if (startTime === null || ((_a = window.MotionHandoffIsComplete) == null ? void 0 : _a.call(window, elementId))) {
        cancelAnimation();
        return null;
      } else {
        return startTime;
      }
    }
    var startFrameTime;
    var readyAnimation;
    var suspendedAnimations = /* @__PURE__ */ new Set();
    function resumeSuspendedAnimations() {
      suspendedAnimations.forEach((data) => {
        data.animation.play();
        data.animation.startTime = data.startTime;
      });
      suspendedAnimations.clear();
    }
    function startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {
      if (window.MotionIsMounted) {
        return;
      }
      const id2 = element.dataset[create.optimizedAppearDataId];
      if (!id2)
        return;
      window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;
      const storeId = appearStoreId(id2, name);
      if (!readyAnimation) {
        readyAnimation = motionDom.startWaapiAnimation(
          element,
          name,
          [keyframes[0], keyframes[0]],
          /**
           * 10 secs is basically just a super-safe duration to give Chrome
           * long enough to get the animation ready.
           */
          { duration: 1e4, ease: "linear" }
        );
        appearAnimationStore.set(storeId, {
          animation: readyAnimation,
          startTime: null
        });
        window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;
        window.MotionHasOptimisedAnimation = (elementId, valueName) => {
          if (!elementId)
            return false;
          if (!valueName) {
            return appearComplete.has(elementId);
          }
          const animationId = appearStoreId(elementId, valueName);
          return Boolean(appearAnimationStore.get(animationId));
        };
        window.MotionHandoffMarkAsComplete = (elementId) => {
          if (appearComplete.has(elementId)) {
            appearComplete.set(elementId, true);
          }
        };
        window.MotionHandoffIsComplete = (elementId) => {
          return appearComplete.get(elementId) === true;
        };
        window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) => {
          const animationId = appearStoreId(elementId, valueName);
          const data = appearAnimationStore.get(animationId);
          if (!data)
            return;
          if (frame && canResume === void 0) {
            frame.postRender(() => {
              frame.postRender(() => {
                data.animation.cancel();
              });
            });
          } else {
            data.animation.cancel();
          }
          if (frame && canResume) {
            suspendedAnimations.add(data);
            frame.render(resumeSuspendedAnimations);
          } else {
            appearAnimationStore.delete(animationId);
            if (!appearAnimationStore.size) {
              window.MotionCancelOptimisedAnimation = void 0;
            }
          }
        };
        window.MotionCheckAppearSync = (visualElement, valueName, value) => {
          var _a, _b;
          const appearId = create.getOptimisedAppearId(visualElement);
          if (!appearId)
            return;
          const valueIsOptimised = (_a = window.MotionHasOptimisedAnimation) == null ? void 0 : _a.call(window, appearId, valueName);
          const externalAnimationValue = (_b = visualElement.props.values) == null ? void 0 : _b[valueName];
          if (!valueIsOptimised || !externalAnimationValue)
            return;
          const removeSyncCheck = value.on("change", (latestValue) => {
            var _a2;
            if (externalAnimationValue.get() !== latestValue) {
              (_a2 = window.MotionCancelOptimisedAnimation) == null ? void 0 : _a2.call(window, appearId, valueName);
              removeSyncCheck();
            }
          });
          return removeSyncCheck;
        };
      }
      const startAnimation = () => {
        readyAnimation.cancel();
        const appearAnimation = motionDom.startWaapiAnimation(element, name, keyframes, options);
        if (startFrameTime === void 0) {
          startFrameTime = performance.now();
        }
        appearAnimation.startTime = startFrameTime;
        appearAnimationStore.set(storeId, {
          animation: appearAnimation,
          startTime: startFrameTime
        });
        if (onReady)
          onReady(appearAnimation);
      };
      appearComplete.set(id2, false);
      if (readyAnimation.ready) {
        readyAnimation.ready.then(startAnimation).catch(motionUtils.noop);
      } else {
        startAnimation();
      }
    }
    var createObject = () => ({});
    var StateVisualElement = class extends create.VisualElement {
      constructor() {
        super(...arguments);
        this.measureInstanceViewportBox = create.createBox;
      }
      build() {
      }
      resetTransform() {
      }
      restoreTransform() {
      }
      removeValueFromRenderState() {
      }
      renderInstance() {
      }
      scrapeMotionValuesFromProps() {
        return createObject();
      }
      getBaseTargetFromProps() {
        return void 0;
      }
      readValueFromInstance(_state, key, options) {
        return options.initialState[key] || 0;
      }
      sortInstanceNodePosition() {
        return 0;
      }
    };
    var useVisualState = create.makeUseVisualState({
      scrapeMotionValuesFromProps: createObject,
      createRenderState: createObject
    });
    function useAnimatedState(initialState) {
      const [animationState, setAnimationState] = React.useState(initialState);
      const visualState = useVisualState({}, false);
      const element = create.useConstant(() => {
        return new StateVisualElement({
          props: {
            onUpdate: (v) => {
              setAnimationState({ ...v });
            }
          },
          visualState,
          presenceContext: null
        }, { initialState });
      });
      React.useLayoutEffect(() => {
        element.mount({});
        return () => element.unmount();
      }, [element]);
      const startAnimation = create.useConstant(() => (animationDefinition) => {
        return create.animateVisualElement(element, animationDefinition);
      });
      return [animationState, startAnimation];
    }
    var id = 0;
    var AnimateSharedLayout = ({ children }) => {
      React__namespace.useEffect(() => {
        motionUtils.invariant(false, "AnimateSharedLayout is deprecated: https://www.framer.com/docs/guide-upgrade/##shared-layout-animations");
      }, []);
      return jsxRuntime.jsx(LayoutGroup, { id: create.useConstant(() => `asl-${id++}`), children });
    };
    var maxScale = 1e5;
    var invertScale = (scale) => scale > 1e-3 ? 1 / scale : maxScale;
    var hasWarned = false;
    function useInvertedScale(scale) {
      let parentScaleX = useMotionValue(1);
      let parentScaleY = useMotionValue(1);
      const { visualElement } = React.useContext(create.MotionContext);
      motionUtils.invariant(!!(scale || visualElement), "If no scale values are provided, useInvertedScale must be used within a child of another motion component.");
      motionUtils.warning(hasWarned, "useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.");
      hasWarned = true;
      if (scale) {
        parentScaleX = scale.scaleX || parentScaleX;
        parentScaleY = scale.scaleY || parentScaleY;
      } else if (visualElement) {
        parentScaleX = visualElement.getValue("scaleX", 1);
        parentScaleY = visualElement.getValue("scaleY", 1);
      }
      const scaleX = useTransform(parentScaleX, invertScale);
      const scaleY = useTransform(parentScaleY, invertScale);
      return { scaleX, scaleY };
    }
    exports.FlatTree = create.FlatTree;
    exports.LayoutGroupContext = create.LayoutGroupContext;
    exports.MotionConfigContext = create.MotionConfigContext;
    exports.MotionContext = create.MotionContext;
    exports.PresenceContext = create.PresenceContext;
    exports.SwitchLayoutGroupContext = create.SwitchLayoutGroupContext;
    exports.VisualElement = create.VisualElement;
    exports.addPointerEvent = create.addPointerEvent;
    exports.addPointerInfo = create.addPointerInfo;
    exports.addScaleCorrector = create.addScaleCorrector;
    exports.animateVisualElement = create.animateVisualElement;
    exports.animations = create.animations;
    exports.buildTransform = create.buildTransform;
    exports.calcLength = create.calcLength;
    exports.createBox = create.createBox;
    exports.createRendererMotionComponent = create.createRendererMotionComponent;
    exports.delay = create.delay;
    exports.distance = create.distance;
    exports.distance2D = create.distance2D;
    exports.filterProps = create.filterProps;
    exports.isBrowser = create.isBrowser;
    exports.isMotionValue = create.isMotionValue;
    exports.isValidMotionProp = create.isValidMotionProp;
    exports.makeUseVisualState = create.makeUseVisualState;
    exports.optimizedAppearDataAttribute = create.optimizedAppearDataAttribute;
    exports.resolveMotionValue = create.resolveMotionValue;
    exports.useIsPresent = create.useIsPresent;
    exports.useIsomorphicLayoutEffect = create.useIsomorphicLayoutEffect;
    exports.usePresence = create.usePresence;
    exports.visualElementStore = create.visualElementStore;
    Object.defineProperty(exports, "MotionGlobalConfig", {
      enumerable: true,
      get: function() {
        return motionUtils.MotionGlobalConfig;
      }
    });
    exports.AnimatePresence = AnimatePresence;
    exports.AnimateSharedLayout = AnimateSharedLayout;
    exports.DeprecatedLayoutGroupContext = DeprecatedLayoutGroupContext;
    exports.DragControls = DragControls;
    exports.LayoutGroup = LayoutGroup;
    exports.LazyMotion = LazyMotion;
    exports.MotionConfig = MotionConfig;
    exports.Reorder = namespace;
    exports.WillChangeMotionValue = WillChangeMotionValue;
    exports.animate = animate;
    exports.animateMini = animateMini;
    exports.animationControls = animationControls;
    exports.createScopedAnimate = createScopedAnimate;
    exports.disableInstantTransitions = disableInstantTransitions;
    exports.domAnimation = domAnimation;
    exports.domMax = domMax;
    exports.domMin = domMin;
    exports.inView = inView;
    exports.isMotionComponent = isMotionComponent;
    exports.m = m;
    exports.motion = motion;
    exports.scroll = scroll;
    exports.scrollInfo = scrollInfo;
    exports.stagger = stagger;
    exports.startOptimizedAppearAnimation = startOptimizedAppearAnimation;
    exports.unwrapMotionComponent = unwrapMotionComponent;
    exports.useAnimate = useAnimate;
    exports.useAnimateMini = useAnimateMini;
    exports.useAnimation = useAnimation;
    exports.useAnimationControls = useAnimationControls;
    exports.useAnimationFrame = useAnimationFrame;
    exports.useCycle = useCycle;
    exports.useDeprecatedAnimatedState = useAnimatedState;
    exports.useDeprecatedInvertedScale = useInvertedScale;
    exports.useDomEvent = useDomEvent;
    exports.useDragControls = useDragControls;
    exports.useElementScroll = useElementScroll;
    exports.useForceUpdate = useForceUpdate;
    exports.useInView = useInView;
    exports.useInstantLayoutTransition = useInstantLayoutTransition;
    exports.useInstantTransition = useInstantTransition;
    exports.useMotionTemplate = useMotionTemplate;
    exports.useMotionValue = useMotionValue;
    exports.useMotionValueEvent = useMotionValueEvent;
    exports.usePresenceData = usePresenceData;
    exports.useReducedMotion = useReducedMotion;
    exports.useReducedMotionConfig = useReducedMotionConfig;
    exports.useResetProjection = useResetProjection;
    exports.useScroll = useScroll;
    exports.useSpring = useSpring;
    exports.useTime = useTime;
    exports.useTransform = useTransform;
    exports.useUnmountEffect = useUnmountEffect;
    exports.useVelocity = useVelocity;
    exports.useViewportScroll = useViewportScroll;
    exports.useWillChange = useWillChange;
    Object.keys(motionDom).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
        Object.defineProperty(exports, k, {
          enumerable: true,
          get: function() {
            return motionDom[k];
          }
        });
    });
    Object.keys(motionUtils).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
        Object.defineProperty(exports, k, {
          enumerable: true,
          get: function() {
            return motionUtils[k];
          }
        });
    });
  }
});

// node_modules/react-cursive-handwrite/dist/components/Loader.js
var require_Loader = __commonJS({
  "node_modules/react-cursive-handwrite/dist/components/Loader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateWordPath = exports.getLetterPath = exports.initializeFont = void 0;
    var parseSVG = (svgString) => {
      var _a;
      const parser = new DOMParser();
      const doc = parser.parseFromString(svgString, "image/svg+xml");
      const svg = doc.querySelector("svg");
      const path = doc.querySelector("path");
      if (!svg || !path) {
        throw new Error("Invalid SVG format");
      }
      const viewBox = ((_a = svg.getAttribute("viewBox")) == null ? void 0 : _a.split(" ").map(Number)) || [0, 0, 100, 100];
      const width = viewBox[2];
      const height = viewBox[3];
      let pathData = path.getAttribute("d") || "";
      pathData = pathData.replace(/\s+/g, " ").trim();
      pathData = pathData.replace(/([MLHVCSQTAZmlhvcsqtaz])(?=[^0-9\s])/g, "$1 ");
      return {
        path: pathData,
        width,
        height
      };
    };
    var letterPaths = {};
    var initializeFont = async (fontPath) => {
      console.log(`Initializing font with path: ${fontPath}`);
      if (letterPaths[fontPath]) {
        console.log(`Using cached paths for ${fontPath}`);
        return letterPaths[fontPath];
      }
      try {
        const paths = {};
        const letters = "abcdefghijklmnopqrstuvwxyz";
        const letterPromises = letters.split("").map(async (letter) => {
          try {
            const path = fontPath.startsWith("/") ? fontPath : `/${fontPath}`;
            const response = await fetch(`${path}/${letter}.svg`);
            if (!response.ok) {
              throw new Error(`Failed to load SVG for letter "${letter}": ${response.status} ${response.statusText}`);
            }
            const svgContent = await response.text();
            const parsedPath = parseSVG(svgContent);
            if (!(parsedPath == null ? void 0 : parsedPath.path)) {
              throw new Error(`Failed to parse SVG for letter "${letter}"`);
            }
            paths[letter] = parsedPath;
            console.log(` Successfully loaded SVG for letter "${letter}"`);
            return true;
          } catch (error) {
            console.error(` Error loading SVG for letter "${letter}":`, error);
            return false;
          }
        });
        const results = await Promise.allSettled(letterPromises);
        const successCount = results.filter((r) => r.status === "fulfilled" && r.value).length;
        if (successCount === 0) {
          throw new Error("Failed to load any letter SVGs");
        }
        console.log(`Loaded ${successCount} letter SVGs for font "${fontPath}"`);
        letterPaths[fontPath] = paths;
        return paths;
      } catch (error) {
        console.error("Error loading font:", error);
        throw error;
      }
    };
    exports.initializeFont = initializeFont;
    var getLetterPath = (letter, fontPaths) => {
      const lowerLetter = letter.toLowerCase();
      if (fontPaths[lowerLetter]) {
        return fontPaths[lowerLetter];
      }
      console.log(`No SVG path found for letter: "${letter}"`);
      return null;
    };
    exports.getLetterPath = getLetterPath;
    var generateWordPath = (word, fontPaths) => {
      console.log(`Generating path for word: "${word}" with ${Object.keys(fontPaths).length} available letters`);
      let path = "";
      let xOffset = 0;
      const letterSpacing = 5;
      let currentFill = "#000000";
      for (let i = 0; i < word.length; i++) {
        const letter = word[i].toLowerCase();
        console.log(`Processing letter "${letter}" at position ${i}`);
        if (letter === " ") {
          xOffset += 20;
          continue;
        }
        const letterData = (0, exports.getLetterPath)(letter, fontPaths);
        if (!letterData) {
          console.log(`Skipping missing letter: "${letter}"`);
          continue;
        }
        if (letterData.path) {
          currentFill = letterData.path.split(" ")[0].split(",")[3] || "#000000";
          console.log(`Letter "${letter}" path: ${letterData.path.substring(0, 50)}...`);
          const commands = letterData.path.split(/(?=[MLHVCSQTAZmlhvcsqtaz])/);
          let letterPathWithOffset = "";
          for (const cmd of commands) {
            if (!cmd)
              continue;
            const command = cmd[0];
            const params = cmd.slice(1).trim().split(/[\s,]+/).filter(Boolean);
            if (command === "Z" || command === "z") {
              letterPathWithOffset += command;
              continue;
            }
            let newParams = [];
            let isX = true;
            for (let i2 = 0; i2 < params.length; i2++) {
              const param = params[i2];
              if (!isNaN(parseFloat(param))) {
                if (isX && /[MLHVCSQTA]/.test(command)) {
                  newParams.push((parseFloat(param) + xOffset).toString());
                } else if (isX && /[mlhvcsqta]/.test(command)) {
                  if (i2 === 0) {
                    newParams.push((parseFloat(param) + xOffset).toString());
                  } else {
                    newParams.push(param);
                  }
                } else {
                  newParams.push(param);
                }
                isX = !isX;
              } else {
                newParams.push(param);
              }
            }
            letterPathWithOffset += command + newParams.join(" ");
          }
          if (!letterPathWithOffset.startsWith("M") && !letterPathWithOffset.startsWith("m")) {
            letterPathWithOffset = "M" + xOffset + " 0 " + letterPathWithOffset;
          }
          path += letterPathWithOffset;
          console.log(`Letter "${letter}" path with offset: ${letterPathWithOffset.substring(0, 50)}...`);
          xOffset += letterData.width + letterSpacing;
          console.log(`Updated xOffset to ${xOffset} for next letter`);
        }
      }
      path = path.replace(/([MLHVCSQTAZmlhvcsqtaz])\s+/g, "$1");
      path = path.replace(/\s+/g, " ");
      if (!path.startsWith("M") && !path.startsWith("m")) {
        path = "M0 0 " + path;
      }
      console.log(`Generated path length: ${path.length} characters`);
      console.log(`Final path: ${path.substring(0, 100)}...`);
      return { path, fill: currentFill };
    };
    exports.generateWordPath = generateWordPath;
  }
});

// node_modules/react-cursive-handwrite/dist/components/PathCreator.js
var require_PathCreator = __commonJS({
  "node_modules/react-cursive-handwrite/dist/components/PathCreator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.measurePath = exports.createPositionedPath = void 0;
    var createPositionedPath = (letterPath, xOffset) => {
      if (!(letterPath == null ? void 0 : letterPath.path)) {
        throw new Error("Invalid letter path provided");
      }
      try {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        const pathElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
        const cleanedPath = letterPath.path.trim().replace(/\s+/g, " ");
        if (!cleanedPath) {
          throw new Error("Empty path data");
        }
        pathElement.setAttribute("d", cleanedPath);
        svg.appendChild(pathElement);
        document.body.appendChild(svg);
        const bbox = pathElement.getBBox();
        document.body.removeChild(svg);
        if (isNaN(bbox.width) || isNaN(bbox.height)) {
          throw new Error("Invalid path dimensions");
        }
        const baselineOffset = letterPath.height - bbox.height;
        const positionedPath = `M${xOffset},${baselineOffset} ${cleanedPath}`;
        return {
          path: positionedPath,
          xOffset,
          width: letterPath.width,
          height: letterPath.height
        };
      } catch (error) {
        console.error("Error creating positioned path:", error);
        throw error;
      }
    };
    exports.createPositionedPath = createPositionedPath;
    var measurePath = (path) => {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      const pathElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
      pathElement.setAttribute("d", path);
      svg.appendChild(pathElement);
      document.body.appendChild(svg);
      const length = pathElement.getTotalLength();
      const bbox = pathElement.getBBox();
      document.body.removeChild(svg);
      return {
        length,
        width: bbox.width,
        height: bbox.height
      };
    };
    exports.measurePath = measurePath;
  }
});

// node_modules/react-cursive-handwrite/dist/components/QueueManager.js
var require_QueueManager = __commonJS({
  "node_modules/react-cursive-handwrite/dist/components/QueueManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueueManager = void 0;
    var PathCreator_1 = require_PathCreator();
    var QueueManager = class {
      constructor(letterPaths) {
        Object.defineProperty(this, "queue", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: []
        });
        Object.defineProperty(this, "currentIndex", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 0
        });
        Object.defineProperty(this, "letterPaths", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "addText", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (text) => {
            if (!text || typeof text !== "string") {
              throw new Error("Invalid text provided to addText");
            }
            let xOffset = 0;
            for (let i = 0; i < text.length; i++) {
              const letter = text[i].toLowerCase();
              if (letter === " ") {
                xOffset += 20;
                continue;
              }
              const letterData = this.letterPaths[letter];
              if (!letterData) {
                console.warn(`Missing letter: "${letter}"`);
                continue;
              }
              try {
                const positionedPath = (0, PathCreator_1.createPositionedPath)(letterData, xOffset);
                this.queue.push({
                  letter,
                  path: positionedPath,
                  isRendered: false,
                  order: i
                });
                xOffset += letterData.width;
              } catch (error) {
                console.error(`Error processing letter "${letter}":`, error);
                continue;
              }
            }
          }
        });
        Object.defineProperty(this, "getNextLetter", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: () => {
            if (this.currentIndex >= this.queue.length) {
              return null;
            }
            const nextLetter = this.queue[this.currentIndex];
            if (!nextLetter) {
              console.warn("Invalid letter at index:", this.currentIndex);
              return null;
            }
            this.currentIndex++;
            return nextLetter;
          }
        });
        Object.defineProperty(this, "markAsRendered", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (order) => {
            const letter = this.queue.find((l) => l.order === order);
            if (letter) {
              letter.isRendered = true;
            }
          }
        });
        Object.defineProperty(this, "isComplete", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: () => {
            return this.queue.every((letter) => letter.isRendered);
          }
        });
        Object.defineProperty(this, "getTotalLength", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: () => {
            return this.queue.reduce((sum, letter) => {
              var _a;
              return sum + (((_a = letter == null ? void 0 : letter.path) == null ? void 0 : _a.width) || 0);
            }, 0);
          }
        });
        Object.defineProperty(this, "getMaxHeight", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: () => {
            return Math.max(...this.queue.map((letter) => {
              var _a;
              return ((_a = letter == null ? void 0 : letter.path) == null ? void 0 : _a.height) || 0;
            }));
          }
        });
        Object.defineProperty(this, "reset", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: () => {
            this.queue = [];
            this.currentIndex = 0;
          }
        });
        if (!letterPaths || typeof letterPaths !== "object") {
          throw new Error("Invalid letter paths provided to QueueManager");
        }
        this.letterPaths = letterPaths;
      }
    };
    exports.QueueManager = QueueManager;
  }
});

// node_modules/react-cursive-handwrite/dist/components/HandwritingText.js
var require_HandwritingText = __commonJS({
  "node_modules/react-cursive-handwrite/dist/components/HandwritingText.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2)
            if (Object.prototype.hasOwnProperty.call(o2, k))
              ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++)
            if (k[i] !== "default")
              __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HandwritingText = void 0;
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = __importStar(require_react());
    var framer_motion_1 = require_cjs3();
    var Loader_1 = require_Loader();
    var QueueManager_1 = require_QueueManager();
    var HandwritingText2 = ({ children, strokeColor = "#000", strokeWidth = 2, duration = 3, as: Component = "div", fontPath = "google", debug = false }) => {
      const log = (...args) => {
        if (debug) {
          console.log("[HandwritingText]", ...args);
        }
      };
      const controls = (0, framer_motion_1.useAnimation)();
      const [letterPaths, setLetterPaths] = react_1.default.useState({});
      const [isLoading, setIsLoading] = react_1.default.useState(true);
      const [error, setError] = react_1.default.useState(null);
      const [dimensions, setDimensions] = react_1.default.useState({ width: 0, height: 0 });
      const [renderedLetters, setRenderedLetters] = (0, react_1.useState)([]);
      const [currentLetter, setCurrentLetter] = react_1.default.useState(null);
      const queueManagerRef = (0, react_1.useRef)(null);
      (0, react_1.useEffect)(() => {
        let mounted = true;
        setIsLoading(true);
        setError(null);
        const loadFont = async () => {
          try {
            if (!fontPath) {
              throw new Error("fontPath is required");
            }
            log(`Loading font from path: ${fontPath}`);
            const paths = await (0, Loader_1.initializeFont)(fontPath);
            if (!mounted)
              return;
            if (!paths || typeof paths !== "object") {
              throw new Error("Invalid font paths returned");
            }
            if (Object.keys(paths).length === 0) {
              log("Warning: No letter paths were loaded");
            } else {
              log(`Loaded ${Object.keys(paths).length} letter paths`);
            }
            setLetterPaths(paths);
            queueManagerRef.current = new QueueManager_1.QueueManager(paths);
            setIsLoading(false);
          } catch (error2) {
            log("Error loading font:", error2);
            if (mounted) {
              setError(`Failed to load font: ${error2 instanceof Error ? error2.message : String(error2)}`);
              setIsLoading(false);
            }
          }
        };
        loadFont();
        return () => {
          mounted = false;
        };
      }, [fontPath, debug]);
      (0, react_1.useEffect)(() => {
        if (isLoading || !queueManagerRef.current)
          return;
        const text = typeof children === "string" ? children : "";
        if (!text) {
          setError("No text content provided");
          return;
        }
        try {
          queueManagerRef.current.reset();
          queueManagerRef.current.addText(text);
          setRenderedLetters([]);
          const padding = 20;
          setDimensions({
            width: queueManagerRef.current.getTotalLength() + padding * 2,
            height: queueManagerRef.current.getMaxHeight() + padding * 2
          });
          const nextLetter = queueManagerRef.current.getNextLetter();
          if (nextLetter) {
            setCurrentLetter(nextLetter);
          }
        } catch (error2) {
          log("Error processing text:", error2);
          setError(`Failed to process text: ${error2 instanceof Error ? error2.message : String(error2)}`);
        }
      }, [children, letterPaths, isLoading]);
      const baselineY = Math.floor(dimensions.height * 0.75);
      (0, react_1.useEffect)(() => {
        if (!currentLetter)
          return;
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", currentLetter.path.path);
        svg.appendChild(path);
        document.body.appendChild(svg);
        const pathLength = path.getTotalLength();
        document.body.removeChild(svg);
        log(`Animating letter "${currentLetter.letter}" with length ${pathLength}`);
        const text = typeof children === "string" ? children : "";
        const letterDuration = duration / text.length * 1.25;
        controls.set({
          strokeDasharray: pathLength,
          strokeDashoffset: pathLength,
          opacity: 1
        });
        controls.start({
          strokeDashoffset: 0,
          opacity: 1,
          transition: {
            duration: letterDuration,
            ease: [0.33, 1, 0.68, 1]
            // Custom easing for smoother animation
          }
        }).then(() => {
          if (queueManagerRef.current) {
            setRenderedLetters((prev) => [...prev, currentLetter]);
            queueManagerRef.current.markAsRendered(currentLetter.order);
          }
        });
        const timer = setTimeout(() => {
          if (queueManagerRef.current) {
            const nextLetter = queueManagerRef.current.getNextLetter();
            if (nextLetter) {
              setCurrentLetter(nextLetter);
            }
          }
        }, letterDuration * 1e3 * 0.6);
        return () => clearTimeout(timer);
      }, [currentLetter, controls, duration, children]);
      const containerStyle = {
        position: "relative",
        display: "inline-block",
        width: dimensions.width || "auto",
        height: dimensions.height || "auto",
        minWidth: "100px",
        minHeight: "50px",
        opacity: isLoading ? 0 : 1,
        // Hide while loading
        transition: "opacity 0.3s ease-in"
        // Smooth fade in when ready
      };
      const svgStyle = {
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        overflow: "visible"
      };
      if (isLoading) {
        return (0, jsx_runtime_1.jsx)(Component, { style: containerStyle });
      }
      return (0, jsx_runtime_1.jsx)(Component, { style: containerStyle, children: error ? (0, jsx_runtime_1.jsx)("div", { style: { fontSize: "14px", color: "red", padding: "10px" }, children: debug ? error : "Error loading content" }) : (0, jsx_runtime_1.jsxs)("svg", { viewBox: `0 0 ${dimensions.width} ${dimensions.height}`, fill: "none", xmlns: "http://www.w3.org/2000/svg", style: svgStyle, preserveAspectRatio: "xMidYMid meet", children: [renderedLetters.map((letter, index) => (0, jsx_runtime_1.jsx)("path", { d: letter.path.path, stroke: strokeColor, strokeWidth, fill: "none", strokeLinecap: "round", strokeLinejoin: "round", transform: `translate(${letter.path.xOffset}, ${baselineY - letter.path.height})` }, `rendered-${index}`)), currentLetter && (0, jsx_runtime_1.jsx)(framer_motion_1.motion.path, { d: currentLetter.path.path, stroke: strokeColor, strokeWidth, fill: "none", strokeLinecap: "round", strokeLinejoin: "round", transform: `translate(${currentLetter.path.xOffset}, ${baselineY - currentLetter.path.height})`, initial: {
        strokeDasharray: 0,
        strokeDashoffset: 0,
        opacity: 0
      }, animate: controls })] }) });
    };
    exports.HandwritingText = HandwritingText2;
  }
});

// node_modules/react-cursive-handwrite/dist/index.mjs
var import_HandwritingText = __toESM(require_HandwritingText(), 1);
var export_HandwritingText = import_HandwritingText.HandwritingText;
export {
  export_HandwritingText as HandwritingText
};
/*! Bundled license information:

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=react-cursive-handwrite.js.map
