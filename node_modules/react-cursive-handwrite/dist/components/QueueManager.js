"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueueManager = void 0;
const PathCreator_1 = require("./PathCreator");
class QueueManager {
    constructor(letterPaths) {
        Object.defineProperty(this, "queue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "currentIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "letterPaths", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.letterPaths = letterPaths;
    }
    addText(text) {
        let xOffset = 0;
        for (let i = 0; i < text.length; i++) {
            const letter = text[i].toLowerCase();
            if (letter === ' ') {
                xOffset += 20; // Space width
                continue;
            }
            const letterData = this.letterPaths[letter];
            if (!letterData) {
                console.log(`Missing letter: "${letter}"`);
                continue;
            }
            const positionedPath = (0, PathCreator_1.createPositionedPath)(letterData, xOffset);
            this.queue.push({
                letter,
                path: positionedPath,
                isRendered: false,
                order: i
            });
            xOffset += letterData.width;
        }
    }
    getNextLetter() {
        if (this.currentIndex >= this.queue.length) {
            return null;
        }
        const nextLetter = this.queue[this.currentIndex];
        this.currentIndex++;
        return nextLetter;
    }
    markAsRendered(order) {
        const letter = this.queue.find(l => l.order === order);
        if (letter) {
            letter.isRendered = true;
        }
    }
    isComplete() {
        return this.queue.every(letter => letter.isRendered);
    }
    getTotalLength() {
        return this.queue.reduce((sum, letter) => {
            return sum + letter.path.width;
        }, 0);
    }
    getMaxHeight() {
        return Math.max(...this.queue.map(letter => letter.path.height));
    }
    reset() {
        this.queue = [];
        this.currentIndex = 0;
    }
}
exports.QueueManager = QueueManager;
