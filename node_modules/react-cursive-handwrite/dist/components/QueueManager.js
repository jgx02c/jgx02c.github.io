"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueueManager = void 0;
const PathCreator_1 = require("./PathCreator");
class QueueManager {
    constructor(letterPaths) {
        Object.defineProperty(this, "queue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "currentIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "letterPaths", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "addText", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (text) => {
                if (!text || typeof text !== 'string') {
                    throw new Error('Invalid text provided to addText');
                }
                let xOffset = 0;
                for (let i = 0; i < text.length; i++) {
                    const letter = text[i].toLowerCase();
                    if (letter === ' ') {
                        xOffset += 20; // Space width
                        continue;
                    }
                    const letterData = this.letterPaths[letter];
                    if (!letterData) {
                        console.warn(`Missing letter: "${letter}"`);
                        continue;
                    }
                    try {
                        const positionedPath = (0, PathCreator_1.createPositionedPath)(letterData, xOffset);
                        this.queue.push({
                            letter,
                            path: positionedPath,
                            isRendered: false,
                            order: i
                        });
                        xOffset += letterData.width;
                    }
                    catch (error) {
                        console.error(`Error processing letter "${letter}":`, error);
                        continue;
                    }
                }
            }
        });
        Object.defineProperty(this, "getNextLetter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                if (this.currentIndex >= this.queue.length) {
                    return null;
                }
                const nextLetter = this.queue[this.currentIndex];
                if (!nextLetter) {
                    console.warn('Invalid letter at index:', this.currentIndex);
                    return null;
                }
                this.currentIndex++;
                return nextLetter;
            }
        });
        Object.defineProperty(this, "markAsRendered", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (order) => {
                const letter = this.queue.find(l => l.order === order);
                if (letter) {
                    letter.isRendered = true;
                }
            }
        });
        Object.defineProperty(this, "isComplete", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                return this.queue.every(letter => letter.isRendered);
            }
        });
        Object.defineProperty(this, "getTotalLength", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                return this.queue.reduce((sum, letter) => {
                    return sum + (letter?.path?.width || 0);
                }, 0);
            }
        });
        Object.defineProperty(this, "getMaxHeight", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                return Math.max(...this.queue.map(letter => letter?.path?.height || 0));
            }
        });
        Object.defineProperty(this, "reset", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => {
                this.queue = [];
                this.currentIndex = 0;
            }
        });
        if (!letterPaths || typeof letterPaths !== 'object') {
            throw new Error('Invalid letter paths provided to QueueManager');
        }
        this.letterPaths = letterPaths;
    }
}
exports.QueueManager = QueueManager;
